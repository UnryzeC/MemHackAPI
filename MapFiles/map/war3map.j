//===========================================================================
// 
// MemHackAPI v1.7
// 
//   Warcraft III map script
//   Generated by the Warcraft III World Editor
//   Date: Sat Apr 30 00:22:09 2022
//   Map Author: Unryze & quq_CCCP
// 
//===========================================================================

//***************************************************************************
//*
//*  Global Variables
//*
//***************************************************************************

globals
    // Generated
    trigger                 gg_trg_APIBasicUtils       = null
    trigger                 gg_trg_APITypecast         = null
    trigger                 gg_trg_APIMemory           = null
    trigger                 gg_trg_APIMemoryCalls      = null
    trigger                 gg_trg_APIMemoryBitwise    = null
    trigger                 gg_trg_APIMemoryString     = null
    trigger                 gg_trg_APIMemoryKernel     = null
    trigger                 gg_trg_APIMemoryMPQ        = null
    trigger                 gg_trg_APIMemoryRestorer   = null
    trigger                 gg_trg_APIMemoryStormDLL   = null
    trigger                 gg_trg_APIMemoryGameData   = null
    trigger                 gg_trg_MemHackCObjectAPI   = null
    trigger                 gg_trg_APIMemoryGameUI     = null
    trigger                 gg_trg_APIMemoryGameUIButton = null
    trigger                 gg_trg_APIMemoryGameWindow = null
    trigger                 gg_trg_MemHackConstantsAPI = null
    trigger                 gg_trg_MemHackCFrameAPI    = null
    trigger                 gg_trg_MemHackCLayerAPI    = null
    trigger                 gg_trg_MemHackCLayoutFrameAPI = null
    trigger                 gg_trg_MemHackCBackDropFrameAPI = null
    trigger                 gg_trg_MemHackCEditBoxAPI  = null
    trigger                 gg_trg_MemHackCModelFrameAPI = null
    trigger                 gg_trg_MemHackCSimpleButtonAPI = null
    trigger                 gg_trg_MemHackCSimpleFontAPI = null
    trigger                 gg_trg_MemHackCSimpleGlueAPI = null
    trigger                 gg_trg_MemHackCSimpleFrameAPI = null
    trigger                 gg_trg_MemHackCSimpleMessageFrameAPI = null
    trigger                 gg_trg_MemHackCSliderAPI   = null
    trigger                 gg_trg_MemHackCSpriteFrameAPI = null
    trigger                 gg_trg_MemHackCTextAreaAPI = null
    trigger                 gg_trg_MemHackCTextFrameAPI = null
    trigger                 gg_trg_MemHackCSimpleStatusBarAPI = null
    trigger                 gg_trg_MemHackCStatusBarAPI = null
    trigger                 gg_trg_MemHackCSimpleTextureAPI = null
    trigger                 gg_trg_MemHackCSimpleRegionAPI = null
    trigger                 gg_trg_MemHackFrameAPI     = null
    trigger                 gg_trg_MemHackUIAPI        = null
    trigger                 gg_trg_MemHackPlayerAPI    = null
    trigger                 gg_trg_MemHackAbilityAddressAPI = null
    trigger                 gg_trg_MemHackAbilityBaseAPI = null
    trigger                 gg_trg_MemHackAbilityNormalAPI = null
    trigger                 gg_trg_MemHackAbilityUnitAPI = null
    trigger                 gg_trg_MemHackCastAbility  = null
    trigger                 gg_trg_MemHackWidgetBaseAPI = null
    trigger                 gg_trg_MemHackWidgetNormalAPI = null
    trigger                 gg_trg_MemHackEffectAPI    = null
    trigger                 gg_trg_MemHackTrackableAPI = null
    trigger                 gg_trg_MemHackItemBaseAPI  = null
    trigger                 gg_trg_MemHackItemNormalAPI = null
    trigger                 gg_trg_MemHackUnitBaseAPI  = null
    trigger                 gg_trg_MemHackUnitNormalAPI = null
    trigger                 gg_trg_MemHackGroupAPI     = null
    trigger                 gg_trg_MemHackMouseAPI     = null
    trigger                 gg_trg_InitMemoryHack      = null
    trigger                 gg_trg_InitMainHook        = null
    trigger                 gg_trg_TestHookedDamageEvent = null
    trigger                 gg_trg_MemHackDrawCooldown = null
    trigger                 gg_trg_MemHackDamageHook   = null
    trigger                 gg_trg_MemHackBerserkHook  = null
    trigger                 gg_trg_MemHackCustomAbilityChargesHook = null
    trigger                 gg_trg_Testing             = null
    trigger                 gg_trg_HandleAPI           = null
    trigger                 gg_trg_MemHackCSpriteUberAPI = null
    trigger                 gg_trg_MemHackCSpriteBaseAPI = null
    trigger                 gg_trg_MemHackCSpriteMiniAPI = null
endglobals

function InitGlobals takes nothing returns nothing
endfunction

//***************************************************************************
//*
//*  Unit Creation
//*
//***************************************************************************

//===========================================================================
function CreateUnitsForPlayer0 takes nothing returns nothing
    local player p = Player(0)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u = CreateUnit( p, 'hfoo', -263.7, 58.0, 99.627 )
    set u = CreateUnit( p, 'hfoo', -464.6, -68.5, 146.639 )
    set u = CreateUnit( p, 'hfoo', -354.3, -291.8, 81.741 )
    set u = CreateUnit( p, 'hfoo', -164.3, -319.0, 316.229 )
    set u = CreateUnit( p, 'hfoo', -103.5, -72.7, 111.053 )
    set u = CreateUnit( p, 'hfoo', -235.0, -75.7, 254.550 )
    set u = CreateUnit( p, 'Hvsh', 250.9, -254.6, 348.530 )
endfunction

//===========================================================================
function CreatePlayerBuildings takes nothing returns nothing
endfunction

//===========================================================================
function CreatePlayerUnits takes nothing returns nothing
    call CreateUnitsForPlayer0(  )
endfunction

//===========================================================================
function CreateAllUnits takes nothing returns nothing
    call CreatePlayerBuildings(  )
    call CreatePlayerUnits(  )
endfunction

//***************************************************************************
//*
//*  Triggers
//*
//***************************************************************************

//===========================================================================
// Trigger: APIBasicUtils
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library APIBasicUtils
    globals
        boolean IsPrint = false
        constant string sLetters = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
    endglobals

    function iabs takes integer number returns integer
        if number < 0 then
            return -number
        endif

        return number
    endfunction
    
    function fabs takes real r returns real
        if r < 0 then
            return -r
        endif

        return r
    endfunction
    
    function floor takes real r returns real
        if r < 0 then
            return -I2R( R2I( -r ) )
        endif
        
        return I2R( R2I( r ) )
    endfunction
    
    function ceil takes real r returns real
        if floor( r ) == r then
            return r
        elseif r < 0 then
            return -( I2R( R2I( -r ) ) + 1. )
        endif
        
        return I2R( R2I( r ) ) + 1.
    endfunction
    
    function round takes real r returns real
        if r > 0 then
            return I2R( R2I( r + .5 ) )
        endif
        
        return I2R( R2I( r - .5 ) )
    endfunction

    function log takes integer number, integer base returns integer
        local integer id = 1

        if number > 0 then
            loop
                exitwhen number / base <= 1
                set id = id + 1
                set number = number / base
            endloop

            return id
        endif

        return 0
    endfunction

    function PowI takes integer x, integer power returns integer
        local integer y = x

        if power == 0 then
            set x = 1
    elseif power > 1 then
            loop
                set power = power - 1
                exitwhen power == 0
                set x = x * y
            endloop
        endif

        return x
    endfunction

    function B2S takes boolean flag returns string
        if flag then
            return "yes"
        endif
        
        return "no"
    endfunction

    function CharToId takes string input returns integer
        local integer pos = 0
        local string char

        loop
            set char = SubString( sLetters, pos, pos + 1 )
            exitwhen char == null or char == input
            set pos = pos + 1
        endloop

        if pos < 10 then
            return pos + 48
        elseif pos < 36 then
            return pos + 65 - 10
        endif

        return pos + 97 - 36
    endfunction

    function StringToId takes string input returns integer
        return ( ( CharToId( SubString( input, 0, 1 ) ) * 256 + CharToId( SubString( input, 1, 2 ) ) ) * 256 + CharToId( SubString( input, 2, 3 ) ) ) * 256 + CharToId( SubString( input, 3, 4 ) )
    endfunction

    function IdToChar takes integer input returns string
        local integer pos = input - 48

        if input >= 97 then
            set pos = input - 97 + 36
        elseif input >= 65 then
            set pos = input - 65 + 10
        endif

        return SubString( sLetters, pos, pos + 1 )
    endfunction

    function IdToString takes integer input returns string
        local integer result = input / 256
        local string char    = IdToChar( input - 256 * result )

        set input  = result / 256
        set char   = IdToChar( result - 256 * input ) + char
        set result = input / 256

        return IdToChar( result ) + IdToChar( input - 256 * result ) + char
    endfunction

    function GetIntHex takes integer i returns string
        local string result = ""
        local integer numb  = iabs( i )

        if numb >= 0 and numb <= 15 then
            if numb <= 9 then
                set result = I2S( numb )
            elseif numb == 10 then
                set result = "A"
            elseif numb == 11 then
                set result = "B"
            elseif numb == 12 then
                set result = "C"
            elseif numb == 13 then
                set result = "D"
            elseif numb == 14 then
                set result = "E"
            elseif numb == 15 then
                set result = "F"
            endif
        endif

        return result
    endfunction

    function IntToHex takes integer i returns string
        local string result = ""
        local boolean ispos = i >= 0
        local integer numb  = iabs( i )
        local integer r     = 0
    
        loop
            exitwhen numb == 0
            set r = numb - ( numb / 16 ) * 16
            set result = GetIntHex( r ) + result
            set numb = ( numb - r ) / 16
        endloop

        set result = "0x" + result

        if not ispos then
            set result = "-" + result
        endif

        return result
    endfunction

    function PrintData takes string path, string s, boolean flag returns nothing
        if not IsPrint then
            call PreloadGenClear( )
            call PreloadGenStart( )
            set IsPrint = true
        endif

        if IsPrint then
            call Preload( s )

            if flag then
                call PreloadGenEnd( path )
                set IsPrint = false
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_APIBasicUtils takes nothing returns nothing
    //set gg_trg_APIBasicUtils = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: APITypecast
//===========================================================================
//TESH.scrollpos=240
//TESH.alwaysfold=0
//! nocjass
library APIAllTypecast
    globals
        code Code               // This is not used, it's here just to fool Jasshelper
        code l__Code
        integer Int             // This is not used, it's here just to fool Jasshelper
        integer l__Int
        string Str              // This is not used, it's here just to fool Jasshelper
        string l__Str
        boolean Bool            // This is not used, it's here just to fool Jasshelper
        boolean l__Bool
        handle Handle           // This is not used, it's here just to fool Jasshelper
        handle l__Handle
        unit Unit               // This is not used, it's here just to fool Jasshelper
        unit l__Unit
        ability Abil            // This is not used, it's here just to fool Jasshelper
        ability l__Abil
        trigger Trig            // This is not used, it's here just to fool Jasshelper
        trigger l__Trig
        integer Array           // This is not used, it's here just to fool Jasshelper
        integer array l__Array
        integer ArrayA          // This is not used, it's here just to fool Jasshelper
        integer array l__ArrayA
        integer ArrayB          // This is not used, it's here just to fool Jasshelper
        integer array l__ArrayB
        integer ArrayC          // This is not used, it's here just to fool Jasshelper
        integer array l__ArrayC
        integer ArrayD          // This is not used, it's here just to fool Jasshelper
        integer array l__ArrayD
        integer ArrayE          // This is not used, it's here just to fool Jasshelper
        integer array l__ArrayE
        integer bytecode        // This is not used, it's here just to fool Jasshelper
        integer array l__bytecode
        integer pbytecode

        hashtable MemHackTable = InitHashtable( )
    endglobals

    //# +nosemanticerror
    function InitBytecode takes integer id, integer k returns nothing
        set l__bytecode[  0 ] = 0x0C010900  // op: 0C(LITERAL), type: 09(integer array), reg: 01,
        set l__bytecode[  1 ] = k           // value: 0x2114D008
        set l__bytecode[  2 ] = 0x11010000  // op: 11(SETVAR), reg: 01
        set l__bytecode[  3 ] = id          // id of variable l__Memory
        set l__bytecode[  4 ] = 0x0C010400  // op: 0C(LITERAL), type: 04(integer), reg: 01, value: 0
        set l__bytecode[  6 ] = 0x27000000  // op: 27(RETURN)
        set l__bytecode[  8 ] = 0x07090000  // op: 07(GLOBAL), type: 09 (integer array) //Create new array
        set l__bytecode[  9 ] = 0x005E      // name: 5E("i") | old: C5F("stand")
        set l__bytecode[ 10 ] = 0x0E010400  // op: 0E(GETVAR), type: 04(integer), reg: 01 //Obtain the desired amount of bytes
        set l__bytecode[ 11 ] = id + 0x1    // id of variable bytecodedata (variable ids are sequential)
        set l__bytecode[ 12 ] = 0x12010100  // op: 12(SETARRAY), index=reg01, value=reg01 //Set index of the array, forcing allocation of memory
        set l__bytecode[ 13 ] = 0x005E      // name: 5E("i")
        set l__bytecode[ 14 ] = 0x0E010400  // op: 0E(GETVAR), type: 04(integer), reg: 01 //Read array variable as an integer
        set l__bytecode[ 15 ] = 0x005E      // name: 5E("i")
        set l__bytecode[ 16 ] = 0x11010000  // op: 11(SETVAR), reg: 01 //pass the value to the jass world
        set l__bytecode[ 17 ] = id + 0x1    // id of variable bytecodedata
        set l__bytecode[ 18 ] = 0x27000000  // op: 27(RETURN)
    endfunction
    //# +nosemanticerror
    function Typecast takes nothing returns nothing
        local integer bytecode // Jasshelper will implicitly rename this to l__bytecode
    endfunction
    //# +nosemanticerror
    function GetBytecodeAddress takes nothing returns integer
        loop
            return l__bytecode
        endloop
        
        return 0
    endfunction
    //# +nosemanticerror
    function InitArray takes integer vtable returns nothing
        set l__Array[ 4 ] = 0
        set l__Array[ 1 ] = vtable
        set l__Array[ 2 ] = -1
        set l__Array[ 3 ] = -1
    endfunction
    //# +nosemanticerror
    function InitArrayA takes integer index, integer valueA returns nothing
        set l__ArrayA[ 1000 ]        = 0
        set l__ArrayA[ index + 3 ] = valueA
        set l__ArrayA[ index + 2 ] = valueA
        set l__ArrayA[ index + 1 ] = valueA
        set l__ArrayA[ index     ] = valueA
        set l__ArrayA[ index - 1 ] = valueA
        set l__ArrayA[ index - 2 ] = valueA
        set l__ArrayA[ index - 3 ] = valueA
    endfunction

    //# +nosemanticerror
    function InitArrayB takes integer index, integer valueB returns nothing
        set l__ArrayB[ 1000 ]  = 0
        set l__ArrayB[ index ] = valueB
    endfunction

    //# +nosemanticerror
    function WriteArrayBMemory takes integer addr, integer value returns nothing
        local integer ii    = addr
        set l__ArrayB[ ii ] = value
    endfunction

    //# +nosemanticerror
    function InitArrayC takes integer valueC returns nothing
        set l__ArrayC[ 4 ] = 0
        set l__ArrayC[ 3 ] = valueC
        set l__ArrayC[ 2 ] = valueC
        set l__ArrayC[ 1 ] = valueC
        set l__ArrayC[ 0 ] = valueC
    endfunction

    //# +nosemanticerror
    function InitArrayD takes integer index, integer valueD returns nothing
        set l__ArrayD[ 1001 ]  = 0
        set l__ArrayD[ index ] = valueD
    endfunction

    //# +nosemanticerror
    function InitArrayE takes integer valueE returns nothing
        set l__ArrayE[ 4 ] = 0
        set l__ArrayE[ 3 ] = valueE
        set l__ArrayE[ 2 ] = valueE
        set l__ArrayE[ 1 ] = valueE
        set l__ArrayE[ 0 ] = valueE
    endfunction

    //# +nosemanticerror
    function TypecastArray takes nothing returns nothing //typecast Array to integer
        local integer Array // Jasshelper will implicitly rename this to l__Array
    endfunction

    //# +nosemanticerror
    function GetArrayAddress takes nothing returns integer
        loop
            return l__Array 
        endloop
        
        return 0
    endfunction

    //# +nosemanticerror
    function TypecastArrayA takes nothing returns nothing
        local integer ArrayA // Jasshelper will implicitly rename this to l__ArrayA
    endfunction

    //# +nosemanticerror
    function GetArrayAAddress takes nothing returns integer
        loop
            return l__ArrayA
        endloop

        return 0
    endfunction

    //# +nosemanticerror
    function TypecastArrayB takes nothing returns nothing
        local integer ArrayB // Jasshelper will implicitly rename this to l__ArrayB
    endfunction

    //# +nosemanticerror
    function GetArrayBAddress takes nothing returns integer
        loop
             return l__ArrayB
        endloop
        return 0
    endfunction

    //# +nosemanticerror
    function TypecastArrayC takes nothing returns nothing
        local integer ArrayC // Jasshelper will implicitly rename this to l__ArrayC
    endfunction 

    //# +nosemanticerror
    function GetArrayCAddress takes nothing returns integer
        loop
            return l__ArrayC
        endloop

        return 0
    endfunction

    //# +nosemanticerror
    function TypecastArrayD takes nothing returns nothing
        local integer ArrayD // Jasshelper will implicitly rename this to l__ArrayD
    endfunction 

    //# +nosemanticerror
    function GetArrayDAddress takes nothing returns integer
        loop
            return l__ArrayD
        endloop

        return 0
    endfunction

    //# +nosemanticerror
    function TypecastArrayE takes nothing returns nothing
        local integer ArrayE // Jasshelper will implicitly rename this to l__ArrayE
    endfunction 

    //# +nosemanticerror
    function GetArrayEAddress takes nothing returns integer
        loop
            return l__ArrayE
        endloop

        return 0
    endfunction
    
    //# +nosemanticerror
    function setCode takes code c returns nothing
        set l__Code = c

        return // Prevents Jasshelper from inlining this function
    endfunction
    //# +nosemanticerror
    function setInt takes integer i returns nothing
        set l__Int = i

        return // Prevents Jasshelper from inlining this function
    endfunction
    //# +nosemanticerror
    function setStr takes string s returns nothing
        set l__Str = s

        return // Prevents Jasshelper from inlining this function
    endfunction
    //# +nosemanticerror
    function setBool takes boolean b returns nothing
        set l__Bool = b

        return // Prevents Jasshelper from inlining this function
    endfunction
    //# +nosemanticerror
    function setHandle takes handle h returns nothing
        set l__Handle = h

        return // Prevents JassHelper from inlining this function
    endfunction
    //# +nosemanticerror
    function setUnit takes unit u returns nothing
        set l__Unit = u

        return // Prevents JassHelper from inlining this function
    endfunction
    //# +nosemanticerror
    function setAbility takes ability a returns nothing
        set l__Abil = a

        return // Prevents JassHelper from inlining this function
    endfunction
    //# +nosemanticerror
    function setTrig takes trigger t returns nothing
        set l__Trig = t

        return // Prevents Jasshelper from inlining this function
    endfunction
    //# +nosemanticerror
    function Typecast1 takes nothing returns nothing
        local integer Code // Jasshelper will implicitly rename this to l__Code
        local code Int     // Jasshelper will implicitly rename this to l__Int
    endfunction
    //# +nosemanticerror
    function C2I takes code c returns integer
        call setCode( c )
        
        loop
            return l__Code
        endloop
        
        return 0
    endfunction
    //# +nosemanticerror
    function I2C takes integer i returns code
        call setInt( i )

        loop 
            return l__Int
        endloop

        return null
    endfunction
    //# +nosemanticerror
    function Typecast2 takes nothing returns nothing
        local integer Str   // Jasshelper will implicitly rename this to l__Str
        local string Int    // Jasshelper will implicitly rename this to l__Int
    endfunction
    //# +nosemanticerror
    function SH2I takes string s returns integer
        call setStr( s )

        loop
            return l__Str
        endloop

        return 0
    endfunction
    //# +nosemanticerror
    function I2SH takes integer i returns string
        call setInt( i )

        loop 
            return l__Int
        endloop

        return null
    endfunction
    //# +nosemanticerror
    function Typecast3 takes nothing returns nothing
        local integer Bool // Jasshelper will implicitly rename this to l__Bool
        local boolean Int  // Jasshelper will implicitly rename this to l__Int
    endfunction
    //# +nosemanticerror
    function B2I takes boolean b returns integer
        call setBool( b )

        loop 
            return l__Bool
        endloop

        return 0
    endfunction
    //# +nosemanticerror
    function I2B takes integer i returns boolean
        call setInt( i )

        loop
            return l__Int
        endloop

        return false
    endfunction
    //# +nosemanticerror
    function Typecast4 takes nothing returns nothing
        local integer Handle    // Jasshelper will implicitly rename this to l__Handle
        local handle Int        // Jasshelper will implicitly rename this to l__Int
    endfunction
    //# +nosemanticerror
    function H2I takes handle h returns integer
        call setHandle( h )

        loop  
            return l__Handle
        endloop

        return 0
    endfunction
    //# +nosemanticerror
    function I2H takes integer i returns handle
        call setInt( i )

        loop  
            return l__Int
        endloop

        return null
    endfunction
    //# +nosemanticerror
    function Typecast5 takes nothing returns nothing
        local integer Unit  // Jasshelper will implicitly rename this to l__Unit
        local unit Int      // Jasshelper will implicitly rename this to l__Int
    endfunction
    //# +nosemanticerror
    function U2I takes unit u returns integer
        call setUnit( u )

        loop  
            return l__Unit
        endloop

        return 0
    endfunction
    //# +nosemanticerror
    function I2U takes integer i returns unit
        call setInt( i )

        loop  
            return l__Int
        endloop

        return null
    endfunction
    //# +nosemanticerror
    function Typecast6 takes nothing returns nothing
        local integer Abil  // Jasshelper will implicitly rename this to l__Abil
        local ability Int   // Jasshelper will implicitly rename this to l__Int
    endfunction
    //# +nosemanticerror
    function A2I takes ability a returns integer
        call setAbility( a )

        loop  
            return l__Abil
        endloop

        return 0
    endfunction
    //# +nosemanticerror
    function I2A takes integer i returns ability
        call setInt( i )

        loop  
            return l__Int
        endloop

        return null
    endfunction
    //# +nosemanticerror
    function Typecast7 takes nothing returns nothing
        local integer Trig // Jasshelper will implicitly rename this to l__Trig
        local trigger Int  // Jasshelper will implicitly rename this to l__Int
    endfunction
    //# +nosemanticerror
    function T2I takes trigger t returns integer
        call setTrig( t )

        loop  
            return l__Trig
        endloop

        return 0
    endfunction
    //# +nosemanticerror
    function I2T takes integer i returns trigger
        call setInt( i )

        return l__Int
    endfunction
    //# +nosemanticerror
    function RealToIndex takes real r returns integer
        loop
            return r
        endloop

        return 0
    endfunction
    //# +nosemanticerror
    function CleanInt takes integer i returns integer
        return i
    endfunction
    //# +nosemanticerror
    function IndexToReal takes integer i returns real
        loop
            return i
        endloop

        return 0.
    endfunction
    //# +nosemanticerror
    function CleanReal takes real r returns real
        return r
    endfunction
    //# +nosemanticerror
    function GetRealFromMemory takes integer i returns real
        return CleanReal( IndexToReal( i ) )
    endfunction
    //# +nosemanticerror
    function SetRealIntoMemory takes real r returns integer
        return CleanInt( RealToIndex( r ) )
    endfunction
    //# +nosemanticerror
    function BitwiseNot takes integer i returns integer
        return 0xFFFFFFFF - i
    endfunction
    
    function Init_APITypecast takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
        elseif PatchVersion == "1.26a" then
        elseif PatchVersion == "1.27a" then
        elseif PatchVersion == "1.27b" then
        elseif PatchVersion == "1.28f" then
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_APITypecast takes nothing returns nothing
    //set gg_trg_APITypecast = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: APIMemory
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library APIMemory
    globals
    //  integer NULL                        = 0 // Might be used later.
        integer iGameVersion                = 0
        integer pMemory                     = 0
        integer array RJassNativesBuffer
        integer Memory // This is not used, it's here just to fool Jasshelper
        integer array l__Memory
        integer iBytecodeData

        integer pReservedIntArg1
        integer pReservedIntArg2
        integer pReservedIntArg3
        integer pReservedIntArg4

        integer pPointers                   = 0
        integer pWriteMemory                = 0
        integer pReservedWritableMemory     = 0
        integer pReservedWritableMemory2    = 0
        integer pJassEnvAddress             = 0
        integer RJassNativesBufferSize      = 0
        
        integer JassVM                      = 0
        integer JassTable                   = 0
        
        integer pUnlockCall1                = 0
        integer pUnlockCall2                = 0
        integer pUnlockJmp1                 = 0
    endglobals

    function GetByteFromInteger takes integer i, integer byteid returns integer
        local integer tmpval = i
        local integer retval = 0
        local integer byte1  = 0
        local integer byte2  = 0
        local integer byte3  = 0
        local integer byte4  = 0
        
        if tmpval < 0 then
            set tmpval = BitwiseNot( tmpval )
            set byte4  = 255 - ModuloInteger( tmpval, 256 )
            set tmpval = tmpval / 256
            set byte3  = 255 - ModuloInteger( tmpval, 256 )
            set tmpval = tmpval / 256
            set byte2  = 255 - ModuloInteger( tmpval, 256 )
            set tmpval = tmpval / 256
            set byte1  = 255 - tmpval
        else
            set byte4  =  ModuloInteger( tmpval, 256)
            set tmpval = tmpval / 256
            set byte3  =  ModuloInteger( tmpval, 256)
            set tmpval = tmpval / 256
            set byte2  =  ModuloInteger( tmpval, 256)
            set tmpval = tmpval / 256
            set byte1  = tmpval
        endif

        if byteid == 1 then
            return byte1
        elseif byteid == 2 then
            return byte2
        elseif byteid == 3 then
            return byte3
        elseif byteid == 4 then
            return byte4
        endif

        return retval
    endfunction

    function CreateInteger1 takes integer byte1, integer byte2, integer byte3, integer byte4 returns integer
        local integer retval = byte1
        
        set retval = ( retval * 256 ) + byte2
        set retval = ( retval * 256 ) + byte3
        set retval = ( retval * 256 ) + byte4
        
        return retval
    endfunction

    // addr 0x10000 data 1C 2C 8A 7D 6D 5F 5A 4C 6C 3C 8C 7A
    // read memory at 0x10003   ( 7D 6D 5F 5A )
    function CreateIntegerFromTwoByOffset takes integer LocalInteger1, integer LocalInteger2, integer offset returns integer
        local integer array pBytes
        
        set pBytes[ 0 ] = GetByteFromInteger( LocalInteger1, 4 )
        set pBytes[ 1 ] = GetByteFromInteger( LocalInteger1, 3 )
        set pBytes[ 2 ] = GetByteFromInteger( LocalInteger1, 2 )
        set pBytes[ 3 ] = GetByteFromInteger( LocalInteger1, 1 )
        set pBytes[ 4 ] = GetByteFromInteger( LocalInteger2, 4 )
        set pBytes[ 5 ] = GetByteFromInteger( LocalInteger2, 3 )
        set pBytes[ 6 ] = GetByteFromInteger( LocalInteger2, 2 )
        set pBytes[ 7 ] = GetByteFromInteger( LocalInteger2, 1 )
        
        return CreateInteger1( pBytes[ offset + 3 ], pBytes[ offset + 2 ], pBytes[ offset + 1 ], pBytes[ offset + 0 ] )
    endfunction

    function CreateDoubleIntegerAndGetOne takes integer LocalInteger1, integer LocalInteger2, integer value, integer offset, boolean first returns integer
        local integer array pBytes

        set pBytes[ 0 ] = GetByteFromInteger( LocalInteger1, 4 )
        set pBytes[ 1 ] = GetByteFromInteger( LocalInteger1, 3 )
        set pBytes[ 2 ] = GetByteFromInteger( LocalInteger1, 2 )
        set pBytes[ 3 ] = GetByteFromInteger( LocalInteger1, 1 )
        set pBytes[ 4 ] = GetByteFromInteger( LocalInteger2, 4 )
        set pBytes[ 5 ] = GetByteFromInteger( LocalInteger2, 3 )
        set pBytes[ 6 ] = GetByteFromInteger( LocalInteger2, 2 )
        set pBytes[ 7 ] = GetByteFromInteger( LocalInteger2, 1 )

        set pBytes[ offset + 0 ] = GetByteFromInteger( value, 4 )
        set pBytes[ offset + 1 ] = GetByteFromInteger( value, 3 )
        set pBytes[ offset + 2 ] = GetByteFromInteger( value, 2 )
        set pBytes[ offset + 3 ] = GetByteFromInteger( value, 1 )

        if first then
            return CreateInteger1( pBytes[ 3 ], pBytes[ 2 ], pBytes[ 1 ], pBytes[ 0 ] )
        else
            return CreateInteger1( pBytes[ 7 ], pBytes[ 6 ], pBytes[ 5 ], pBytes[ 4 ] )
        endif
    endfunction

    function ReadMemory takes integer address returns integer
        return l__Memory[ address / 4 ]
    endfunction

    function ReadRealMemorySafe takes integer addr returns integer
        local integer ByteOffset = addr - ( addr / 4 * 4 )
        local integer FirstAddr = addr - ByteOffset
        
        return CreateIntegerFromTwoByOffset( l__Memory[ FirstAddr / 4 ], l__Memory[ FirstAddr / 4 + 1 ] , ByteOffset )
    endfunction

    function ReadUnrealMemory takes integer address returns integer
        if address * 4 < 0x7Fffffff and address > 0x500 then
            return l__Memory[ address ]
        endif

        return 0
    endfunction

    function ReadRealMemory takes integer address returns integer
        if address < 0x500 or address > 0x7FFFFFFF then // MINIMAL_ACCESSABLE_ADDRESS
            return 0
        endif

        if pGetUnitCountOffset != 0 then
            return GetUnitCount( address )
        endif

        if address / 4 * 4 != address then
            return ReadRealMemorySafe( address )
        else
            return ReadMemory( address )
        endif
    endfunction

    function RMem takes integer address returns integer
        return ReadRealMemory( address )
    endfunction
    
    function ReadOffset takes integer pOff returns integer
        return ReadRealMemory( pGameDLL + pOff )
    endfunction

    function ReadOffsetUnsafe takes integer pOff returns integer
        return ReadUnrealMemory( ( pGameDLL + pOff ) / 4 )
    endfunction

    function ReadByte takes integer byte returns integer
        return GetByteFromInteger( ReadRealMemory( byte ), 4 )
    endfunction
    
    function ReadRealFloat takes integer address returns real
        return GetRealFromMemory( ReadRealMemory( address ) )
    endfunction

    function WriteMemory takes integer address, integer value returns nothing
        set l__Memory[ address / 4 ] = value
    endfunction

    function WriteRealMemorySafe takes integer addr, integer val returns nothing
        local integer Int_1
        local integer Int_2
        local integer ByteOffset = addr - ( addr / 4 * 4 )
        local integer FirstAddr = addr - ByteOffset

        set Int_1                           = ReadRealMemory( FirstAddr )
        set Int_2                           = ReadRealMemory( FirstAddr + 0x4 )
        set l__Memory[ FirstAddr / 4 ]      = CreateDoubleIntegerAndGetOne( Int_1, Int_2, val, ByteOffset, true )
        set l__Memory[ FirstAddr / 4 + 1 ]  = CreateDoubleIntegerAndGetOne( Int_1, Int_2, val, ByteOffset, false )
    endfunction

    function WriteUnrealMemory takes integer address, integer value returns nothing
        if address > 0x500 and address * 4 < 0x7FFFFFFF then
            set l__Memory[ address ] = value
            return
        endif
    endfunction

    function WriteRealMemory takes integer address, integer value returns nothing
        if address < 0x500 or address > 0x7FFFFFFF then // MINIMAL_ACCESSABLE_ADDRESS = 0x500
            return
        endif

        if address == pWriteMemory then
            return
        endif

        if pAttackMoveXYOffset != 0 then
            call AttackMoveXY( address, value )
            return
        endif        

        if address / 4 * 4 != address then
            call WriteRealMemorySafe( address, value )
        else
            call WriteMemory( address, value )
        endif
    endfunction

    function WMem takes integer address, integer value returns nothing
        call WriteRealMemory( address, value )
    endfunction
    
    function WriteOffset takes integer pOff, integer value returns nothing
        call WriteRealMemory( pGameDLL + pOff, value )
    endfunction

    function WriteOffsetUnsafe takes integer pOff, integer value returns nothing
        call WriteUnrealMemory( pGameDLL + pOff, value )
    endfunction

    function WriteRealFloat takes integer address, real value returns nothing
        call WriteRealMemory( address, SetRealIntoMemory( value ) )
    endfunction
    //# +nosemanticerror
    function NewGlobal takes nothing returns integer
        return -0x005E0704  //op: 07(GLOBAL), type: 04(integer), name: 0x005E("i")
        return 0x2700       //op: 27(RETURN)
    endfunction

    //# +nosemanticerror
    function SetGlobal takes nothing returns nothing
        //This will actually set the value of the global variable, not the local
        local integer i = 0x2114D008
    endfunction

    function Malloc takes integer bytes returns integer
        set iBytecodeData = bytes / 4 + 0x4
        call ForForce( bj_FORCE_PLAYER[ 0 ], I2C( l__Memory[ GetBytecodeAddress( ) / 4 + 0x3 ] + 0x20 ) )
        return ( ReadUnrealMemory( iBytecodeData / 4 + 0x3 ) + 0x4 ) / 4 * 4 // Address of data in the newly created array
    endfunction

    function ConvertPointer takes integer ptr returns integer
        local integer i = ReadRealMemory( ptr )

        if i < 0 then
            return ReadRealMemory( ReadRealMemory( pPointers + 0x2C ) - i * 8 + 0x4 ) //checkme
        endif

        return ReadRealMemory( ReadRealMemory( pPointers + 0xC ) + i * 8 + 0x4 )
    endfunction

    function ReadRealPointer1LVL takes integer addr, integer offset1 returns integer
        local integer retval = 0
        
        if addr > 0 then
            set retval = ReadRealMemory( addr )
            
            if addr > 0 then
                set retval = ReadRealMemory( retval + offset1 )
            else
                set retval = 0
            endif
        endif
        
        return retval
    endfunction

    function WriteRealPointer1LVL takes integer addr, integer offset1, integer val returns nothing
        local integer retval = 0

        if addr > 0 then 
            set retval = ReadRealMemory( addr )

            if addr > 0 then 
                call WriteRealMemory( retval + offset1, val )
            endif
        endif
    endfunction

    function ReadRealPointer2LVL takes integer addr, integer offset1, integer offset2 returns integer
        local integer retval = ReadRealPointer1LVL( addr, offset1 )
        
        if retval > 0 then
            set retval = ReadRealMemory( retval + offset2 )
        else
            set retval = 0
        endif
        
        return retval
    endfunction

    function WriteRealPointer2LVL takes integer addr, integer offset1, integer offset2, integer val returns nothing
        local integer retval = 0

        if addr > 0 then 
            set retval = ReadRealPointer1LVL( addr, offset1 )

            if addr > 0 then 
                call WriteRealMemory( retval + offset2, val )
            endif
        endif
    endfunction 

    function ReadRealPointer3LVL takes integer addr, integer offset1, integer offset2, integer offset3 returns integer
        local integer retval = ReadRealPointer2LVL( addr, offset1, offset2 )

        if retval > 0 then 
            set retval = ReadRealMemory( retval + offset3 )
        else
            set retval = 0
        endif

        return retval
    endfunction

    function WriteRealPointer3LVL takes integer addr, integer offset1, integer offset2, integer offset3, integer val returns nothing
        local integer retval = 0

        if addr > 0 then 
            set retval = ReadRealPointer2LVL( addr, offset1, offset2 )

            if addr > 0 then 
                call WriteRealMemory( retval + offset3, val )
            endif
        endif
    endfunction

    function ReadRealPointer4LVL takes integer addr, integer offset1, integer offset2, integer offset3, integer offset4 returns integer
        local integer retval = ReadRealPointer3LVL( addr, offset1, offset2, offset3 )

        if retval > 0 then 
            set retval = ReadRealMemory( retval + offset4 )
        else
            set retval = 0
        endif

        return retval
    endfunction

    function WriteRealPointer4LVL takes integer addr, integer offset1, integer offset2, integer offset3, integer offset4, integer val returns nothing
        local integer retval = 0

        if addr > 0 then 
            set retval = ReadRealPointer3LVL( addr, offset1, offset2, offset3 )

            if addr > 0 then 
                call WriteRealMemory( retval + offset4, val )
            endif
        endif
    endfunction

    function ReadRealPointer5LVL takes integer addr, integer offset1, integer offset2, integer offset3, integer offset4, integer offset5 returns integer
        local integer retval = ReadRealPointer4LVL( addr, offset1, offset2, offset3, offset4 )

        if retval > 0 then 
            set retval = ReadRealMemory( retval + offset5 )
        else
            set retval = 0
        endif

        return retval
    endfunction

    function WriteRealPointer5LVL takes integer addr, integer offset1, integer offset2,integer offset3, integer offset4,integer offset5, integer val returns nothing
        local integer retval = 0

        if addr > 0 then 
            set retval = ReadRealPointer4LVL( addr, offset1, offset2, offset3, offset4 )

            if addr > 0 then 
                call WriteRealMemory( retval + offset5, val )
            endif
        endif
    endfunction

    function IsJassNativeExists takes integer nativeaddress returns boolean
        local integer FirstAddress = ReadRealPointer2LVL( pJassEnvAddress, 0x14, 0x20 )
        local integer NextAddress = FirstAddress
        local integer i = 0

        loop 
            if ReadRealMemory( NextAddress + 0xC ) == nativeaddress then
                return NextAddress > 0
            endif
            
            set NextAddress = ReadRealMemory( NextAddress )
            if NextAddress == FirstAddress or NextAddress == 0 then
                return false
            endif
        endloop

        return false
    endfunction

    function CreateJassNativeHook takes integer oldaddress, integer newaddress returns integer
        local integer FirstAddress    = ReadRealPointer2LVL( pJassEnvAddress, 0x14, 0x20 )
        local integer NextAddress     = FirstAddress
        local integer i = 0
     
        if RJassNativesBufferSize > 0 then
            loop
                set i = i + 1
           
                if RJassNativesBuffer[ i * 3 - 0x3 ] == oldaddress or RJassNativesBuffer[ i * 3 - 0x2 ] == oldaddress or RJassNativesBuffer[ i * 3 - 0x3 ] == newaddress or RJassNativesBuffer[ i * 3 - 0x2 ] == newaddress then
                    call WriteRealMemory( RJassNativesBuffer[ i * 3 - 0x1 ], newaddress )
                    return RJassNativesBuffer[ i * 3 - 0x1 ]
                endif
           
                exitwhen i == RJassNativesBufferSize
            endloop
        endif
     
        loop
            if ReadRealMemory( NextAddress + 0xC ) < 0x3000 then
                return 0
            endif
            
            if ReadRealMemory( NextAddress + 0xC ) == oldaddress then
                call WriteRealMemory( NextAddress + 0xC, newaddress )

                if RJassNativesBufferSize < 100 then
                    set RJassNativesBufferSize = RJassNativesBufferSize + 1
                    set RJassNativesBuffer[ RJassNativesBufferSize * 3 - 0x1 ] = NextAddress + 0xC
                    set RJassNativesBuffer[ RJassNativesBufferSize * 3 - 0x2 ] = oldaddress
                    set RJassNativesBuffer[ RJassNativesBufferSize * 3 - 0x3 ] = newaddress
                endif
           
                return NextAddress + 0xC
            endif
       
            set NextAddress = ReadRealMemory( NextAddress )
            if NextAddress == FirstAddress or NextAddress == 0 then
                return 0
            endif
        endloop
        
        return 0
    endfunction

    function GetJassVM takes integer id returns integer
        local integer result = 0

        if pJassEnvAddress > 0 then
            set result = ReadRealMemory( ReadRealMemory( ReadRealMemory( ReadRealMemory( pJassEnvAddress ) + 0x14 ) + 0x90 ) + 0x4 * id )

            if id == 1 then
                if JassVM <= 0 then
                    set JassVM = result
                endif
            endif
        endif

        return result
    endfunction

    function GetJassTable takes nothing returns integer
        local integer jvm = GetJassVM( 1 )

        if jvm > 0 then
            return ReadRealMemory( ReadRealMemory( ReadRealMemory( jvm + 0x28A4 ) ) + 0x19C )
        endif

        return 0
    endfunction

    function GetStringAddress takes string s returns integer
        local integer jvm = GetJassVM( 1 )

        if jvm > 0 then
            return ReadRealMemory( ReadRealMemory( ReadRealMemory( ReadRealMemory( jvm + 0x2874 ) + 0x8 ) + SH2I( s ) * 0x10 + 0x8 ) + 0x1C )
        endif

        return 0
    endfunction

    //# +nosemanticerror
    function InitMemoryArray takes integer id, integer val returns nothing
        set l__Memory[ id ] = val
    endfunction

    //# +nosemanticerror
     function TypecastMemoryArray takes nothing returns nothing
        local integer Memory // Jasshelper will implicitly rename this to l__Memory
    endfunction

    //# +nosemanticerror
    function GetMemoryArrayAddress takes nothing returns integer
        loop
            return l__Memory
        endloop
            
        return 0
    endfunction

    function UnlockMemEx takes nothing returns nothing
        local integer array i
        local integer a
        local integer b
        local integer offset

        call InitArrayA( 0, 0 )
        call InitArrayA( 0, i[ GetArrayAAddress( ) / 4 ] )
        call InitArrayB( 0, 0 )
        call InitArrayB( 0, i[ GetArrayBAddress( ) / 4 ] )
        call InitArrayC( 0 )
        call InitArrayC( i[ GetArrayCAddress( ) / 4 ] )
        call InitArrayD( 0, 0 )
        call InitArrayD( 0, i[ GetArrayDAddress( ) / 4 ] )
        call InitArrayE( 0 )
        call InitArrayE( i[ GetArrayEAddress( ) / 4 ] )

        set JassVM = i[ i[ i[ i[ pJassEnvAddress / 4 ] / 4 + 5 ] / 4 + 36 ] / 4 + 1 ]

        if JassVM > 0 then
            set JassTable = i[ i[ i[ JassVM / 4 + 0x28A4 / 4 ] / 4 ] / 4 + 0x19C / 4 ]

            if JassTable > 0 then
                set offset = ( i[ GetArrayDAddress( ) / 4 + 3 ] + 4 ) - ( i[ GetArrayBAddress( ) / 4 + 3 ] )
                
                call InitArrayD( 1 + 0x1C / 4, pUnlockCall1 )
                call InitArrayD( 1 + 0xA4 / 4, pUnlockCall2 )
                call InitArrayD( 1 + 0x5C / 4, pUnlockJmp1 )
                call InitArrayD( 1 + 0x04 / 4, GetArrayBAddress( ) - offset + 0x8 )
                call InitArrayD( 1, GetArrayBAddress( ) + 0x8 )
                call InitArrayB( 1, i[ GetArrayDAddress( ) / 4 + 3 ] + 1 * 4 )
                call InitArrayB( 2, pMemory )
                call InitArrayA( 4, i[ GetArrayBAddress( ) / 4 + 3 ] + 4 )

                set b = JassTable - ModuloInteger( i[ GetArrayAAddress( ) / 4 + 3 ] / 4 + 4, 3 )
                set a = ( i[ GetArrayAAddress( ) / 4 + 3 ] / 4 + 4 - b / 4 + 0x2FFFFF ) / 3

                call SetUnitUserData( I2U( a ), 23 )
                call WriteArrayBMemory( 0 + offset / 4, 0xFFFFFFFF )
                call WriteArrayBMemory( 1 + offset / 4, 0 )
                call WriteArrayBMemory( 1 + GetArrayBAddress( ) / 4, 0xFFFFFFFF )
                call WriteArrayBMemory( pMemory / 4 + 1, 0xFFFFFFFF )
                call WriteArrayBMemory( pMemory / 4 + 2, 0xFFFFFFFF )
                call WriteArrayBMemory( pMemory / 4 + 3, 0 )
            endif
        endif
    endfunction

    //# +nosemanticerror
    function UnlockMemory takes nothing returns nothing
        local integer array i
        local boolean IsExtra = false

        call ForForce( bj_FORCE_PLAYER[ 0 ], I2C( C2I( function NewGlobal ) + 0x2 ) )
        call ForForce( bj_FORCE_PLAYER[ 0 ], I2C( C2I( function SetGlobal ) + 0x8 ) )
        // local array "i" can now read memory, but not write.
        call InitArray( 0 )
        set pGameDLL = i[ GetArrayAddress( ) / 4 ]
        call InitArray( pGameDLL )
        call InitMemoryArray( 10, 0 )
        set pMemory = GetMemoryArrayAddress( )
        set iGameVersion = pGameDLL - i[ pGameDLL / 4 ]

        if iGameVersion == 0x5084A8 then
            set PatchVersion    = "1.24e"
            set pGameDLL        = pGameDLL - 0x9631B8
            set pJassEnvAddress = pGameDLL + 0xAF16A8
            set pWriteMemory    = pGameDLL + 0x9B26C0
            set pPointers       = ReadRealMemory( pGameDLL + 0xACE5E0 )
    elseif iGameVersion == 0x4F6E60 then
            set PatchVersion    = "1.26a"
            set pGameDLL        = pGameDLL - 0x951060
            set pJassEnvAddress = pGameDLL + 0xADA848
            set pWriteMemory    = pGameDLL + 0xBE6188
            set pPointers       = ReadRealMemory( pGameDLL + 0xAB7788 )
    elseif iGameVersion == 0x277890 then
            set PatchVersion    = "1.27a"
            set pGameDLL        = pGameDLL - 0xA63B30
            set pJassEnvAddress = pGameDLL + 0xBE3740
            set pWriteMemory    = pGameDLL + 0xAB5948
            set pPointers       = ReadRealMemory( pGameDLL + 0xBE40A8 )
    elseif iGameVersion == 0x2C1554 then
            set PatchVersion    = "1.27b"
            set pGameDLL        = pGameDLL - 0xBD7214
            set pJassEnvAddress = pGameDLL + 0xD46118 // Inside ExecuteFunc | under Concurrency::details::ContextBase dword_... = v3
            set pWriteMemory    = pGameDLL + 0xC2E428 // CBuffDrunkenHaze::`RTTI Base Class Array' -> ??_R2CBuffDrunkenHaze@@8
            set pPointers       = ReadRealMemory( pGameDLL + 0xD68610 ) // (int)"Occlusion", (int)"BuildingsOcclude", 0); -> & 0x7FFFFFFF) < *(_DWORD *)(dword_6F... + 60
            set pUnlockCall1    = pGameDLL + 0x3F4C50 // *(_DWORD *)this + 164))(); main func
            set pUnlockCall2    = pGameDLL + 0x124142 // search v1 = a1 > 0.0; -> go to ida -> 3 functions below to push    esi
            set pUnlockJmp1     = pGameDLL + 0x684BA0 // Under "Async set local leader to %s %x:%x for player %d" | (v10 = 
            set IsExtra         = true
    elseif iGameVersion == 0x2BF828 then
            set PatchVersion    = "1.28f"
            set pGameDLL        = pGameDLL - 0xB8A438
            set pJassEnvAddress = pGameDLL + 0xD0DEF8
            set pWriteMemory    = pGameDLL + 0xBEAF90
            set pPointers       = ReadRealMemory( pGameDLL + 0xD30448 )
            set pUnlockCall1    = pGameDLL + 0x428D30
            set pUnlockCall2    = pGameDLL + 0x152802
            set pUnlockJmp1     = pGameDLL + 0x6B8D30
            set IsExtra         = true
        endif

        // The bytecode unlocks the ability to read and write memory
        // with the "Memory" array

        if IsExtra then // 1.27b and higher required code execution to get access to bytecode.
            call ForForce( bj_FORCE_PLAYER[ 0 ], I2C( C2I( function UnlockMemEx ) + 0x8 ) )
        endif
        
        call InitBytecode( i[ ( C2I( function ReadMemory ) + 0x34 ) / 4 ], i[ ( GetArrayAddress( ) + 0xC ) / 4 ] + 0x4 )
        call ForForce( bj_FORCE_PLAYER[ 0 ], I2C( i[ ( GetBytecodeAddress( ) + 0xC ) / 4 ] ) )
    endfunction

    function Init_APIMemory takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
        elseif PatchVersion == "1.26a" then
        elseif PatchVersion == "1.27a" then
        elseif PatchVersion == "1.27b" then
        elseif PatchVersion == "1.28f" then
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_APIMemory takes nothing returns nothing
    //set gg_trg_APIMemory = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: APIMemoryCalls
//===========================================================================
//TESH.scrollpos=3
//TESH.alwaysfold=0
//! nocjass
native MergeUnits   takes integer qty, integer a, integer b, integer make returns boolean    // reserved native for call 4 integer function and return BOOLEAN value
native ConvertUnits takes integer qty, integer id returns boolean                            // reserved native for call 2 integer function and return BOOLEAN value (can be converted to int!)
native IgnoredUnits takes integer unitid returns integer                                     // reserved native for call 1 integer function and return integer value
native GetUnitCount takes integer addr returns integer                                       // reserved native for FastReadMemory call 1 integer function and return integer value
native AttackMoveXY takes integer addr, integer val returns nothing                          // reserved native for FastWriteMemory call 2 integer function and return integer value

library APIMemoryAllCalls
    globals
        integer AllocatedMemorySize         = 0

        integer pMergeUnits                 = 0
        integer pMergeUnitsOffset           = 0
        integer pIgnoredUnits               = 0
        integer pIgnoredUnitsOffset         = 0
        integer pConvertUnits               = 0
        integer pConvertUnitsOffset         = 0
        integer pGetUnitCount               = 0
        integer pGetUnitCountOffset         = 0
        integer pAttackMoveXY               = 0
        integer pAttackMoveXYOffset         = 0

        integer pMemcpy                     = 0

        integer pGetModuleHandle            = 0
        integer pGetProcAddress             = 0

        integer pVirtualAlloc               = 0
        integer pVirtualProtect             = 0

        //Pointers for calls Start
        integer pFastRead         = 0
        integer pFastWrite        = 0        

        integer pfast_call_1      = 0
        integer pfast_call_2      = 0
        integer pfast_call_3      = 0
        integer pfast_call_4      = 0
        integer pfast_call_5      = 0
        integer pfast_call_6      = 0
        integer pfast_call_7      = 0
        integer pfast_call_8      = 0
        integer pfast_call_9      = 0
        integer pfast_call_10     = 0
        integer pfast_call_11     = 0
        integer pfast_call_12     = 0
        integer pfast_call_13     = 0

        integer pstd_call_1       = 0
        integer pstd_call_2       = 0
        integer pstd_call_3       = 0
        integer pstd_call_4       = 0
        integer pstd_call_5       = 0
        integer pstd_call_6       = 0

        integer pc_call_1         = 0
        integer pc_call_2         = 0
        integer pc_call_3         = 0
        integer pc_call_4         = 0
        integer pc_call_5         = 0
        integer pc_call_6         = 0
        //Pointers for calls End
    endglobals

    // Explanation:
    // We write assembler in a reversed order, since that is how our written memory will translate to machine code
    // Example: 0xB9F68B56 which is B9 F6 8B 56 => but in fact it will be 0x568BF6B9 or 56 8B F6 B9
    // To translate machine code to asm you can use: https://defuse.ca/online-x86-assembler.htm#disassembly2

    function InitFastReadMemory takes nothing returns nothing
		if pGetUnitCount != 0 then
			call WriteRealMemory( pFastRead + 0x0, 0x0424448B )
			call WriteRealMemory( pFastRead + 0x4, 0x90C3008B )
			set pGetUnitCountOffset = CreateJassNativeHook( pGetUnitCount, pFastRead )
		endif
    endfunction

    function InitFastWriteMemory takes nothing returns nothing
		if pAttackMoveXY != 0 then
			call WriteRealMemory( pFastWrite + 0x0, 0x246C8B55 )
			call WriteRealMemory( pFastWrite + 0x4, 0x24448B0C )
			call WriteRealMemory( pFastWrite + 0x8, 0x5D288908 )
			call WriteRealMemory( pFastWrite + 0xC, 0x000090C3 )
			set pAttackMoveXYOffset = CreateJassNativeHook( pAttackMoveXY, pFastWrite )
		endif
    endfunction

    function fast_call_1 takes integer pFuncFastcallAddr, integer arg1 returns integer
        local integer pOffset1

        if ReadRealMemory( pfast_call_1 ) == 0 then
            call WriteRealMemory( pfast_call_1 +  0x0, 0xB9F68B56 ) // push esi | mov esi, esi | mov ecx (arg1)
            call WriteRealMemory( pfast_call_1 +  0x8, 0xBEF68B90 ) // nop | mov esi, esi | mov esi (pFuncFastcallAddr)
            call WriteRealMemory( pfast_call_1 + 0x10, 0xC35ED6FF ) // call esi | pop esi | ret
        endif

        call WriteRealMemory( pfast_call_1 +  0x4, arg1 ) // mov ecx arg1
        call WriteRealMemory( pfast_call_1 +  0xC, pFuncFastcallAddr ) // mov esi, pFuncFastcallAddr

        if pIgnoredUnitsOffset == 0 then
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pfast_call_1 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pfast_call_1 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        return pOffset1
    endfunction

    function fast_call_2 takes integer pFuncFastcallAddr, integer arg1, integer arg2 returns integer
        local integer pOffset1

        if ReadRealMemory( pfast_call_2 ) == 0 then
            call WriteRealMemory( pfast_call_2 + 0x00, 0xBAF68B56 ) // push esi | mov esi, esi | edx (arg2)
            call WriteRealMemory( pfast_call_2 + 0x08, 0xB9F68B90 ) // nop | mov esi, esi | mov ecx (arg1)
            call WriteRealMemory( pfast_call_2 + 0x10, 0xBEF68B90 ) // nop | mov esi, esi | mov esi (pFuncFastcallAddr)
            call WriteRealMemory( pfast_call_2 + 0x18, 0xC35ED6FF ) // call esi | pop esi | ret
        endif

        call WriteRealMemory( pfast_call_2 + 0x04, arg2 ) // mov edx arg2
        call WriteRealMemory( pfast_call_2 + 0x0C, arg1 ) // mov ecx arg1
        call WriteRealMemory( pfast_call_2 + 0x14, pFuncFastcallAddr )  // mov esi, pFuncFastcallAddr

        if pIgnoredUnitsOffset == 0 then
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pfast_call_2 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pfast_call_2 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        return pOffset1
    endfunction

    function fast_call_3 takes integer pFuncFastcallAddr, integer arg1, integer arg2, integer arg3 returns integer
        local integer pOffset1

        if ReadRealMemory( pfast_call_3 ) == 0 then
            call WriteRealMemory( pfast_call_3 + 0x00, 0x68F68B56 ) // push esi | mov esi, esi | push arg3
            call WriteRealMemory( pfast_call_3 + 0x08, 0xBAF68B90 ) // nop | mov esi, esi | mov edx (arg2)
            call WriteRealMemory( pfast_call_3 + 0x10, 0xB9F68B90 ) // nop | mov esi, esi | mov ecx (arg1)
            call WriteRealMemory( pfast_call_3 + 0x18, 0xBEF68B90 ) // nop | mov esi, esi | mov esi (pFuncFastcallAddr)
            call WriteRealMemory( pfast_call_3 + 0x20, 0xC35ED6FF ) // call esi | pop esi | ret
        endif

        call WriteRealMemory( pfast_call_3 + 0x04, arg3 ) // push arg3
        call WriteRealMemory( pfast_call_3 + 0x0C, arg2 ) // mov edx arg2
        call WriteRealMemory( pfast_call_3 + 0x14, arg1 ) // mov ecx arg1
        call WriteRealMemory( pfast_call_3 + 0x1C, pFuncFastcallAddr ) // mov esi, pFuncFastcallAddr

        if pIgnoredUnitsOffset == 0 then
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pfast_call_3 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pfast_call_3 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        return pOffset1
    endfunction

    function fast_call_4 takes integer pFuncFastcallAddr, integer arg1, integer arg2, integer arg3 , integer arg4 returns integer
        local integer pOffset1

        if ReadRealMemory( pfast_call_4 ) == 0 then
            call WriteRealMemory( pfast_call_4 + 0x00, 0x68F68B56 ) // push esi | mov esi, esi | push arg4
            call WriteRealMemory( pfast_call_4 + 0x08, 0x68F68B90 ) // nop | move esi, esi | push arg3
            call WriteRealMemory( pfast_call_4 + 0x10, 0xBAF68B90 ) // nop | mov esi, esi | mov edx (arg2)
            call WriteRealMemory( pfast_call_4 + 0x18, 0xB9F68B90 ) // nop | mov esi, esi | mov ecx (arg1)
            call WriteRealMemory( pfast_call_4 + 0x20, 0xBEF68B90 ) // nop | mov esi, esi | mov esi (pFuncFastcallAddr)
            call WriteRealMemory( pfast_call_4 + 0x28, 0xC35ED6FF ) // call esi | pop esi | ret
        endif
        
        call WriteRealMemory( pfast_call_4 + 0x04, arg4 ) // push arg4
        call WriteRealMemory( pfast_call_4 + 0x0C, arg3 ) // push arg3
        call WriteRealMemory( pfast_call_4 + 0x14, arg2 ) // mov edx arg2
        call WriteRealMemory( pfast_call_4 + 0x1C, arg1 ) // mov ecx arg1
        call WriteRealMemory( pfast_call_4 + 0x24, pFuncFastcallAddr ) // mov esi, pFuncFastcallAddr

        if pIgnoredUnitsOffset == 0 then
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pfast_call_4 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pfast_call_4 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        return pOffset1
    endfunction

    function fast_call_5 takes integer pFuncFastcallAddr, integer arg1, integer arg2, integer arg3 , integer arg4, integer arg5 returns integer
        local integer pOffset1

        if ReadRealMemory( pfast_call_5 ) == 0 then
            call WriteRealMemory( pfast_call_5 + 0x00, 0x68F68B56 ) // push esi | mov esi, esi | push arg5
            call WriteRealMemory( pfast_call_5 + 0x08, 0x68F68B90 ) // nop | move esi, esi | push arg4
            call WriteRealMemory( pfast_call_5 + 0x10, 0x68F68B90 ) // nop | move esi, esi | push arg3
            call WriteRealMemory( pfast_call_5 + 0x18, 0xBAF68B90 ) // nop | mov esi, esi | mov edx (arg2)
            call WriteRealMemory( pfast_call_5 + 0x20, 0xB9F68B90 ) // nop | mov esi, esi | mov ecx (arg1)
            call WriteRealMemory( pfast_call_5 + 0x28, 0xBEF68B90 ) // nop | mov esi, esi | mov esi (pFuncFastcallAddr)
            call WriteRealMemory( pfast_call_5 + 0x30, 0xC35ED6FF ) // call esi | pop esi | ret
        endif
        
        call WriteRealMemory( pfast_call_5 + 0x04, arg5 ) // push arg5
        call WriteRealMemory( pfast_call_5 + 0x0C, arg4 ) // push arg4
        call WriteRealMemory( pfast_call_5 + 0x14, arg3 ) // push arg3
        call WriteRealMemory( pfast_call_5 + 0x1C, arg2 ) // mov edx arg2
        call WriteRealMemory( pfast_call_5 + 0x24, arg1 ) // mov ecx arg1
        call WriteRealMemory( pfast_call_5 + 0x2C, pFuncFastcallAddr ) // mov esi, pFuncFastcallAddr

        if pIgnoredUnitsOffset == 0 then
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pfast_call_5 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pfast_call_5 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        return pOffset1
    endfunction

    function fast_call_6 takes integer pFuncFastcallAddr, integer arg1, integer arg2, integer arg3, integer arg4, integer arg5, integer arg6 returns integer
        local integer pOffset1

        if ReadRealMemory( pfast_call_6 ) == 0 then
            call WriteRealMemory( pfast_call_6 + 0x00, 0x68F68B56 ) // push esi | mov esi, esi | push arg6
            call WriteRealMemory( pfast_call_6 + 0x08, 0x68F68B90 ) // nop | move esi, esi | push arg5
            call WriteRealMemory( pfast_call_6 + 0x10, 0x68F68B90 ) // nop | move esi, esi | push arg4
            call WriteRealMemory( pfast_call_6 + 0x18, 0x68F68B90 ) // nop | move esi, esi | push arg3
            call WriteRealMemory( pfast_call_6 + 0x20, 0xBAF68B90 ) // nop | mov esi, esi | mov edx (arg2)
            call WriteRealMemory( pfast_call_6 + 0x28, 0xB9F68B90 ) // nop | mov esi, esi | mov ecx (arg1)
            call WriteRealMemory( pfast_call_6 + 0x30, 0xBEF68B90 ) // nop | mov esi, esi | mov esi (pFuncFastcallAddr)
            call WriteRealMemory( pfast_call_6 + 0x38, 0xC35ED6FF ) // call esi | pop esi | ret
        endif

        call WriteRealMemory( pfast_call_6 + 0x04, arg6 ) // push arg6
        call WriteRealMemory( pfast_call_6 + 0x0C, arg5 ) // push arg5
        call WriteRealMemory( pfast_call_6 + 0x14, arg4 ) // push arg4
        call WriteRealMemory( pfast_call_6 + 0x1C, arg3 ) // push arg3
        call WriteRealMemory( pfast_call_6 + 0x24, arg2 ) // mov edx arg2
        call WriteRealMemory( pfast_call_6 + 0x2C, arg1 ) // mov ecx arg1
        call WriteRealMemory( pfast_call_6 + 0x34, pFuncFastcallAddr ) // mov esi, pFuncFastcallAddr

        if pIgnoredUnitsOffset == 0 then
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pfast_call_6 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pfast_call_6 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        return pOffset1
    endfunction

    function fast_call_7 takes integer pFuncFastcallAddr, integer arg1, integer arg2, integer arg3, integer arg4, integer arg5, integer arg6, integer arg7 returns integer
        local integer pOffset1

        if ReadRealMemory( pfast_call_7 ) == 0 then
            call WriteRealMemory( pfast_call_7 + 0x00, 0x68F68B56 ) // push esi | mov esi, esi | push arg7
            call WriteRealMemory( pfast_call_7 + 0x08, 0x68F68B90 ) // nop | move esi, esi | push arg6
            call WriteRealMemory( pfast_call_7 + 0x10, 0x68F68B90 ) // nop | move esi, esi | push arg5
            call WriteRealMemory( pfast_call_7 + 0x18, 0x68F68B90 ) // nop | move esi, esi | push arg4
            call WriteRealMemory( pfast_call_7 + 0x20, 0x68F68B90 ) // nop | move esi, esi | push arg3
            call WriteRealMemory( pfast_call_7 + 0x28, 0xBAF68B90 ) // nop | mov esi, esi | mov edx (arg2)
            call WriteRealMemory( pfast_call_7 + 0x30, 0xB9F68B90 ) // nop | mov esi, esi | mov ecx (arg1)
            call WriteRealMemory( pfast_call_7 + 0x38, 0xBEF68B90 ) // nop | mov esi, esi | mov esi (pFuncFastcallAddr)
            call WriteRealMemory( pfast_call_7 + 0x40, 0xC35ED6FF ) // call esi | pop esi | ret
        endif

        call WriteRealMemory( pfast_call_7 + 0x04, arg7 ) // push arg7
        call WriteRealMemory( pfast_call_7 + 0x0C, arg6 ) // push arg6
        call WriteRealMemory( pfast_call_7 + 0x14, arg5 ) // push arg5
        call WriteRealMemory( pfast_call_7 + 0x1C, arg4 ) // push arg4
        call WriteRealMemory( pfast_call_7 + 0x24, arg3 ) // push arg3
        call WriteRealMemory( pfast_call_7 + 0x2C, arg2 ) // mov edx arg2
        call WriteRealMemory( pfast_call_7 + 0x34, arg1 ) // mov ecx arg1
        call WriteRealMemory( pfast_call_7 + 0x3C, pFuncFastcallAddr ) // mov esi, pFuncFastcallAddr

        if pIgnoredUnitsOffset == 0 then
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pfast_call_7 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pfast_call_7 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        return pOffset1
    endfunction

    function fast_call_8 takes integer pFuncFastcallAddr, integer arg1, integer arg2, integer arg3, integer arg4, integer arg5, integer arg6, integer arg7, integer arg8 returns integer
        local integer pOffset1

        if ReadRealMemory( pfast_call_8 ) == 0 then
            call WriteRealMemory( pfast_call_8 + 0x00, 0x68F68B56 ) // push esi | mov esi, esi | push arg8
            call WriteRealMemory( pfast_call_8 + 0x08, 0x68F68B90 ) // nop | move esi, esi | push arg7
            call WriteRealMemory( pfast_call_8 + 0x10, 0x68F68B90 ) // nop | move esi, esi | push arg6
            call WriteRealMemory( pfast_call_8 + 0x18, 0x68F68B90 ) // nop | move esi, esi | push arg5
            call WriteRealMemory( pfast_call_8 + 0x20, 0x68F68B90 ) // nop | move esi, esi | push arg4
            call WriteRealMemory( pfast_call_8 + 0x28, 0x68F68B90 ) // nop | move esi, esi | push arg3
            call WriteRealMemory( pfast_call_8 + 0x30, 0xBAF68B90 ) // nop | mov esi, esi | mov edx (arg2)
            call WriteRealMemory( pfast_call_8 + 0x38, 0xB9F68B90 ) // nop | mov esi, esi | mov ecx (arg1)
            call WriteRealMemory( pfast_call_8 + 0x40, 0xBEF68B90 ) // nop | mov esi, esi | mov esi (pFuncFastcallAddr)
            call WriteRealMemory( pfast_call_8 + 0x48, 0xC35ED6FF ) // call esi | pop esi | ret
        endif
        
        call WriteRealMemory( pfast_call_8 + 0x04, arg8 ) // push arg8
        call WriteRealMemory( pfast_call_8 + 0x0C, arg7 ) // push arg7
        call WriteRealMemory( pfast_call_8 + 0x14, arg6 ) // push arg6
        call WriteRealMemory( pfast_call_8 + 0x1C, arg5 ) // push arg5
        call WriteRealMemory( pfast_call_8 + 0x24, arg4 ) // push arg4
        call WriteRealMemory( pfast_call_8 + 0x2C, arg3 ) // push arg3
        call WriteRealMemory( pfast_call_8 + 0x34, arg2 ) // mov edx arg2
        call WriteRealMemory( pfast_call_8 + 0x3C, arg1 ) // mov ecx arg1
        call WriteRealMemory( pfast_call_8 + 0x44, pFuncFastcallAddr ) // mov esi, pFuncFastcallAddr

        if pIgnoredUnitsOffset == 0 then
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pfast_call_8 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pfast_call_8 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        return pOffset1
    endfunction

    function fast_call_9 takes integer pFuncFastcallAddr, integer arg1, integer arg2, integer arg3, integer arg4, integer arg5, integer arg6, integer arg7, integer arg8, integer arg9 returns integer
        local integer pOffset1

        if ReadRealMemory( pfast_call_9 ) == 0 then
            call WriteRealMemory( pfast_call_9 + 0x00, 0x68F68B56 ) // push esi | mov esi, esi | push arg9
            call WriteRealMemory( pfast_call_9 + 0x08, 0x68F68B90 ) // nop | move esi, esi | push arg8
            call WriteRealMemory( pfast_call_9 + 0x10, 0x68F68B90 ) // nop | move esi, esi | push arg7
            call WriteRealMemory( pfast_call_9 + 0x18, 0x68F68B90 ) // nop | move esi, esi | push arg6
            call WriteRealMemory( pfast_call_9 + 0x20, 0x68F68B90 ) // nop | move esi, esi | push arg5
            call WriteRealMemory( pfast_call_9 + 0x28, 0x68F68B90 ) // nop | move esi, esi | push arg4
            call WriteRealMemory( pfast_call_9 + 0x30, 0x68F68B90 ) // nop | move esi, esi | push arg3
            call WriteRealMemory( pfast_call_9 + 0x38, 0xBAF68B90 ) // nop | mov esi, esi | mov edx (arg2)
            call WriteRealMemory( pfast_call_9 + 0x40, 0xB9F68B90 ) // nop | mov esi, esi | mov ecx (arg1)
            call WriteRealMemory( pfast_call_9 + 0x48, 0xBEF68B90 ) // nop | mov esi, esi | mov esi (pFuncFastcallAddr)
            call WriteRealMemory( pfast_call_9 + 0x50, 0xC35ED6FF ) // call esi | pop esi | ret
        endif

        call WriteRealMemory( pfast_call_9 + 0x04, arg9 ) // push arg9
        call WriteRealMemory( pfast_call_9 + 0x0C, arg8 ) // push arg8
        call WriteRealMemory( pfast_call_9 + 0x14, arg7 ) // push arg7
        call WriteRealMemory( pfast_call_9 + 0x1C, arg6 ) // push arg6
        call WriteRealMemory( pfast_call_9 + 0x24, arg5 ) // push arg5
        call WriteRealMemory( pfast_call_9 + 0x2C, arg4 ) // push arg4
        call WriteRealMemory( pfast_call_9 + 0x34, arg3 ) // push arg3
        call WriteRealMemory( pfast_call_9 + 0x3C, arg2 ) // mov edx arg2
        call WriteRealMemory( pfast_call_9 + 0x44, arg1 ) // mov ecx arg1
        call WriteRealMemory( pfast_call_9 + 0x4C, pFuncFastcallAddr ) // mov esi, pFuncFastcallAddr

        if pIgnoredUnitsOffset == 0 then
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pfast_call_9 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pfast_call_9 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        return pOffset1
    endfunction

    function fast_call_10 takes integer pFuncFastcallAddr, integer arg1, integer arg2, integer arg3, integer arg4, integer arg5, integer arg6, integer arg7, integer arg8, integer arg9, integer arg10 returns integer
        local integer pOffset1

        if ReadRealMemory( pfast_call_10 ) == 0 then
            call WriteRealMemory( pfast_call_10 + 0x00, 0x68F68B56 ) // push esi | mov esi, esi | push arg10
            call WriteRealMemory( pfast_call_10 + 0x08, 0x68F68B90 ) // nop | move esi, esi | push arg9
            call WriteRealMemory( pfast_call_10 + 0x10, 0x68F68B90 ) // nop | move esi, esi | push arg8
            call WriteRealMemory( pfast_call_10 + 0x18, 0x68F68B90 ) // nop | move esi, esi | push arg7
            call WriteRealMemory( pfast_call_10 + 0x20, 0x68F68B90 ) // nop | move esi, esi | push arg6
            call WriteRealMemory( pfast_call_10 + 0x28, 0x68F68B90 ) // nop | move esi, esi | push arg5
            call WriteRealMemory( pfast_call_10 + 0x30, 0x68F68B90 ) // nop | move esi, esi | push arg4
            call WriteRealMemory( pfast_call_10 + 0x38, 0x68F68B90 ) // nop | move esi, esi | push arg3
            call WriteRealMemory( pfast_call_10 + 0x40, 0xBAF68B90 ) // nop | mov esi, esi | mov edx (arg2)
            call WriteRealMemory( pfast_call_10 + 0x48, 0xB9F68B90 ) // nop | mov esi, esi | mov ecx (arg1)
            call WriteRealMemory( pfast_call_10 + 0x50, 0xBEF68B90 ) // nop | mov esi, esi | mov esi (pFuncFastcallAddr)
            call WriteRealMemory( pfast_call_10 + 0x58, 0xC35ED6FF ) // call esi | pop esi | ret
        endif

        call WriteRealMemory( pfast_call_10 + 0x04, arg10 ) // push arg10
        call WriteRealMemory( pfast_call_10 + 0x0C, arg9  ) // push arg9
        call WriteRealMemory( pfast_call_10 + 0x14, arg8  ) // push arg8
        call WriteRealMemory( pfast_call_10 + 0x1C, arg7  ) // push arg7
        call WriteRealMemory( pfast_call_10 + 0x24, arg6  ) // push arg6
        call WriteRealMemory( pfast_call_10 + 0x2C, arg5  ) // push arg5
        call WriteRealMemory( pfast_call_10 + 0x34, arg4  ) // push arg4
        call WriteRealMemory( pfast_call_10 + 0x3C, arg3  ) // push arg3
        call WriteRealMemory( pfast_call_10 + 0x44, arg2  ) // mov edx arg2
        call WriteRealMemory( pfast_call_10 + 0x4C, arg1  ) // mov ecx arg1
        call WriteRealMemory( pfast_call_10 + 0x54, pFuncFastcallAddr ) // mov esi, pFuncFastcallAddr

        if pIgnoredUnitsOffset == 0 then
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pfast_call_10 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pfast_call_10 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        return pOffset1
    endfunction

    function fast_call_11 takes integer pFuncFastcallAddr, integer arg1, integer arg2, integer arg3, integer arg4, integer arg5, integer arg6, integer arg7, integer arg8, integer arg9, integer arg10, integer arg11 returns integer
        local integer pOffset1

        if ReadRealMemory( pfast_call_11 ) == 0 then
            call WriteRealMemory( pfast_call_11 + 0x00, 0x68F68B56 ) // push esi | mov esi, esi | push arg11
            call WriteRealMemory( pfast_call_11 + 0x08, 0x68F68B90 ) // nop | move esi, esi | push arg10
            call WriteRealMemory( pfast_call_11 + 0x10, 0x68F68B90 ) // nop | move esi, esi | push arg9
            call WriteRealMemory( pfast_call_11 + 0x18, 0x68F68B90 ) // nop | move esi, esi | push arg8
            call WriteRealMemory( pfast_call_11 + 0x20, 0x68F68B90 ) // nop | move esi, esi | push arg7
            call WriteRealMemory( pfast_call_11 + 0x28, 0x68F68B90 ) // nop | move esi, esi | push arg6
            call WriteRealMemory( pfast_call_11 + 0x30, 0x68F68B90 ) // nop | move esi, esi | push arg5
            call WriteRealMemory( pfast_call_11 + 0x38, 0x68F68B90 ) // nop | move esi, esi | push arg4
            call WriteRealMemory( pfast_call_11 + 0x40, 0x68F68B90 ) // nop | move esi, esi | push arg3
            call WriteRealMemory( pfast_call_11 + 0x48, 0xBAF68B90 ) // nop | mov esi, esi | mov edx (arg2)
            call WriteRealMemory( pfast_call_11 + 0x50, 0xB9F68B90 ) // nop | mov esi, esi | mov ecx (arg1)
            call WriteRealMemory( pfast_call_11 + 0x58, 0xBEF68B90 ) // nop | mov esi, esi | mov esi (pFuncFastcallAddr)
            call WriteRealMemory( pfast_call_11 + 0x60, 0xC35ED6FF ) // call esi | pop esi | ret
        endif

        call WriteRealMemory( pfast_call_11 + 0x04, arg11 ) // push arg11
        call WriteRealMemory( pfast_call_11 + 0x0C, arg10 ) // push arg10
        call WriteRealMemory( pfast_call_11 + 0x14, arg9  ) // push arg9
        call WriteRealMemory( pfast_call_11 + 0x1C, arg8  ) // push arg8
        call WriteRealMemory( pfast_call_11 + 0x24, arg7  ) // push arg7
        call WriteRealMemory( pfast_call_11 + 0x2C, arg6  ) // push arg6
        call WriteRealMemory( pfast_call_11 + 0x34, arg5  ) // push arg5
        call WriteRealMemory( pfast_call_11 + 0x3C, arg4  ) // push arg4
        call WriteRealMemory( pfast_call_11 + 0x44, arg3  ) // push arg3
        call WriteRealMemory( pfast_call_11 + 0x4C, arg2  ) // mov edx arg2
        call WriteRealMemory( pfast_call_11 + 0x54, arg1  ) // mov ecx arg1
        call WriteRealMemory( pfast_call_11 + 0x5C, pFuncFastcallAddr ) // mov esi, pFuncFastcallAddr

        if pIgnoredUnitsOffset == 0 then
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pfast_call_11 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pfast_call_11 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        return pOffset1
    endfunction

    function fast_call_12 takes integer pFuncFastcallAddr, integer arg1, integer arg2, integer arg3, integer arg4, integer arg5, integer arg6, integer arg7, integer arg8, integer arg9, integer arg10, integer arg11, integer arg12 returns integer
        local integer pOffset1

        if ReadRealMemory( pfast_call_12 ) == 0 then
            call WriteRealMemory( pfast_call_12 + 0x00, 0x68F68B56 ) // push esi | mov esi, esi | push arg12
            call WriteRealMemory( pfast_call_12 + 0x08, 0x68F68B90 ) // nop | move esi, esi | push arg11
            call WriteRealMemory( pfast_call_12 + 0x10, 0x68F68B90 ) // nop | move esi, esi | push arg10
            call WriteRealMemory( pfast_call_12 + 0x18, 0x68F68B90 ) // nop | move esi, esi | push arg9
            call WriteRealMemory( pfast_call_12 + 0x20, 0x68F68B90 ) // nop | move esi, esi | push arg8
            call WriteRealMemory( pfast_call_12 + 0x28, 0x68F68B90 ) // nop | move esi, esi | push arg7
            call WriteRealMemory( pfast_call_12 + 0x30, 0x68F68B90 ) // nop | move esi, esi | push arg6
            call WriteRealMemory( pfast_call_12 + 0x38, 0x68F68B90 ) // nop | move esi, esi | push arg5
            call WriteRealMemory( pfast_call_12 + 0x40, 0x68F68B90 ) // nop | move esi, esi | push arg4
            call WriteRealMemory( pfast_call_12 + 0x48, 0x68F68B90 ) // nop | move esi, esi | push arg3
            call WriteRealMemory( pfast_call_12 + 0x50, 0xBAF68B90 ) // nop | mov esi, esi | mov edx (arg2)
            call WriteRealMemory( pfast_call_12 + 0x58, 0xB9F68B90 ) // nop | mov esi, esi | mov ecx (arg1)
            call WriteRealMemory( pfast_call_12 + 0x60, 0xBEF68B90 ) // nop | mov esi, esi | mov esi (pFuncFastcallAddr)
            call WriteRealMemory( pfast_call_12 + 0x68, 0xC35ED6FF ) // call esi | pop esi | ret
        endif

        call WriteRealMemory( pfast_call_12 + 0x04, arg12 ) // push arg12
        call WriteRealMemory( pfast_call_12 + 0x0C, arg11 ) // push arg11
        call WriteRealMemory( pfast_call_12 + 0x14, arg10 ) // push arg10
        call WriteRealMemory( pfast_call_12 + 0x1C, arg9  ) // push arg9
        call WriteRealMemory( pfast_call_12 + 0x24, arg8  ) // push arg8
        call WriteRealMemory( pfast_call_12 + 0x2C, arg7  ) // push arg7
        call WriteRealMemory( pfast_call_12 + 0x34, arg6  ) // push arg6
        call WriteRealMemory( pfast_call_12 + 0x3C, arg5  ) // push arg5
        call WriteRealMemory( pfast_call_12 + 0x44, arg4  ) // push arg4
        call WriteRealMemory( pfast_call_12 + 0x4C, arg3  ) // push arg3
        call WriteRealMemory( pfast_call_12 + 0x54, arg2  ) // mov edx arg2
        call WriteRealMemory( pfast_call_12 + 0x5C, arg1  ) // mov ecx arg1
        call WriteRealMemory( pfast_call_12 + 0x64, pFuncFastcallAddr ) // mov esi, pFuncFastcallAddr

        if pIgnoredUnitsOffset == 0 then
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pfast_call_12 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pfast_call_12 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        return pOffset1
    endfunction

    function fast_call_13 takes integer pFuncFastcallAddr, integer arg1, integer arg2, integer arg3, integer arg4, integer arg5, integer arg6, integer arg7, integer arg8, integer arg9, integer arg10, integer arg11, integer arg12, integer arg13 returns integer
        local integer pOffset1

        if ReadRealMemory( pfast_call_13 ) == 0 then
            call WriteRealMemory( pfast_call_13 + 0x00, 0x68F68B56 ) // push esi | mov esi, esi | push arg13
            call WriteRealMemory( pfast_call_13 + 0x08, 0x68F68B90 ) // nop | move esi, esi | push arg12
            call WriteRealMemory( pfast_call_13 + 0x10, 0x68F68B90 ) // nop | move esi, esi | push arg11
            call WriteRealMemory( pfast_call_13 + 0x18, 0x68F68B90 ) // nop | move esi, esi | push arg10
            call WriteRealMemory( pfast_call_13 + 0x20, 0x68F68B90 ) // nop | move esi, esi | push arg9
            call WriteRealMemory( pfast_call_13 + 0x28, 0x68F68B90 ) // nop | move esi, esi | push arg8
            call WriteRealMemory( pfast_call_13 + 0x30, 0x68F68B90 ) // nop | move esi, esi | push arg7
            call WriteRealMemory( pfast_call_13 + 0x38, 0x68F68B90 ) // nop | move esi, esi | push arg6
            call WriteRealMemory( pfast_call_13 + 0x40, 0x68F68B90 ) // nop | move esi, esi | push arg5
            call WriteRealMemory( pfast_call_13 + 0x48, 0x68F68B90 ) // nop | move esi, esi | push arg4
            call WriteRealMemory( pfast_call_13 + 0x50, 0x68F68B90 ) // nop | move esi, esi | push arg3
            call WriteRealMemory( pfast_call_13 + 0x58, 0xBAF68B90 ) // nop | mov esi, esi | mov edx (arg2)
            call WriteRealMemory( pfast_call_13 + 0x60, 0xB9F68B90 ) // nop | mov esi, esi | mov ecx (arg1)
            call WriteRealMemory( pfast_call_13 + 0x68, 0xBEF68B90 ) // nop | mov esi, esi | mov esi (pFuncFastcallAddr)
            call WriteRealMemory( pfast_call_13 + 0x70, 0xC35ED6FF ) // call esi | pop esi | ret
        endif

        call WriteRealMemory( pfast_call_13 + 0x04, arg13 ) // push arg13
        call WriteRealMemory( pfast_call_13 + 0x0C, arg12 ) // push arg12
        call WriteRealMemory( pfast_call_13 + 0x14, arg11 ) // push arg11
        call WriteRealMemory( pfast_call_13 + 0x1C, arg10 ) // push arg10
        call WriteRealMemory( pfast_call_13 + 0x24, arg9  ) // push arg9
        call WriteRealMemory( pfast_call_13 + 0x2C, arg8  ) // push arg8
        call WriteRealMemory( pfast_call_13 + 0x34, arg7  ) // push arg7
        call WriteRealMemory( pfast_call_13 + 0x3C, arg6  ) // push arg6
        call WriteRealMemory( pfast_call_13 + 0x44, arg5  ) // push arg5
        call WriteRealMemory( pfast_call_13 + 0x4C, arg4  ) // push arg4
        call WriteRealMemory( pfast_call_13 + 0x54, arg3  ) // push arg3
        call WriteRealMemory( pfast_call_13 + 0x5C, arg2  ) // mov edx arg2
        call WriteRealMemory( pfast_call_13 + 0x64, arg1  ) // mov ecx arg1
        call WriteRealMemory( pfast_call_13 + 0x6C, pFuncFastcallAddr ) // mov esi, pFuncFastcallAddr

        if pIgnoredUnitsOffset == 0 then
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pfast_call_13 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pfast_call_13 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        return pOffset1
    endfunction

    function this_call_1 takes integer pfuncaddr, integer arg1 returns integer
        return fast_call_2( pfuncaddr, arg1, 0 )
    endfunction

    function this_call_2 takes integer pfuncaddr, integer arg1, integer arg2 returns integer
        return fast_call_3( pfuncaddr, arg1, 0, arg2 )
    endfunction

    function this_call_3 takes integer pfuncaddr, integer arg1, integer arg2, integer arg3 returns integer
        return fast_call_4( pfuncaddr, arg1, 0, arg2, arg3 )
    endfunction

    function this_call_4 takes integer pfuncaddr, integer arg1, integer arg2, integer arg3, integer arg4 returns integer
        return fast_call_5( pfuncaddr, arg1, 0, arg2, arg3, arg4 )
    endfunction

    function this_call_5 takes integer pfuncaddr, integer arg1, integer arg2, integer arg3, integer arg4, integer arg5 returns integer
        return fast_call_6( pfuncaddr, arg1, 0, arg2, arg3, arg4, arg5 )
    endfunction

    function this_call_6 takes integer pfuncaddr, integer arg1, integer arg2, integer arg3, integer arg4, integer arg5, integer arg6 returns integer
        return fast_call_7( pfuncaddr, arg1, 0, arg2, arg3, arg4, arg5, arg6 )
    endfunction

    function this_call_7 takes integer pfuncaddr, integer arg1, integer arg2, integer arg3, integer arg4, integer arg5, integer arg6, integer arg7 returns integer
        return fast_call_8( pfuncaddr, arg1, 0, arg2, arg3, arg4, arg5, arg6, arg7 )
    endfunction

    function this_call_8 takes integer pfuncaddr, integer arg1, integer arg2, integer arg3, integer arg4, integer arg5, integer arg6, integer arg7, integer arg8 returns integer
        return fast_call_9( pfuncaddr, arg1, 0, arg2, arg3, arg4, arg5, arg6, arg7, arg8 )
    endfunction

    function this_call_9 takes integer pfuncaddr, integer arg1, integer arg2, integer arg3, integer arg4, integer arg5, integer arg6, integer arg7, integer arg8, integer arg9 returns integer
        return fast_call_10( pfuncaddr, arg1, 0, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 )
    endfunction

    function this_call_10 takes integer pfuncaddr, integer arg1, integer arg2, integer arg3, integer arg4, integer arg5, integer arg6, integer arg7, integer arg8, integer arg9, integer arg10 returns integer
        return fast_call_11( pfuncaddr, arg1, 0, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10 )
    endfunction

    function this_call_11 takes integer pfuncaddr, integer arg1, integer arg2, integer arg3, integer arg4, integer arg5, integer arg6, integer arg7, integer arg8, integer arg9, integer arg10, integer arg11 returns integer
        return fast_call_12( pfuncaddr, arg1, 0, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11 )
    endfunction

    function this_call_12 takes integer pfuncaddr, integer arg1, integer arg2, integer arg3, integer arg4, integer arg5, integer arg6, integer arg7, integer arg8, integer arg9, integer arg10, integer arg11, integer arg12 returns integer
        return fast_call_13( pfuncaddr, arg1, 0, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12 )
    endfunction

    function std_call_1 takes integer pFuncStdcallAddr, integer arg1 returns integer
        local integer pOffset1

        if ReadRealMemory( pstd_call_1 ) == 0 then
            call WriteRealMemory( pstd_call_1 + 0x00, 0x68C98B51 )    // push ecx | mov ecx, ecx | push (arg1)
            call WriteRealMemory( pstd_call_1 + 0x08, 0xB990C98B )    // mov ecx, ecx | nop | mov ecx (pFuncStdcallAddr)
            call WriteRealMemory( pstd_call_1 + 0x10, 0xC359D1FF )    // call ecx, pop ecx, ret
        endif
        
        call WriteRealMemory( pstd_call_1 + 0x04, arg1 )                // push arg1
        call WriteRealMemory( pstd_call_1 + 0x0C, pFuncStdcallAddr )    // mov ecx, pFuncStdcallAddr

        if pIgnoredUnitsOffset == 0 then
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pstd_call_1 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pstd_call_1 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        
        return pOffset1
    endfunction

    function std_call_2 takes integer pFuncStdcallAddr, integer arg1, integer arg2 returns integer
        local integer pOffset1

        if ReadRealMemory( pstd_call_2 ) == 0 then
            call WriteRealMemory( pstd_call_2 + 0x00, 0x68C98B51 )    // push ecx, mov ecx, ecx
            call WriteRealMemory( pstd_call_2 + 0x08, 0x6890C98B )    // mov ecx, ecx
            call WriteRealMemory( pstd_call_2 + 0x10, 0xB990C98B )    // mov ecx, ecx, nop
            call WriteRealMemory( pstd_call_2 + 0x18, 0xC359D1FF )    // call ecx, pop ecx, ret
        endif

        call WriteRealMemory( pstd_call_2 + 0x04, arg2 )                // push arg1
        call WriteRealMemory( pstd_call_2 + 0x0C, arg1 )                // push arg2
        call WriteRealMemory( pstd_call_2 + 0x14, pFuncStdcallAddr )     // mov ecx, pFuncStdcallAddr

        if pIgnoredUnitsOffset == 0 then
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pstd_call_2 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pstd_call_2 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        
        return pOffset1
    endfunction

    function std_call_3 takes integer pFuncStdcallAddr, integer arg1, integer arg2, integer arg3 returns integer
        local integer pOffset1

        if ReadRealMemory( pstd_call_3 ) == 0 then
            call WriteRealMemory( pstd_call_3 + 0x00, 0x68C98B51 )   // push ecx, mov ecx, ecx
            call WriteRealMemory( pstd_call_3 + 0x08, 0x6890C98B )   // mov ecx, ecx
            call WriteRealMemory( pstd_call_3 + 0x10, 0x6890C98B )   // mov ecx, ecx
            call WriteRealMemory( pstd_call_3 + 0x18, 0xB990C98B )   // mov ecx, ecx, nop
            call WriteRealMemory( pstd_call_3 + 0x20, 0xC359D1FF )   // call ecx, pop ecx, ret
        endif

        call WriteRealMemory( pstd_call_3 + 0x04, arg3 )                // push arg3
        call WriteRealMemory( pstd_call_3 + 0x0C, arg2 )                // push arg2
        call WriteRealMemory( pstd_call_3 + 0x14, arg1 )                // push arg1
        call WriteRealMemory( pstd_call_3 + 0x1C, pFuncStdcallAddr )    // mov ecx, pFuncStdcallAddr
        

        if pIgnoredUnitsOffset == 0 then
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pstd_call_3 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pstd_call_3 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        return pOffset1
    endfunction

    function std_call_4 takes integer pFuncStdcallAddr, integer arg1, integer arg2, integer arg3, integer arg4 returns integer
        local integer pOffset1

        if ReadRealMemory( pstd_call_4 ) == 0 then
            call WriteRealMemory( pstd_call_4 + 0x00, 0x68C98B51 )    // push ecx, mov ecx, ecx
            call WriteRealMemory( pstd_call_4 + 0x08, 0x6890C98B )    // mov ecx, ecx
            call WriteRealMemory( pstd_call_4 + 0x10, 0x6890C98B )    // mov ecx, ecx
            call WriteRealMemory( pstd_call_4 + 0x18, 0x6890C98B )    // mov ecx, ecx
            call WriteRealMemory( pstd_call_4 + 0x20, 0xB990C98B )    // mov ecx, ecx, nop
            call WriteRealMemory( pstd_call_4 + 0x28, 0xC359D1FF )    // call ecx, pop ecx, ret
        endif

        call WriteRealMemory( pstd_call_4 + 0x04, arg4 )                // push arg4
        call WriteRealMemory( pstd_call_4 + 0x0C, arg3 )                // push arg3
        call WriteRealMemory( pstd_call_4 + 0x14, arg2 )                // push arg2
        call WriteRealMemory( pstd_call_4 + 0x1C, arg1 )                // push arg1
        call WriteRealMemory( pstd_call_4 + 0x24, pFuncStdcallAddr )    // mov ecx, pFuncStdcallAddr

        if pIgnoredUnitsOffset == 0 then
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pstd_call_4 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pstd_call_4 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        
        return pOffset1
    endfunction

    function std_call_5 takes integer pFuncStdcallAddr, integer arg1, integer arg2, integer arg3, integer arg4, integer arg5 returns integer
        local integer pOffset1

        if ReadRealMemory( pstd_call_5 ) == 0 then
            call WriteRealMemory( pstd_call_5 + 0x00, 0x68C98B51 )    // push ecx, mov ecx, ecx
            call WriteRealMemory( pstd_call_5 + 0x08, 0x6890C98B )    // mov ecx, ecx
            call WriteRealMemory( pstd_call_5 + 0x10, 0x6890C98B )    // mov ecx, ecx
            call WriteRealMemory( pstd_call_5 + 0x18, 0x6890C98B )    // mov ecx, ecx
            call WriteRealMemory( pstd_call_5 + 0x20, 0x6890C98B )    // mov ecx, ecx
            call WriteRealMemory( pstd_call_5 + 0x28, 0xB990C98B )    // mov ecx, ecx, nop
            call WriteRealMemory( pstd_call_5 + 0x30, 0xC359D1FF )    // call ecx, pop ecx, ret
        endif

        call WriteRealMemory( pstd_call_5 + 0x04, arg5 )                // push arg5
        call WriteRealMemory( pstd_call_5 + 0x0C, arg4 )                // push arg4
        call WriteRealMemory( pstd_call_5 + 0x14, arg3 )                // push arg3
        call WriteRealMemory( pstd_call_5 + 0x1C, arg2 )                // push arg2
        call WriteRealMemory( pstd_call_5 + 0x24, arg1 )                // push arg1
        call WriteRealMemory( pstd_call_5 + 0x2C, pFuncStdcallAddr )    // mov ecx, pFuncStdcallAddr

        if pIgnoredUnitsOffset == 0 then
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pstd_call_5 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pstd_call_5 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        return pOffset1
    endfunction

    function std_call_6 takes integer pFuncStdcallAddr, integer arg1, integer arg2, integer arg3, integer arg4, integer arg5, integer arg6 returns integer
        local integer pOffset1

        if ReadRealMemory( pstd_call_6 ) == 0 then
            call WriteRealMemory( pstd_call_6 + 0x00, 0x68C98B51 )    // push ecx, mov ecx, ecx
            call WriteRealMemory( pstd_call_6 + 0x08, 0x6890C98B )    // mov ecx, ecx
            call WriteRealMemory( pstd_call_6 + 0x10, 0x6890C98B )    // mov ecx, ecx
            call WriteRealMemory( pstd_call_6 + 0x18, 0x6890C98B )    // mov ecx, ecx
            call WriteRealMemory( pstd_call_6 + 0x20, 0x6890C98B )    // mov ecx, ecx
            call WriteRealMemory( pstd_call_6 + 0x28, 0x6890C98B )    // mov ecx, ecx, nop
            call WriteRealMemory( pstd_call_6 + 0x30, 0xB990C98B )    // mov ecx, ecx, nop
            call WriteRealMemory( pstd_call_6 + 0x38, 0xC359D1FF )    // call ecx, pop ecx, ret
        endif

        call WriteRealMemory( pstd_call_6 + 0x04, arg6 )                  // push arg5
        call WriteRealMemory( pstd_call_6 + 0x0C, arg5 )                  // push arg4
        call WriteRealMemory( pstd_call_6 + 0x14, arg4 )                  // push arg3
        call WriteRealMemory( pstd_call_6 + 0x1C, arg3 )                  // push arg2
        call WriteRealMemory( pstd_call_6 + 0x24, arg2 )                  // push arg1
        call WriteRealMemory( pstd_call_6 + 0x2C, arg1 )                  // push arg1
        call WriteRealMemory( pstd_call_6 + 0x34, pFuncStdcallAddr )     // mov ecx, pFuncStdcallAddr

        if pIgnoredUnitsOffset == 0 then
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pstd_call_6 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pstd_call_6 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        return pOffset1
    endfunction

    function c_call_1 takes integer pFuncCdeclAddr, integer arg1 returns integer 
        local integer pOffset1

        if ReadRealMemory( pc_call_1 ) == 0 then 
            call WriteRealMemory( pc_call_1 + 0x00, 0x68C98B51 ) // push ecx, mov ecx, ecx
            call WriteRealMemory( pc_call_1 + 0x08, 0xB990C98B ) // mov ecx, ecx, nop
            call WriteRealMemory( pc_call_1 + 0x10, 0xC483D1FF ) // call ecx, add esp
            call WriteRealMemory( pc_call_1 + 0x14, 0xCCC35904 ) // 4, pop ecx, ret
        endif

        call WriteRealMemory( pc_call_1 + 0x04, arg1 )           // push arg1
        call WriteRealMemory( pc_call_1 + 0x0C, pFuncCdeclAddr ) // mov ecx, pFuncCdeclAddr

        if pIgnoredUnitsOffset == 0 then 
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pc_call_1 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pc_call_1 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        return pOffset1
    endfunction

    function c_call_2 takes integer pFuncCdeclAddr, integer arg1, integer arg2 returns integer 
        local integer pOffset1

        if ReadRealMemory( pc_call_2 ) == 0 then 
            call WriteRealMemory( pc_call_2 + 0x00, 0x68C98B51 ) // push ecx, mov ecx, ecx
            call WriteRealMemory( pc_call_2 + 0x08, 0x6890C98B ) // mov ecx, ecx
            call WriteRealMemory( pc_call_2 + 0x10, 0xB990C98B ) // mov ecx,ecx , nop
            call WriteRealMemory( pc_call_2 + 0x18, 0xC483D1FF ) // call ecx, add esp, 
            call WriteRealMemory( pc_call_2 + 0x1C, 0xCCC35908 ) // 4, pop ecx, ret
        endif

        call WriteRealMemory( pc_call_2 + 0x04, arg2 )           // push arg2
        call WriteRealMemory( pc_call_2 + 0x0C, arg1 )           // push arg1
        call WriteRealMemory( pc_call_2 + 0x14, pFuncCdeclAddr ) // mov ecx, pFuncCdeclAddr

        if pIgnoredUnitsOffset == 0 then 
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pc_call_2 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pc_call_2 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        return pOffset1
    endfunction

    function c_call_3 takes integer pFuncCdeclAddr, integer arg1, integer arg2, integer arg3 returns integer 
        local integer pOffset1

        if ReadRealMemory( pc_call_3 ) == 0 then 
            call WriteRealMemory( pc_call_3 + 0x00, 0x68C98B51 ) // push ecx, mov ecx, ecx
            call WriteRealMemory( pc_call_3 + 0x08, 0x6890C98B ) // mov ecx, ecx
            call WriteRealMemory( pc_call_3 + 0x10, 0x6890C98B ) // mov ecx, ecx
            call WriteRealMemory( pc_call_3 + 0x18, 0xB990C98B ) // mov ecx,ecx, nop
            call WriteRealMemory( pc_call_3 + 0x20, 0xC483D1FF ) // call ecx, add esp
            call WriteRealMemory( pc_call_3 + 0x24, 0xCCC3590C ) // 4, pop ecx, ret
        endif

        call WriteRealMemory( pc_call_3 + 0x04, arg3 )           // push arg3
        call WriteRealMemory( pc_call_3 + 0x0C, arg2 )           // push arg2
        call WriteRealMemory( pc_call_3 + 0x14, arg1 )           // push arg1
        call WriteRealMemory( pc_call_3 + 0x1C, pFuncCdeclAddr ) // mov ecx, pFuncCdeclAddr

        if pIgnoredUnitsOffset == 0 then 
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pc_call_3 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pc_call_3 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        return pOffset1
    endfunction

    function c_call_4 takes integer pFuncCdeclAddr, integer arg1, integer arg2, integer arg3 , integer arg4 returns integer 
        local integer pOffset1

        if ReadRealMemory( pc_call_4 ) == 0 then 
            call WriteRealMemory( pc_call_4 + 0x00, 0x68C98B51 ) // push ecx, mov ecx, ecx
            call WriteRealMemory( pc_call_4 + 0x08, 0x6890C98B ) // mov ecx, ecx
            call WriteRealMemory( pc_call_4 + 0x10, 0x6890C98B ) // mov ecx, ecx
            call WriteRealMemory( pc_call_4 + 0x18, 0x6890C98B ) // mov ecx, ecx
            call WriteRealMemory( pc_call_4 + 0x20, 0xB990C98B ) // mov ecx, ecx, nop
            call WriteRealMemory( pc_call_4 + 0x28, 0xC483D1FF ) // call ecx, add esp
            call WriteRealMemory( pc_call_4 + 0x2C, 0xCCC35910 ) // 4, pop ecx, ret
        endif

        call WriteRealMemory( pc_call_4 + 0x04, arg4 )           // push arg4
        call WriteRealMemory( pc_call_4 + 0x0C, arg3 )           // push arg3
        call WriteRealMemory( pc_call_4 + 0x14, arg2 )           // push arg2
        call WriteRealMemory( pc_call_4 + 0x1C, arg1 )           // push arg1
        call WriteRealMemory( pc_call_4 + 0x24, pFuncCdeclAddr ) // mov ecx, pFuncCdeclAddr

        if pIgnoredUnitsOffset == 0 then 
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pc_call_4 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pc_call_4 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        return pOffset1
    endfunction

    function c_call_5 takes integer pFuncCdeclAddr, integer arg1, integer arg2, integer arg3 , integer arg4, integer arg5 returns integer 
        local integer pOffset1

        if ReadRealMemory( pc_call_5 ) == 0 then 
            call WriteRealMemory( pc_call_5 + 0x00, 0x68C98B51 ) // push ecx, mov ecx, ecx
            call WriteRealMemory( pc_call_5 + 0x08, 0x6890C98B ) // mov ecx, ecx
            call WriteRealMemory( pc_call_5 + 0x10, 0x6890C98B ) // mov ecx, ecx
            call WriteRealMemory( pc_call_5 + 0x18, 0x6890C98B ) // mov ecx, ecx
            call WriteRealMemory( pc_call_5 + 0x20, 0x6890C98B ) // mov ecx, ecx
            call WriteRealMemory( pc_call_5 + 0x28, 0xB990C98B ) // mov ecx, ecx, nop
            call WriteRealMemory( pc_call_5 + 0x30, 0xC483D1FF ) // call ecx, add esp, 
            call WriteRealMemory( pc_call_5 + 0x34, 0xCCC35914 ) // 4, pop ecx, ret
        endif

        call WriteRealMemory( pc_call_5 + 0x04, arg5 )           // push arg5
        call WriteRealMemory( pc_call_5 + 0x0C, arg4 )           // push arg4
        call WriteRealMemory( pc_call_5 + 0x14, arg3 )           // push arg3
        call WriteRealMemory( pc_call_5 + 0x1C, arg2 )           // push arg2
        call WriteRealMemory( pc_call_5 + 0x24, arg1 )           // push arg1
        call WriteRealMemory( pc_call_5 + 0x2C, pFuncCdeclAddr ) // mov ecx, pFuncCdeclAddr
        
        if pIgnoredUnitsOffset == 0 then 
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pc_call_5 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pc_call_5 )
        endif
        
        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        return pOffset1
    endfunction

    function c_call_6 takes integer pFuncCdeclAddr, integer arg1, integer arg2, integer arg3 , integer arg4, integer arg5 , integer arg6 returns integer 
        local integer pOffset1

        if ReadRealMemory( pc_call_6 ) == 0 then 
            call WriteRealMemory( pc_call_6 + 0x00, 0x68C98B51 ) // push ecx, mov ecx, ecx
            call WriteRealMemory( pc_call_6 + 0x08, 0x6890C98B ) // mov ecx, ecx
            call WriteRealMemory( pc_call_6 + 0x10, 0x6890C98B ) // mov ecx, ecx
            call WriteRealMemory( pc_call_6 + 0x18, 0x6890C98B ) // mov ecx, ecx
            call WriteRealMemory( pc_call_6 + 0x20, 0x6890C98B ) // mov ecx, ecx
            call WriteRealMemory( pc_call_6 + 0x28, 0x6890C98B ) // mov ecx, ecx
            call WriteRealMemory( pc_call_6 + 0x30, 0xB990C98B ) // mov ecx, ecx, nop
            call WriteRealMemory( pc_call_6 + 0x38, 0xC483D1FF ) // call ecx, add esp, 
            call WriteRealMemory( pc_call_6 + 0x3C, 0xCCC35918 ) // 4, pop ecx, ret
        endif

        call WriteRealMemory( pc_call_6 + 0x04, arg6 )           // push arg6
        call WriteRealMemory( pc_call_6 + 0x0C, arg5 )           // push arg5
        call WriteRealMemory( pc_call_6 + 0x14, arg4 )           // push arg4
        call WriteRealMemory( pc_call_6 + 0x1C, arg3 )           // push arg3
        call WriteRealMemory( pc_call_6 + 0x24, arg2 )           // push arg2
        call WriteRealMemory( pc_call_6 + 0x2C, arg1 )           // push arg1
        call WriteRealMemory( pc_call_6 + 0x34, pFuncCdeclAddr ) // mov ecx, pFuncCdeclAddr

        if pIgnoredUnitsOffset == 0 then 
            set pIgnoredUnitsOffset = CreateJassNativeHook( pIgnoredUnits, pc_call_6 )
        else
            call WriteRealMemory( pIgnoredUnitsOffset, pc_call_6 )
        endif

        set pOffset1 = IgnoredUnits( 0 )
        call WriteRealMemory( pIgnoredUnitsOffset, pIgnoredUnits )
        return pOffset1
    endfunction

    function AllocateExecutableMemory takes integer size returns integer
        local integer retval = 0

        if pVirtualAlloc != 0 then
            if pMergeUnitsOffset == 0 then
                set pMergeUnitsOffset = CreateJassNativeHook( pMergeUnits, ReadRealMemory( pVirtualAlloc ) )
            else
                call WriteRealMemory( pMergeUnitsOffset, ReadRealMemory( pVirtualAlloc ) )
            endif

            set retval = B2I( MergeUnits( 0, size + 4, 0x3000, 0x40 ) )
            call WriteRealMemory( pMergeUnitsOffset, pMergeUnits )
        endif

        if retval == 0 then
            return 0
        endif

        return ( retval + 0x4 ) / 4 * 4
    endfunction

    function AllocateExecutableMemoryCounted takes integer size returns integer
        local integer retval = AllocateExecutableMemory( size )

        if retval != 0 then
            set AllocatedMemorySize = AllocatedMemorySize + size
        endif
        
        return retval
    endfunction
    
    function CopyMemory takes integer dest, integer src, integer size returns integer 
        return c_call_3( ReadRealMemory( pMemcpy ), dest, src, size )
    endfunction
    
    function GetModuleHandleByAddr takes integer pDll returns integer
        if pGetModuleHandle > 0 then
            return std_call_1( ReadRealMemory( pGetModuleHandle ), pDll )
        endif

        return 0
    endfunction
    
    function GetModuleHandle takes string nDllName returns integer
        return GetModuleHandleByAddr( GetStringAddress( nDllName ) )
    endfunction

    function GetModuleProcAddressByAddr takes integer pDll, integer pFunc returns integer
        if pGetProcAddress > 0 then
            return std_call_2( ReadRealMemory( pGetProcAddress ), GetModuleHandleByAddr( pDll ), pFunc )
        endif
        
        return 0
    endfunction
    
    function GetModuleProcAddress takes string nDllName, string nProcName returns integer
        return GetModuleProcAddressByAddr( GetStringAddress( nDllName ), GetStringAddress( nProcName ) )
    endfunction
    
    function ReallocateCallMemory takes nothing returns nothing
        local integer i   = 0

        set pFastRead     = AllocateExecutableMemoryCounted( 0x8 )
        set pFastWrite    = AllocateExecutableMemoryCounted( 0x10 )

        set pfast_call_1  = AllocateExecutableMemoryCounted( 0x14 )
        set pfast_call_2  = AllocateExecutableMemoryCounted( 0x1C )
        set pfast_call_3  = AllocateExecutableMemoryCounted( 0x24 )
        set pfast_call_4  = AllocateExecutableMemoryCounted( 0x2C )
        set pfast_call_5  = AllocateExecutableMemoryCounted( 0x34 )
        set pfast_call_6  = AllocateExecutableMemoryCounted( 0x3C )
        set pfast_call_7  = AllocateExecutableMemoryCounted( 0x44 )
        set pfast_call_8  = AllocateExecutableMemoryCounted( 0x4C )
        set pfast_call_9  = AllocateExecutableMemoryCounted( 0x5C )
        set pfast_call_10 = AllocateExecutableMemoryCounted( 0x64 )
        set pfast_call_11 = AllocateExecutableMemoryCounted( 0x6C )
        set pfast_call_12 = AllocateExecutableMemoryCounted( 0x74 )
        set pfast_call_13 = AllocateExecutableMemoryCounted( 0x7C )

        set pstd_call_1   = AllocateExecutableMemoryCounted( 0x14 )
        set pstd_call_2   = AllocateExecutableMemoryCounted( 0x1C )
        set pstd_call_3   = AllocateExecutableMemoryCounted( 0x24 )
        set pstd_call_4   = AllocateExecutableMemoryCounted( 0x2C )
        set pstd_call_5   = AllocateExecutableMemoryCounted( 0x34 )
        set pstd_call_6   = AllocateExecutableMemoryCounted( 0x3C )

        set pc_call_1     = AllocateExecutableMemoryCounted( 0x18 )
        set pc_call_2     = AllocateExecutableMemoryCounted( 0x20 )
        set pc_call_3     = AllocateExecutableMemoryCounted( 0x28 )
        set pc_call_4     = AllocateExecutableMemoryCounted( 0x30 )
        set pc_call_5     = AllocateExecutableMemoryCounted( 0x38 )
        set pc_call_6     = AllocateExecutableMemoryCounted( 0x40 )

        loop
            exitwhen i > ( AllocatedMemorySize - 0x4 )
            call WriteRealMemory( pFastRead + i, 0 )
            set i = i + 4
        endloop

        set AllocatedMemorySize = 0
    endfunction

    function AllocateCallMemory takes nothing returns nothing
        call ReallocateCallMemory( ) // AllocateExecutableMemory( 37000 )
    endfunction
    
    function Init_APIMemoryCalls takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pMergeUnits          = pGameDLL + 0x2DDE40
                set pIgnoredUnits        = pGameDLL + 0x2DD9A0
                set pConvertUnits        = pGameDLL + 0x2DDE00
                set pGetUnitCount        = pGameDLL + 0x2DDB70
                set pAttackMoveXY        = pGameDLL + 0x2DE730
                set pMemcpy              = pGameDLL + 0x87F47C
                set pGetModuleHandle     = pGameDLL + 0x87F204
                set pGetProcAddress      = pGameDLL + 0x87F2BC
                set pVirtualAlloc        = pGameDLL + 0x87F134
        elseif PatchVersion == "1.26a" then
                set pMergeUnits          = pGameDLL + 0x2DD320
                set pIgnoredUnits        = pGameDLL + 0x2DCE80
                set pConvertUnits        = pGameDLL + 0x2DD2E0
                set pGetUnitCount        = pGameDLL + 0x2DD050
                set pAttackMoveXY        = pGameDLL + 0x2DDC10
                set pMemcpy              = pGameDLL + 0x86D3CC
                set pGetModuleHandle     = pGameDLL + 0x86D1D0
                set pGetProcAddress      = pGameDLL + 0x86D280
                set pVirtualAlloc        = pGameDLL + 0x86D0F4
        elseif PatchVersion == "1.27a" then
                set pMergeUnits          = pGameDLL + 0x891F20
                set pIgnoredUnits        = pGameDLL + 0x890FB0
                set pConvertUnits        = pGameDLL + 0x88E350
                set pGetUnitCount        = pGameDLL + 0x890750
                set pAttackMoveXY        = pGameDLL + 0x88CFE0
                set pMemcpy              = pGameDLL + 0x94E468
                set pGetModuleHandle     = pGameDLL + 0x94E184
                set pGetProcAddress      = pGameDLL + 0x94E168
                set pVirtualAlloc        = pGameDLL + 0x94E270
        elseif PatchVersion == "1.27b" then
                set pMergeUnits          = pGameDLL + 0x9BD020
                set pIgnoredUnits        = pGameDLL + 0x9BC0B0
                set pConvertUnits        = pGameDLL + 0x9B9450
                set pGetUnitCount        = pGameDLL + 0x9BB850
                set pAttackMoveXY        = pGameDLL + 0x9B80E0
                set pMemcpy              = pGameDLL + 0xA7C504
                set pGetModuleHandle     = pGameDLL + 0xA7C28C
                set pGetProcAddress      = pGameDLL + 0xA7C17C
                set pVirtualAlloc        = pGameDLL + 0xA7C2D0
        elseif PatchVersion == "1.28f" then
                set pMergeUnits          = pGameDLL + 0x971FB0
                set pIgnoredUnits        = pGameDLL + 0x971040
                set pConvertUnits        = pGameDLL + 0x96E3E0
                set pGetUnitCount        = pGameDLL + 0x9707E0
                set pAttackMoveXY        = pGameDLL + 0x96D070
                set pMemcpy              = pGameDLL + 0xA6B3DC
                set pGetModuleHandle     = pGameDLL + 0xA6B378
                set pGetProcAddress      = pGameDLL + 0xA6B24C
                set pVirtualAlloc        = pGameDLL + 0xA6B2B8
            endif

            if pMergeUnits != 0 then
                call AllocateCallMemory( )
                call InitFastReadMemory( )
                call InitFastWriteMemory( )
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_APIMemoryCalls takes nothing returns nothing
    //set gg_trg_APIMemoryCalls = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: APIMemoryBitwise
//===========================================================================
//TESH.scrollpos=119
//TESH.alwaysfold=0
//! nocjass
library APIMemoryBitwise
    globals
        integer pBitwiseOR_ExecutableMemory
        boolean bNeedInitBitwiseOr             = true
        integer pBitwiseXOR_ExecutableMemory
        boolean bNeedInitBitwiseXor            = true
        integer pBitwiseAND_ExecutableMemory
        boolean bNeedInitBitwiseAnd            = true
    endglobals

    function GetGameTypeSupported takes nothing returns integer
        return ReadRealPointer2LVL( pGameState, 0x30, 0x30 )
    endfunction

    function Player2Flag takes player p returns integer
        return R2I( Pow( 2, GetPlayerId( p ) ) )
    endfunction

    function IsFlagBitSet takes integer flags, integer bit returns boolean
        return flags / bit * 2147483648 != 0
    endfunction

    function ShiftLeftForBits takes integer byte, integer shiftval returns integer
        return byte * ( PowI( 2, shiftval ) )
    endfunction
    
    function ShiftRightForBits takes integer byte, integer shiftval returns integer
        return byte / ( PowI( 2, shiftval ) )
    endfunction
    
    function ShiftLeftForBytes takes integer byte, integer shiftval returns integer
        return ShiftLeftForBits( byte, shiftval * 8 )
    endfunction
    
    function ShiftRightForBytes takes integer byte, integer shiftval returns integer
        return ShiftRightForBits( byte, shiftval * 8 )
    endfunction

    function BitwiseOr takes integer arg1, integer arg2 returns integer
        local integer retval
     
        if bNeedInitBitwiseOr then
            set bNeedInitBitwiseOr = false
            call WriteRealMemory( pBitwiseOR_ExecutableMemory + 0x0, 0x0424448B )
            call WriteRealMemory( pBitwiseOR_ExecutableMemory + 0x4, 0x0824548B )
            call WriteRealMemory( pBitwiseOR_ExecutableMemory + 0x8, 0xCCC3D009 )
        endif

        if pConvertUnitsOffset == 0 then
            set pConvertUnitsOffset = CreateJassNativeHook( pConvertUnits, pBitwiseOR_ExecutableMemory )
        else
            call WriteRealMemory( pConvertUnitsOffset, pBitwiseOR_ExecutableMemory )
        endif
     
        if pConvertUnitsOffset != 0 then
            set retval = B2I( ConvertUnits( arg1,arg2 ) )
            call WriteRealMemory( pConvertUnitsOffset, pConvertUnits )
            return retval
        endif

        return 0
    endfunction

    function BitwiseXor takes integer arg1, integer arg2 returns integer
        local integer retval
     
        if bNeedInitBitwiseXor then
            set bNeedInitBitwiseXor = false
            call WriteRealMemory( pBitwiseXOR_ExecutableMemory + 0x0, 0x0424448B )
            call WriteRealMemory( pBitwiseXOR_ExecutableMemory + 0x4, 0x0824548B )
            call WriteRealMemory( pBitwiseXOR_ExecutableMemory + 0x8, 0xCCC3D031 )
        endif
     
        if pConvertUnitsOffset == 0 then
            set pConvertUnitsOffset = CreateJassNativeHook( pConvertUnits, pBitwiseXOR_ExecutableMemory )
        else
            call WriteRealMemory( pConvertUnitsOffset, pBitwiseXOR_ExecutableMemory )
        endif
     
        if pConvertUnitsOffset != 0 then
            set retval = B2I( ConvertUnits( arg1,arg2 ) )
            call WriteRealMemory( pConvertUnitsOffset, pConvertUnits )
            return retval
        endif

        return 0
    endfunction

    function BitwiseAnd takes integer arg1, integer arg2 returns integer
        local integer retval
     
        if bNeedInitBitwiseAnd then
            set bNeedInitBitwiseAnd = false
            call WriteRealMemory( pBitwiseAND_ExecutableMemory + 0x0, 0x0424448B )
            call WriteRealMemory( pBitwiseAND_ExecutableMemory + 0x4, 0x0824548B )
            call WriteRealMemory( pBitwiseAND_ExecutableMemory + 0x8, 0xCCC3D021 )
        endif

        if pConvertUnitsOffset == 0 then
            set pConvertUnitsOffset = CreateJassNativeHook( pConvertUnits, pBitwiseAND_ExecutableMemory )
        else
            call WriteRealMemory( pConvertUnitsOffset, pBitwiseAND_ExecutableMemory )
        endif
     
        if pConvertUnitsOffset != 0 then
            set retval = B2I( ConvertUnits( arg1,arg2 ) )
            call WriteRealMemory( pConvertUnitsOffset, pConvertUnits )
            return retval
        endif

        return 0
    endfunction
    
    function Init_APIMemoryBitwise takes nothing returns nothing
        local integer i = 0

        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
        elseif PatchVersion == "1.26a" then
        elseif PatchVersion == "1.27a" then
        elseif PatchVersion == "1.27b" then
        elseif PatchVersion == "1.28f" then
            endif

            set pBitwiseOR_ExecutableMemory  = AllocateExecutableMemory( 0xC )
            set pBitwiseXOR_ExecutableMemory = AllocateExecutableMemory( 0xC )
            set pBitwiseAND_ExecutableMemory = AllocateExecutableMemory( 0xC )
            
            loop
                exitwhen i > 0x8
                call WriteRealMemory( pBitwiseOR_ExecutableMemory + i, 0 )
                call WriteRealMemory( pBitwiseXOR_ExecutableMemory + i, 0 )
                call WriteRealMemory( pBitwiseAND_ExecutableMemory + i, 0 )
                set i = i + 4
            endloop
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_APIMemoryBitwise takes nothing returns nothing
    //set gg_trg_APIMemoryBitwise = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: APIMemoryString
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library APIMemoryForString
    globals
        integer pConvertString      = 0
        integer pSearchStringAddr1  = 0
        integer pSearchStringAddr2  = 0
        integer pSearchStringValue  = 0
        
        integer pSprintf            = 0
    endglobals

    function ToJString takes integer pCString returns string
        if pCString > 0 then
            return I2SH( this_call_1( pConvertString, pCString ) )
        endif

        return null
    endfunction
    
    function WriteCString takes integer pAddr, string text returns nothing
        call WriteRealMemory( pAddr, GetStringAddress( text ) )
    endfunction

    function ConvertNullTerminatedStringToString takes integer pNullTerminatedString returns string
        return ToJString( pNullTerminatedString )
    endfunction

    function WriteNullTerminatedString takes string s, integer pAddr returns nothing
        call WriteRealMemory( pAddr, GetStringAddress( s ) )
    endfunction
    
    function SearchStringValueAddress takes string str returns integer
        local integer retaddr = this_call_2( pSearchStringValue, pSearchStringAddr1, GetStringAddress( str ) )

        if retaddr == 0 or ReadRealMemory( retaddr + 0x1C ) == 0 then 
            set retaddr = this_call_2( pSearchStringValue, pSearchStringAddr2, GetStringAddress( str ) )
        endif

        if retaddr == 0 or ReadRealMemory( retaddr + 0x1C ) == 0 then 
            return 0
        endif

        return ReadRealMemory( retaddr + 0x1C )
    endfunction

    function SearchStringValue takes string str returns string
        return ToJString( SearchStringValueAddress( str ) )
    endfunction

    function ReplaceStringValue takes string str, integer newstraddress, integer str_len returns nothing
         local integer retaddr = SearchStringValueAddress( str )

         call CopyMemory( retaddr, newstraddress, str_len )
    endfunction

    function sprintf_1 takes string format, integer arg1 returns string
        call c_call_3( ReadRealMemory( pSprintf ), pReservedWritableMemory, GetStringAddress( format ), arg1 )
        return ToJString( pReservedWritableMemory )
    endfunction

    function sprintf_2 takes string format, integer arg1, integer arg2 returns string
        call c_call_4( ReadRealMemory( pSprintf ), pReservedWritableMemory, GetStringAddress( format ), arg1, arg2 )
        return ToJString( pReservedWritableMemory )
    endfunction

    function sprintf_3 takes string format, integer arg1, integer arg2, integer arg3 returns string
        call c_call_5( ReadRealMemory( pSprintf ), pReservedWritableMemory, GetStringAddress( format ), arg1, arg2, arg3 )
        return ToJString( pReservedWritableMemory )
    endfunction

    function sprintf_4 takes string format, integer arg1, integer arg2, integer arg3, integer arg4 returns string
        call c_call_6( ReadRealMemory( pSprintf ), pReservedWritableMemory, GetStringAddress( format ), arg1, arg2, arg3, arg4 )
        return ToJString( pReservedWritableMemory )
    endfunction
    
    function Init_APIMemoryString takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pConvertString      = pGameDLL + 0x3BB560
                set pSearchStringValue  = pGameDLL + 0x5C9670
                set pSearchStringAddr1  = pGameDLL + 0xAE409C
                set pSearchStringAddr2  = pGameDLL + 0xAE4074
                set pSprintf            = pGameDLL + 0x87F3AC
        elseif PatchVersion == "1.26a" then
                set pConvertString      = pGameDLL + 0x3BAA20
                set pSearchStringValue  = pGameDLL + 0x5C8ED0
                set pSearchStringAddr1  = pGameDLL + 0xACD23C
                set pSearchStringAddr2  = pGameDLL + 0xACD214
                set pSprintf            = pGameDLL + 0x86D32C
        elseif PatchVersion == "1.27a" then
                set pConvertString      = pGameDLL + 0x1DA520 // AbilityId2String -> result = sub_6F...(v1);
                set pSearchStringValue  = pGameDLL + 0x06B030 // if (... -> "Warning, string \"%s\" already encountered!"
                set pSearchStringAddr1  = pGameDLL + 0xBB9CD4 // if ( !a1 || !*a1 || !a2 || !a3 ) -> first dword_6F...
                set pSearchStringAddr2  = pGameDLL + 0xBB9CAC // if ( !a1 || !*a1 || !a2 || !a3 ) -> second dword_6F...
                set pSprintf            = pGameDLL + 0x94E464
        elseif PatchVersion == "1.27b" then
                set pConvertString      = pGameDLL + 0x1F7F60
                set pSearchStringValue  = pGameDLL + 0x0BF020
                set pSearchStringAddr1  = pGameDLL + 0xD4776C
                set pSearchStringAddr2  = pGameDLL + 0xD47744
                set pSprintf            = pGameDLL + 0xA7C500
        elseif PatchVersion == "1.28f" then
                set pConvertString      = pGameDLL + 0x22A770
                set pSearchStringValue  = pGameDLL + 0x0ED810
                set pSearchStringAddr1  = pGameDLL + 0xD0F54C
                set pSearchStringAddr2  = pGameDLL + 0xD0F524
                set pSprintf            = pGameDLL + 0xA6B3E0
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_APIMemoryString takes nothing returns nothing
    //set gg_trg_APIMemoryString = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: APIMemoryKernel
//===========================================================================
//TESH.scrollpos=347
//TESH.alwaysfold=0
//! nocjass
library APIMemoryKernel
    globals
        integer pIsBadReadPtr               = 0
        integer pGetSystemTime              = 0
        integer pGetLocalTime               = 0
        integer pSysTimeReservedMemory      = 0
        integer pGetCurrentProcessId        = 0
        integer pGetPrivateProfileStringA   = 0
        integer pWritePrivateProfileStringA = 0
        integer pGetFileAttributesA         = 0
        integer pLoadLibraryA               = 0
        integer pShellExecuteA              = 0
        integer pMessageBoxA                = 0
        integer pFindWindowA                = 0
        integer pFindWindowExA              = 0
        integer pGetWindowClassName         = 0
        integer pGetWindowText              = 0
        integer pPostMessageA               = 0
        integer pGetAsyncKeyState           = 0
        integer pWindowRect                 = 0
        integer pGetWindowRect              = 0
        integer pGetSystemMetrics           = 0
        integer pScreenToClient             = 0
        integer pCursorCoords               = 0
        integer pGetCursorPos               = 0
        integer pHWND_WC3                   = 0

        integer BenchmarkTime               = 0
        integer BenchmarkLastTime           = 0
    endglobals

    function IsBadReadPtr takes integer pointer, integer size returns boolean
        if pIsBadReadPtr == 0 then
            set pIsBadReadPtr = GetModuleProcAddress( "Kernel32.dll", "IsBadReadPtr" )
        endif

        if pIsBadReadPtr != 0 then
            return std_call_2( pIsBadReadPtr, pointer, size ) == 0
        endif

        return false
    endfunction
    
    // 0 - milisecond | 1 - Sec | 2 - Minutes | 3 - Hours | 4 - Day | 5 - Day of Week | 6 - Month | 7 - Year
    function GetLocalTime takes integer timeId returns integer
        local integer pOff   = 0
        local integer memval = 0

        if pGetLocalTime == 0 then 
            set pGetLocalTime = GetModuleProcAddress( "Kernel32.dll", "GetLocalTime" )
        endif

        if pGetLocalTime != 0 then 
            call std_call_1( pGetLocalTime, pSysTimeReservedMemory )

            if timeId >= 0 and timeId <= 7 then
                set memval = ReadRealMemory( pSysTimeReservedMemory + ( 0xE - timeId * 2 ) )

                if memval > 0 then
                    return CreateInteger1( 0, 0, GetByteFromInteger( memval, 3 ), GetByteFromInteger( memval, 4 ) )
                endif
            endif
        endif

        return 0
    endfunction

    function GetCurrentProcessId takes nothing returns integer
        if pGetCurrentProcessId == 0 then
            set pGetCurrentProcessId = GetModuleProcAddress( "Kernel32.dll", "GetCurrentProcessId" )
        endif

        if pGetCurrentProcessId != 0 then
            return c_call_1( pGetCurrentProcessId, 0 )
        endif

        return 0
    endfunction

    function VirtualProtect takes integer pRealOffset, integer pMemSize, integer pProtectFlag returns integer
        if pVirtualProtect == 0 then
            set pVirtualProtect = GetModuleProcAddress( "Kernel32.dll", "VirtualProtect" )
        endif

        if pVirtualProtect != 0 then
            call std_call_4( pVirtualProtect, pRealOffset, pMemSize, pProtectFlag, pReservedIntArg1 )
            return ReadRealMemory( pReservedIntArg1 )
        endif

        return 0
    endfunction

    function ReadStringFromFile takes string sfile, string ssection, string skey, string sdefval returns string
        if pGetPrivateProfileStringA == 0 then
            set pGetPrivateProfileStringA = GetModuleProcAddress( "Kernel32.dll", "GetPrivateProfileStringA" )
        endif
        
        if pGetPrivateProfileStringA != 0 then 
            // szReservedWritableMemory = 3000
            call std_call_6( pGetPrivateProfileStringA, GetStringAddress( ssection ), GetStringAddress( skey ), GetStringAddress( sdefval ), pReservedWritableMemory, 3000, GetStringAddress( sfile ) )
            return ToJString( pReservedWritableMemory )
        endif

        return ""
    endfunction

    function WriteStringToFile takes string sfile, string ssection, string skey, string sval returns nothing
        local integer nOffset1
        
        if pWritePrivateProfileStringA == 0 then
            set pWritePrivateProfileStringA = GetModuleProcAddress( "Kernel32.dll", "WritePrivateProfileStringA" )
        endif

        if pWritePrivateProfileStringA != 0 then 
            call std_call_4( pWritePrivateProfileStringA, GetStringAddress( ssection ), GetStringAddress( skey ), GetStringAddress( sval ), GetStringAddress( sfile ) )
        endif
    endfunction

    function GetFileAttributes takes string s returns integer
        if pGetFileAttributesA == 0 then
            set pGetFileAttributesA = GetModuleProcAddress( "Kernel32.dll", "GetFileAttributesA" )
        endif

        if pGetFileAttributesA != 0 then
            return std_call_1( pGetFileAttributesA, GetStringAddress( s ) )
        endif
     
        return 0
    endfunction

    function LoadLibrary takes string nDllName returns integer
        if pLoadLibraryA == 0 then
            set pLoadLibraryA = GetModuleProcAddress( "Kernel32.dll", "LoadLibraryA" )
        endif

        if pLoadLibraryA != 0 then
            return std_call_1( pLoadLibraryA, GetStringAddress( nDllName ) )
        endif

        return 0
    endfunction

    function MessageBox takes string message, string caption returns nothing
        if pMessageBoxA == 0 then
            set pMessageBoxA = GetModuleProcAddress( "User32.dll", "MessageBoxA" )
        endif

        if pMessageBoxA != 0 then
            call std_call_4( pMessageBoxA, 0, GetStringAddress( message ), GetStringAddress( caption ), 0 )
        endif
    endfunction

    function FindWindowByAddr takes integer c_addr, integer w_addr returns integer
        if pFindWindowA == 0 then
            set pFindWindowA = GetModuleProcAddress( "User32.dll", "FindWindowA" )
        endif
     
        if pFindWindowA != 0 then
            return std_call_2( pFindWindowA, c_addr, w_addr )
        endif

        return 0
    endfunction
    
    function FindWindow takes string class, string window returns integer
        local integer c_addr = 0
        local integer w_addr = 0

        if class != "" then
            set c_addr = GetStringAddress( class )
        endif
        
        if window != "" then
            set w_addr = GetStringAddress( window )
        endif

        return FindWindowByAddr( c_addr, w_addr )
    endfunction

    function FindWindowExByAddr takes integer hwid1, integer hwid2, integer c_addr, integer w_addr returns integer
        if pFindWindowExA == 0 then
            set pFindWindowExA = GetModuleProcAddress( "User32.dll", "FindWindowExA" )
        endif

        if pFindWindowExA != 0 then
            return std_call_4( pFindWindowExA, hwid1, hwid2, c_addr, w_addr )
        endif

        return 0
    endfunction

    function FindWindowEx takes integer hwid1, integer hwid2, string class, string window returns integer
        local integer c_addr = 0
        local integer w_addr = 0

        if class != "" then
            set c_addr = GetStringAddress( class )
        endif

        if window != "" then
            set w_addr = GetStringAddress( window )
        endif

        return FindWindowExByAddr( hwid1, hwid2, c_addr, w_addr )
    endfunction

    function GetWindowClassName takes integer hwid returns string
        if pGetWindowClassName == 0 then
            set pGetWindowClassName = GetModuleProcAddress( "User32.dll", "GetClassNameA" )
        endif

        if pGetWindowClassName != 0 then
            if hwid > 0 then
                call std_call_3( pGetWindowClassName, hwid, pReservedWritableMemory, 260 )
                return ToJString( pReservedWritableMemory )
            endif
        endif

        return ""
    endfunction

    function GetWindowText takes integer hwid returns string
        if pGetWindowText == 0 then
            set pGetWindowText = GetModuleProcAddress( "User32.dll", "GetWindowTextA" )
        endif

        if pGetWindowText != 0 then
            if hwid > 0 then
                call std_call_3( pGetWindowText, hwid, pReservedWritableMemory, 260 )
                return ToJString( pReservedWritableMemory )
            endif
        endif

        return ""
    endfunction

    function GetSystemMetrics takes integer id returns integer
        if pGetSystemMetrics == 0 then
            set pGetSystemMetrics = GetModuleProcAddress( "User32.dll", "GetSystemMetrics" )
        endif

        if pGetSystemMetrics != 0 then
            return std_call_1( pGetSystemMetrics, id )
        endif

        return 0
    endfunction

    function GetScreenWidth takes nothing returns integer
        return GetSystemMetrics( 0 )
    endfunction

    function GetScreenHeight takes nothing returns integer
        return GetSystemMetrics( 1 )
    endfunction

    function GetWindowRect takes integer hwnd returns integer
        if pGetWindowRect == 0 then
            set pGetWindowRect = GetModuleProcAddress( "User32.dll", "GetWindowRect" )
        endif

        if pGetWindowRect != 0 then
            // RECT structure
            // 0x0 = pWindowRect.left
            // 0x4 = pWindowRect.top
            // 0x8 = pWindowRect.right
            // 0xC = pWindowRect.bottom
            return std_call_2( pGetWindowRect, hwnd, pWindowRect )
        endif

        return 0
    endfunction

    function GetWindowX takes integer hwnd returns integer
        local integer pWRect = GetWindowRect( hwnd )

        if pWRect > 0 then
            return ReadRealMemory( pWindowRect + 0x0 )
        endif

        return 0
    endfunction

    function GetWindowY takes integer hwnd returns integer
        local integer pWRect = GetWindowRect( hwnd )

        if pWRect > 0 then
            return ReadRealMemory( pWindowRect + 0x4 )
        endif

        return 0
    endfunction
    
    function ScreenToClient takes integer hwnd, integer lpPoint returns integer
        if pScreenToClient == 0 then
            set pScreenToClient = GetModuleProcAddress( "User32.dll", "ScreenToClient" )
        endif

        if pScreenToClient != 0 then
            return std_call_2( pScreenToClient, hwnd, lpPoint )
        endif

        return 0
    endfunction

    function GetCursorPos takes nothing returns integer
        if pGetCursorPos == 0 then
            set pGetCursorPos = GetModuleProcAddress( "User32.dll", "GetCursorPos" )
        endif

        if pGetCursorPos != 0 then
            // tagPOINT structure
            // 0x0 = pCursorCoords.x
            // 0x4 = pCursorCoords.y
            return std_call_1( pGetCursorPos, pCursorCoords )
        endif

        return 0
    endfunction

    function PostMessage takes integer hwnd, integer msg, integer wparam, integer lparam returns nothing
        if pPostMessageA == 0 then
            set pPostMessageA = GetModuleProcAddress( "User32.dll", "PostMessageA" )
        endif

        if pPostMessageA != 0 then
            call std_call_4( pPostMessageA, hwnd, msg, wparam, lparam )
        endif

        //call PostMessage( pHWND_WC3, 0x0100, 0x0D, 0 )
        //call PostMessage( pHWND_WC3, 0x0101, 0x0D, 0 )
    endfunction

    function ShellExecute takes string command, string path, string args returns nothing
        if pShellExecuteA == 0 then
            set pShellExecuteA = GetModuleProcAddress( "Shell32.dll", "ShellExecuteA" )  // call ShellExecute( "open", url, "" )
        endif

        if pShellExecuteA != 0 then
            call std_call_6( pShellExecuteA, 0, GetStringAddress( command ), GetStringAddress( path ), GetStringAddress( args ), 0, 0 )
        endif
    endfunction

    function GetAsyncKeyState takes integer vk_key_code returns integer
        local integer retval = 0
        local integer nOffset1

        if pGetAsyncKeyState == 0 then
            set pGetAsyncKeyState = GetModuleProcAddress( "User32.dll", "GetAsyncKeyState" )
        endif

        if pGetAsyncKeyState != 0 then
            return std_call_1( pGetAsyncKeyState, vk_key_code )
        endif

        return retval
    endfunction

    function IsKeyPressed takes integer vk_key_code returns boolean
        // IsKeyPressed( VK_LMENU ) | VK_LMENU = 0xA4 | https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
        return BitwiseAnd( GetAsyncKeyState( vk_key_code ), 0x8000 ) > 0
    endfunction

    function StartBenchmark takes nothing returns integer
        set BenchmarkTime = GetLocalTime( 0 )
        return BenchmarkTime
    endfunction

    function StopBenchmark takes nothing returns integer
        set BenchmarkLastTime = GetLocalTime( 0 )
        return BenchmarkLastTime - BenchmarkTime
    endfunction

    function Init_APIMemoryKernel takes nothing returns nothing
        if PatchVersion != "" then
            set pSysTimeReservedMemory          = Malloc( 40 )
            set pReservedWritableMemory         = Malloc( 3000 )
            set pReservedWritableMemory2        = Malloc( 3000 )
            set pReservedIntArg1                = Malloc( 4 )
            set pReservedIntArg2                = Malloc( 4 )
            set pReservedIntArg3                = Malloc( 4 )
            set pReservedIntArg4                = Malloc( 4 )
            set pWindowRect                     = Malloc( 0x10 )
            set pCursorCoords                   = Malloc( 0x8 )
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_APIMemoryKernel takes nothing returns nothing
    //set gg_trg_APIMemoryKernel = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: APIMemoryMPQ
//
// This trigger can be safely removed, since it is not really used at all.
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library APIMemoryMPQ
    globals
        integer pStorm279      = 0
        integer pExportFromMPQ = 0
    endglobals

    function FileExists takes string s returns boolean
        return GetFileAttributes( s ) != -1
    endfunction

    function GetFileSizeFromMPQ takes string source returns integer
        call WriteRealMemory( pReservedIntArg2, 0 )
        call WriteRealMemory( pReservedIntArg1, 0 )
        call std_call_5( ReadRealMemory( pStorm279 ), GetStringAddress( source ), pReservedIntArg2, pReservedIntArg1, 1, 0 )

        return ReadRealMemory( pReservedIntArg1 )
    endfunction

    function ExportFileFromMPQByAddr takes integer saddr, integer daddr returns integer
        if pExportFromMPQ > 0 then
            return fast_call_2( pExportFromMPQ, saddr, daddr )
        endif

        return 0
    endfunction

    function ExportFileFromMPQ takes string source, string dest returns boolean
        return ExportFileFromMPQByAddr( GetStringAddress( source ), GetStringAddress( dest ) ) > 0
    endfunction

    function LoadDllFromMPQ takes string source, string dest, string dllname returns boolean
        if ExportFileFromMPQ( source, dest ) then
            call LoadLibrary( dllname )
            return true
        endif

        return false
    endfunction

    function Init_APIMemoryMPQ takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pStorm279       = pGameDLL + 0x87F63C
                set pExportFromMPQ  = pGameDLL + 0x7386A0
        elseif PatchVersion == "1.26a" then
                set pStorm279       = pGameDLL + 0x86D5B8
                set pExportFromMPQ  = pGameDLL + 0x737F00
        elseif PatchVersion == "1.27a" then
                set pStorm279       = pGameDLL + 0x94E6C4
                set pExportFromMPQ  = pGameDLL + 0x702C50 // IDA Pro search text mov     edx, offset aWb ; "wb" -> look at the top align 10h -> push ebp and so on
        elseif PatchVersion == "1.27b" then
                set pStorm279       = pGameDLL + 0xA7C75C
                set pExportFromMPQ  = pGameDLL + 0x720390
        elseif PatchVersion == "1.28f" then
                set pStorm279       = pGameDLL + 0xA6B854
                set pExportFromMPQ  = pGameDLL + 0x754560
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_APIMemoryMPQ takes nothing returns nothing
    //set gg_trg_APIMemoryMPQ = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: APIMemoryRestorer
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library APIMemoryRestorer
    globals
        boolean bGameIsClosing                = false

        integer array iaOffsetsToRestoreVals
        integer array iaOffsetsToRestore
        integer pExtrasPage                   = 0
        integer pTriggerExecute               = 0
        integer pFinalTableHook               = 0
        integer pOffsetsToRestoreC            = 0
        integer pFinalTableHookRealValue1     = 0
        integer pFinalTableHookRealValue2     = 0
    endglobals

    function AddNewOffsetToRestore takes integer offsetaddress, integer offsetdefaultdata returns nothing
        local integer i

        if bGameIsClosing then
            return
        endif

        set i = pOffsetsToRestoreC
        loop
            exitwhen i == 0
            if iaOffsetsToRestore[ i ] == offsetaddress then
                return
            endif
            set i = i - 1
        endloop

        set pOffsetsToRestoreC = pOffsetsToRestoreC + 1
        set iaOffsetsToRestore[ pOffsetsToRestoreC ] = offsetaddress
        set iaOffsetsToRestoreVals[ pOffsetsToRestoreC ] = offsetdefaultdata
    endfunction

    function ChangeOffsetProtection takes integer pRealOffset, integer pMemSize, integer pProtectFlag returns integer
        local integer a
        local integer nIndex = 0

        if pVirtualProtect == 0 then
            set pVirtualProtect = GetModuleProcAddress( "Kernel32.dll", "VirtualProtect" )
        endif

        if pVirtualProtect != 0 then
            call AddNewOffsetToRestore( pRealOffset, ReadRealMemory( pRealOffset ) )
            if pMemSize > 4 then
                set nIndex = pMemSize / 4 - 0x1
                set a = pRealOffset
                loop
                    exitwhen nIndex < 0x1
                    set a = a + 0x4
                    call AddNewOffsetToRestore( a, ReadRealMemory( a ) )
                    set nIndex = nIndex - 0x1
                endloop
            endif
            call std_call_4( pVirtualProtect, pRealOffset, pMemSize, pProtectFlag, pReservedIntArg1 )
            return ReadRealMemory( pReservedIntArg1 )
        endif

        return 0
    endfunction

    function PatchRealMemoryEx takes integer addr, integer val, integer size returns nothing
        local integer oldprotection = VirtualProtect( addr, size, 0x40 )
        call WriteRealMemory( addr, val )
        call VirtualProtect( addr, size, oldprotection )
    endfunction

    function PatchRealMemory takes integer addr, integer val returns nothing
        call PatchRealMemoryEx( addr, val, 0x4 )
    endfunction

    function PatchMemoryEx takes integer addr, integer val, integer size returns nothing
        local integer oldprotection = VirtualProtect( addr, size, 0x40 )
        call WriteMemory( addr, val )
        call VirtualProtect( addr, size, oldprotection )
    endfunction

    function PatchMemory takes integer addr, integer val returns nothing
        call PatchMemoryEx( addr, val, 0x4 )
    endfunction
    
    function RestoreAllMemory takes nothing returns nothing
        local integer i = pOffsetsToRestoreC
        local integer oldprotection

        set bGameIsClosing = true
        loop
            exitwhen i < 1
            set oldprotection = ChangeOffsetProtection( iaOffsetsToRestore[ i ], 0x4, 0x40 )
            call WriteRealMemory( iaOffsetsToRestore[ i ], iaOffsetsToRestoreVals[ i ] )
            call ChangeOffsetProtection( iaOffsetsToRestore[ i ], 0x4, oldprotection )
            set i = i - 1
        endloop
    endfunction

    function InitExtrasPageDisplayOnExit takes integer pTriggerHandle returns nothing
        local integer oldprotection   = VirtualProtect( pExtrasPage, 0x8, 0x40 )
        local integer address         = pExtrasPage

        set pFinalTableHookRealValue1 = ReadRealMemory( pExtrasPage )
        set pFinalTableHookRealValue2 = ReadRealMemory( pExtrasPage + 0x4 )

        call WriteRealMemory( address, 0xE9E9E9E9 )                                                    // jmp | jmp | jmp | jmp
        call WriteRealMemory( address + 1, pFinalTableHook - ( address + 1 ) - 0x4 )                   // redirection to new address
        call WriteRealMemory( pFinalTableHook + 0x00, 0x68609090 )                                     // nop | nop | pusha | push (pTriggerHandle)
        call WriteRealMemory( pFinalTableHook + 0x04, pTriggerHandle )                                 // argument getting pushed
        call WriteRealMemory( pFinalTableHook + 0x08, 0xB890C08B )                                     // mov eax, eax | nop | mov eax, pTriggerExecute
        call WriteRealMemory( pFinalTableHook + 0x0C, pTriggerExecute )                                // argument getting moved into eax
        call WriteRealMemory( pFinalTableHook + 0x10, 0xC483D0FF )                                     // call eax | add esp, 0x4
        call WriteRealMemory( pFinalTableHook + 0x14, 0xE9906104 )                                     // 0x4 | popa | nop | jmp (pExtrasPage)
        call WriteRealMemory( pFinalTableHook + 0x18, pExtrasPage - ( pFinalTableHook + 0x18 ) - 0x4 ) // argument that we jump to
        call VirtualProtect( pExtrasPage, 0x8, oldprotection )                                         // Restoring original Memory Protection Method
    endfunction

    function DisplayExtrasPageDisplayOnExit takes nothing returns nothing
        local integer oldprotection = VirtualProtect( pExtrasPage, 0x8, 0x40 )

        call WriteRealMemory( pExtrasPage, pFinalTableHookRealValue1 )
        call WriteRealMemory( pExtrasPage + 0x4, pFinalTableHookRealValue2 )
        call VirtualProtect( pExtrasPage, 0x8, oldprotection )
        call RestoreAllMemory( )
    endfunction

    function Init_RestoreMemoryOnExit takes trigger t returns nothing
        set pFinalTableHook = AllocateExecutableMemory( 60 * 0x4 )
        call TriggerAddAction( t, function DisplayExtrasPageDisplayOnExit )
        call InitExtrasPageDisplayOnExit( GetHandleId( t ) )
    endfunction
    
    function Init_APIMemoryRestorer takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pTriggerExecute = pGameDLL + 0x3C4A80
                set pExtrasPage     = pGameDLL + 0x5C48C0
        elseif PatchVersion == "1.26a" then
                set pTriggerExecute = pGameDLL + 0x3C3F40
                set pExtrasPage     = pGameDLL + 0x5C4120
        elseif PatchVersion == "1.27a" then
                set pTriggerExecute = pGameDLL + 0x1F9100
                set pExtrasPage     = pGameDLL + 0x2847F0 // 1074331777, (int)sub_6F -> *(_DWORD *)(v3 + 16));
        elseif PatchVersion == "1.27b" then
                set pTriggerExecute = pGameDLL + 0x216D90
                set pExtrasPage     = pGameDLL + 0x2A23E0
        elseif PatchVersion == "1.28f" then
                set pTriggerExecute = pGameDLL + 0x249410
                set pExtrasPage     = pGameDLL + 0x2D4940
            endif
            
            call Init_RestoreMemoryOnExit( CreateTrigger( ) )
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_APIMemoryRestorer takes nothing returns nothing
    //set gg_trg_APIMemoryRestorer = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: APIMemoryStormDLL
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library APIMemoryhStormDLL
    globals
        integer pStormDLL                   = 0
        integer pStormAllocateMemory        = 0
        integer pStormFreeMemory            = 0
        integer pStormGetMemorySize         = 0
        integer pStormReallocateMemory      = 0
    endglobals

    function StormAllocateMemory takes integer size, string name, integer unk_1, integer unk_2 returns integer
        if pStormAllocateMemory > 0 then
            if size > 0 then
                return std_call_4( pStormAllocateMemory, size, GetStringAddress( name ), unk_1, unk_2 )
            endif
        endif

        return 0
    endfunction

    function StormFreeMemory takes integer addr, string name, integer unk_1, integer unk_2 returns integer
        if pStormFreeMemory > 0 then
            if addr > 0 then
                return std_call_4( pStormFreeMemory, addr, GetStringAddress( name ), unk_1, unk_2 )
            endif
        endif

        return 0
    endfunction

    function StormGetMemorySize takes integer addr, string name, integer unk_1 returns integer
        if pStormGetMemorySize > 0 then
            if addr > 0 then
                return std_call_3( pStormGetMemorySize, addr, GetStringAddress( name ), unk_1 )
            endif
        endif

        return 0
    endfunction

    function StormReallocateMemory takes integer addr, integer size, string name, integer unk_1, integer unk_2 returns integer
        if pStormReallocateMemory > 0 then
            if size > 0 and size > 0 then
                return std_call_5( pStormReallocateMemory, addr, size, GetStringAddress( name ), unk_1, unk_2 )
            endif
        endif

        return 0
    endfunction
    
    function Init_APIMemoryStormDLL takes nothing returns nothing
        if PatchVersion != "" then
            set pStormDLL = GetModuleHandle( "Storm.dll" )

            if pStormDLL > 0 then
                if PatchVersion == "1.24e" then
                    set pStormAllocateMemory    = pStormDLL + 0x025F30
                    set pStormFreeMemory        = pStormDLL + 0x024880
                    set pStormGetMemorySize     = pStormDLL + 0x024AD0
                    set pStormReallocateMemory  = pStormDLL + 0x026230
            elseif PatchVersion == "1.26a" then
                    set pStormAllocateMemory    = pStormDLL + 0x025F30
                    set pStormFreeMemory        = pStormDLL + 0x024880
                    set pStormGetMemorySize     = pStormDLL + 0x024AD0
                    set pStormReallocateMemory  = pStormDLL + 0x026230
            elseif PatchVersion == "1.27a" then
                    set pStormAllocateMemory    = pStormDLL + 0x02B830 // Storm_401
                    set pStormFreeMemory        = pStormDLL + 0x02BE40 // Storm_403
                    set pStormGetMemorySize     = pStormDLL + 0x02C000 // Storm_404
                    set pStormReallocateMemory  = pStormDLL + 0x02C8B0 // Storm_405
            elseif PatchVersion == "1.27b" then
                    set pStormAllocateMemory    = pStormDLL + 0x02B6D0
                    set pStormFreeMemory        = pStormDLL + 0x02BCE0
                    set pStormGetMemorySize     = pStormDLL + 0x02BEA0
                    set pStormReallocateMemory  = pStormDLL + 0x02C760
            elseif PatchVersion == "1.28f" then
                    set pStormAllocateMemory    = pStormDLL + 0x02BC10
                    set pStormFreeMemory        = pStormDLL + 0x02C220
                    set pStormGetMemorySize     = pStormDLL + 0x02C3E0
                    set pStormReallocateMemory  = pStormDLL + 0x02CC90
                endif
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_APIMemoryStormDLL takes nothing returns nothing
    //set gg_trg_APIMemoryStormDLL = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: APIMemoryGameData
//===========================================================================
//TESH.scrollpos=309
//TESH.alwaysfold=0
//! nocjass
library APIMemoryGameData
    globals
        integer pGameState          = 0
        integer pGameClass1         = 0
        integer pGetUnitAddress     = 0
        integer pGetHandleId        = 0
        integer pHandleIdToObject   = 0
        integer pObjectToHandleId   = 0
        integer pGetHashKey         = 0
        integer pGetDataNode        = 0
        integer pGetUIDataNode      = 0
        integer pGetWidgetUIDef     = 0
        integer pGetAgentUIDef      = 0
        integer pToJUnit            = 0
        integer pGetObjectFromHash  = 0

        hashtable htObjectDataPointers = InitHashtable( )
        
        integer pVector2Arg                 = 0
        integer pVector3Arg                 = 0
    endglobals

    function SaveCode takes hashtable ht, integer parentKey, integer childKey, code c returns nothing
        if ht != null then
            call SaveInteger( ht, parentKey, childKey, C2I( c ) )
        endif
    endfunction

    function LoadCode takes hashtable ht, integer parentKey, integer childKey returns code
        if ht != null then
            return I2C( LoadInteger( ht, parentKey, childKey ) )
        endif

        return null
    endfunction

    function ConvertHandleId takes integer handleid returns integer
        if handleid > 0 then
            return ReadRealMemory( ReadRealMemory( ReadRealMemory( ReadRealMemory( pGameState ) + 0x1C ) + 0x19C ) + handleid * 0xC - 0x2FFFFF * 4 )
        endif

        return 0
    endfunction
    
    function ConvertHandle takes handle h returns integer
        return ConvertHandleId( GetHandleId( h ) )
    endfunction

    function HandleIdToObject takes integer handleid returns integer
        local integer pData = this_call_1( pGetHandleId, ReadRealMemory( pGameState ) )

        if pData > 0 then
            return this_call_2( pHandleIdToObject, pData, handleid )
        endif
        
        return 0
    endfunction
    
    function ObjectToHandleId takes integer address returns integer
        local integer pData = this_call_1( pGetHandleId, ReadRealMemory( pGameState ) )

        if pData > 0 then
            return this_call_3( pObjectToHandleId, pData, address, 0 )
        endif
        
        return 0
    endfunction

    function GetAgentType takes handle h returns integer
        // returns code of the handle's type
        // +w3u for unit, +tmr for timer, +trg for trigger, +arg for region, etc...
 
        local integer func = ReadRealMemory( ReadRealMemory( ConvertHandle( h ) ) + 0x1C )
        return ReadRealMemory( func ) / 0x100 + ReadRealMemory( func + 0x4 ) * 0x1000000
    endfunction

    function ObjectToAbility takes integer pObject returns ability
        local integer pAbil = 0

        if pObject > 0 then
            set pAbil = ObjectToHandleId( pObject )

            if pAbil > 0 then
                return I2A( pAbil )
            endif
        endif

        return null
    endfunction
    
    function ObjectToUnit takes integer pObject returns unit
        local integer pUnit = 0

        if pObject > 0 then
            set pUnit = fast_call_1( pToJUnit, pObject )

            if pUnit > 0 then
                return I2U( pUnit )
            endif
        endif
        
        return null
    endfunction
    
    function GetAgentHashKey takes integer agentId returns integer
        local integer pData = 0

        if pGetHashKey != 0 and agentId != 0 then
            call WriteRealMemory( pReservedIntArg1, agentId )
            set pData = this_call_1( pGetHashKey, pReservedIntArg1 )
        endif

        return pData
    endfunction
    
    function GetAgileDataNodeById takes integer pDataNode, integer agentId returns integer
        local integer pData = GetAgentHashKey( agentId )

        if pGetDataNode != 0 and pData != 0 then
            return this_call_3( pGetDataNode, pDataNode, pData, pReservedIntArg1 )
        endif

        return 0
    endfunction

    function GetWidgetUIDefById takes integer wid returns integer // Units/Destructables/Items (aka widgets)
        if pGetWidgetUIDef != 0 and wid != 0 then
            return this_call_1( pGetWidgetUIDef, wid )
        endif

        return 0
    endfunction

    function GetAgentUIDefById takes integer agentId returns integer // Only use this on Abilities
        if pGetWidgetUIDef != 0 and agentId != 0 then
            return this_call_1( pGetAgentUIDef, agentId )
        endif

        return 0
    endfunction

    function GetUnitAddress takes unit u returns integer
        return this_call_1( pGetUnitAddress, GetHandleId( u ) )
    endfunction

    function GetCObjectFromHashEx takes integer pHash1, integer pHash2 returns integer // call of sub_6F03FA30 (1.26a)
        if pHash1 != 0xFFFFFFFF and pHash2 != 0xFFFFFFFF and pGetObjectFromHash > 0 then
            return fast_call_2( pGetObjectFromHash, pHash1, pHash2 )
        endif

        return 0
    endfunction

    function GetCObjectFromHashGroupEx takes integer pHashGroup returns integer // Simplified version of GetCObjectFromHashEx, uses a pointer to HashGroup
        if pHashGroup > 0 then
            return GetCObjectFromHashEx( ReadRealMemory( pHashGroup + 0x0 ), ReadRealMemory( pHashGroup + 0x4 ) )
        endif

        return 0
    endfunction

    function GetCObjectFromHash takes integer pHash1, integer pHash2 returns integer // Jass Variant of sub_6F03FA30 (126a)
        local integer pOff1 = 0x2C

        if BitwiseAnd( pHash1, pHash2 ) == -1 then
            return 0
        endif

        if pHash1 >= 0 then
            set pOff1 = 0xC
        endif

        set pOff1 = ReadRealMemory( pGameClass1 ) + pOff1
        set pOff1 = ReadRealMemory( pOff1 )

        if pOff1 == 0 then
            return 0
        endif

        set pOff1 = ReadRealMemory( pOff1 + 0x8 * pHash1 + 0x4 )

        if pOff1 == 0 or ReadRealMemory( pOff1 + 0x18 ) != pHash2 then
            return 0
        endif

        return pOff1
    endfunction

    function GetCAgentFromHash takes integer pHash1, integer pHash2 returns integer // Jass Variant of sub_6F4786B0 (126a) || pass the read values, not the pointers.
        local integer pOff1 = GetCObjectFromHash( pHash1, pHash2 )

        if pOff1 == 0 or ReadRealMemory( pOff1 + 0x20 ) > 0 then
            return 0
        endif

        return ReadRealMemory( pOff1 + 0x54 )
    endfunction

    function GetCObjectFromHashGroup takes integer pHashGroup returns integer
        // Alternative to GetCObjectFromHash( ReadRealMemory( pHash + 0x0 ), ReadRealMemory( pHash + 0x4 ) )
        local integer pOffset1 = pHashGroup
        local integer pOffset2

        if pHashGroup > 0 then
            set pOffset2 = ReadRealMemory( pGameClass1 )

            if pOffset2 > 0 then
                set pOffset1 = ReadRealMemory( pOffset1 )
                set pOffset2 = ReadRealMemory( pOffset2 + 0xC )
                set pOffset2 = ReadRealMemory( ( pOffset1 * 0x8 ) + pOffset2 + 0x4 )
                return pOffset2
            endif
        endif

        return 0
    endfunction

    function GetCObjectFromHashGroup2 takes integer pHash returns integer
        if pHash > 0 then
            return GetCObjectFromHash( ReadRealMemory( pHash + 0x0 ), ReadRealMemory( pHash + 0x4 ) )
        endif

        return 0
    endfunction

    function GetUnitAddressFloatsRelated takes integer pObject, integer offset returns integer
         // Left here for compatibility reasons, use GetObjectFromHashGroup( pObject + offset ) instead.
        if pObject > 0 then
            return GetCObjectFromHashGroup( pObject + offset )
        endif

        return 0
    endfunction

    function GetAgentTimerCooldown takes integer pTimer returns real
        local integer pData = 0

        if pTimer > 0 then
            set pData = ReadRealMemory( pTimer )

            if pData > 0 then
                call WriteRealMemory( pReservedIntArg1, 0 )
                call this_call_2( ReadRealMemory( pData + 0x18 ), pTimer, pReservedIntArg1 )
                return ReadRealFloat( pReservedIntArg1 )
            endif
        endif

        return -1. // to ensure failure
    endfunction

    function GetAgentTimerExtendedCooldown takes integer pTimerExt returns real
        local integer pData = 0

        if pTimerExt > 0 then
            set pData = ReadRealMemory( pTimerExt )

            if pData > 0 then
                call WriteRealMemory( pReservedIntArg2, 0 )
                call WriteRealMemory( pReservedIntArg3, 0 )
                call this_call_2( ReadRealMemory( pData + 0x10 ), pTimerExt, pReservedIntArg1 )
                call this_call_2( ReadRealMemory( pData + 0x1C ), pTimerExt, pReservedIntArg2 )
                return ReadRealFloat( pReservedIntArg1 ) - ReadRealFloat( pReservedIntArg2 )
            endif
        endif

        return -1. // to ensure failure
    endfunction
    
    function Init_APIMemoryGameData takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pGameState          = pGameDLL + 0xACD44C
                set pGameClass1         = pGameDLL + 0xACE5E0
                set pGetUnitAddress     = pGameDLL + 0x3BE7F0
                set pGetHandleId        = pGameDLL + 0x3A8BA0
                set pHandleIdToObject   = pGameDLL + 0x428B90
                set pObjectToHandleId   = pGameDLL + 0x4317C0
                set pGetHashKey         = pGameDLL + 0x4C9020
                set pGetDataNode        = pGameDLL + 0x46F230
                set pGetUIDataNode      = pGameDLL + 0x001EC0
                set pGetWidgetUIDef     = pGameDLL + 0x32D3C0
                set pGetAgentUIDef      = pGameDLL + 0x32D420
                set pToJUnit            = pGameDLL + 0x2DD760
                set pGetObjectFromHash  = pGameDLL + 0x040770
        elseif PatchVersion == "1.26a" then
                set pGameState          = pGameDLL + 0xAB65F4
                set pGameClass1         = pGameDLL + 0xAB7788
                set pGetUnitAddress     = pGameDLL + 0x3BDCB0
                set pGetHandleId        = pGameDLL + 0x3A8060
                set pHandleIdToObject   = pGameDLL + 0x428050
                set pObjectToHandleId   = pGameDLL + 0x430C80
                set pGetHashKey         = pGameDLL + 0x4C8520
                set pGetDataNode        = pGameDLL + 0x46E720
                set pGetUIDataNode      = pGameDLL + 0x001EC0
                set pGetWidgetUIDef     = pGameDLL + 0x32C880
                set pGetAgentUIDef      = pGameDLL + 0x32C8E0
                set pToJUnit            = pGameDLL + 0x2DCC40
                set pGetObjectFromHash  = pGameDLL + 0x03FA30
        elseif PatchVersion == "1.27a" then
                set pGameState          = pGameDLL + 0xBE4238 // Inside ExecuteFunc | under Concurrency::details::ContextBase dword_... = v3
                set pGameClass1         = pGameDLL + 0xBE40A8 // "DispatchUnitSelectionModify Start for player %d" -> & 0x7FFFFFFFu) >= *(_DWORD *)(dword_6F... + 60
                set pGetUnitAddress     = pGameDLL + 0x1D1550 // WaygateSetDestination -> result = (signed int *)
                set pGetHandleId        = pGameDLL + 0x1C3200 // this + 7, 0, 0, 0);
                set pHandleIdToObject   = pGameDLL + 0x268380 // this[103] + 12 * a2 - 12582908);
                set pObjectToHandleId   = pGameDLL + 0x2651D0 // (_DWORD *)(v4[112] + 12 * (v5 & v8));
                set pGetHashKey         = pGameDLL + 0x17A710 // for ( i = -286331154; v1; i += v4 + 32 * i + v2
                set pGetDataNode        = pGameDLL + 0x0352A0 // first while ( *result != a2 || result[5] != *a3 )
                set pGetUIDataNode      = pGameDLL + 0x021BD0
                set pGetWidgetUIDef     = pGameDLL + 0x327020
                set pGetAgentUIDef      = pGameDLL + 0x322C30
                set pToJUnit            = pGameDLL + 0x88F250 // GetCreepCamp -> JUMPOUT(&loc_6F...);
                set pGetObjectFromHash  = pGameDLL + 0x037350
        elseif PatchVersion == "1.27b" then
                set pGameState          = pGameDLL + 0xD687A8
                set pGameClass1         = pGameDLL + 0xD68610
                set pGetUnitAddress     = pGameDLL + 0x1EEF90
                set pGetHandleId        = pGameDLL + 0x1E0D70
                set pHandleIdToObject   = pGameDLL + 0x285FE0
                set pObjectToHandleId   = pGameDLL + 0x282E30
                set pGetHashKey         = pGameDLL + 0x198420
                set pGetDataNode        = pGameDLL + 0x052480
                set pGetUIDataNode      = pGameDLL + 0x03ECD0
                set pGetWidgetUIDef     = pGameDLL + 0x344760
                set pGetAgentUIDef      = pGameDLL + 0x340380
                set pToJUnit            = pGameDLL + 0x9BA350
                set pGetObjectFromHash  = pGameDLL + 0x054530
        elseif PatchVersion == "1.28f" then
                set pGameState          = pGameDLL + 0xD305E0
                set pGameClass1         = pGameDLL + 0xD30448
                set pGetUnitAddress     = pGameDLL + 0x2217A0
                set pGetHandleId        = pGameDLL + 0x2135F0
                set pHandleIdToObject   = pGameDLL + 0x2B8490
                set pObjectToHandleId   = pGameDLL + 0x2B52E0
                set pGetHashKey         = pGameDLL + 0x1CACC0
                set pGetDataNode        = pGameDLL + 0x07BFE0
                set pGetUIDataNode      = pGameDLL + 0x069D60
                set pGetWidgetUIDef     = pGameDLL + 0x378720
                set pGetAgentUIDef      = pGameDLL + 0x374340
                set pToJUnit            = pGameDLL + 0x96F2E0
                set pGetObjectFromHash  = pGameDLL + 0x07E090
            endif
            
            set pVector2Arg = Malloc( 0x8 )
            set pVector3Arg = Malloc( 0xC )
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_APIMemoryGameData takes nothing returns nothing
    //set gg_trg_APIMemoryGameData = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCObjectAPI
//
// API for CSpriteUber, which are Effects/Trackables which are also inherited by Units.
// Handles such as items/destructabls/doodads use CSpriteMini instead.
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCObjectAPI
//APIMemoryCObjectData
    globals
        integer pSetObjectAlpha     = 0
        integer pSetObjectAnimation = 0
    endglobals

    function GetARGBColour takes integer alpha, integer red, integer green, integer blue returns integer
        return CreateInteger1( alpha, red, green, blue )
    endfunction

    function IsObjectHidden takes integer pObject returns boolean
        if pObject > 0 then
            return IsFlagBitSet( ReadRealMemory( pObject + 0x20 ), 1 )
        endif

        return false
    endfunction

    function ShowObject takes integer pObject, boolean flag returns nothing
        if pObject > 0 then
            call WriteRealMemory( pObject + 0x20, B2I( not flag ) )
        endif
    endfunction

    function GetObjectTypeId takes integer pObj returns integer
        // Do NOT use this with effects or trackables, since they do not have TypeId
        if pObj > 0 then
            return ReadRealMemory( pObj + 0x30 )
        endif

        return 0
    endfunction    

    function GetObjectSprite takes integer pObject returns integer
        // Units and Effects return CSpriteUber | items and destructables returns CSpriteMini
        if pObject != 0 then
            return ReadRealMemory( pObject + 0x28 )
        endif

        return 0
    endfunction

    function GetObjectSpriteFloat takes integer pObject, integer offset returns real
        local integer pSprite = GetObjectSprite( pObject )

        if pSprite != 0 then
            return ReadRealFloat( pSprite + offset )
        endif

        return 0.
    endfunction

    function SetObjectSpriteFloat takes integer pObject, integer offset, real value returns real
        local integer pSprite = GetObjectSprite( pObject )

        if pSprite != 0 then
            call WriteRealFloat( pSprite + offset, value )
        endif

        return 0.
    endfunction

    function UpdateObjectColour takes integer pObject returns nothing // pObject = ConvertHandle( h )
        // Does not work on CSpriteMini, refer to GetObjectSprite for explanation.
        local integer pSprite = GetObjectSprite( pObject )
        local integer flag    = 0

        if pSprite != 0 then
            call WriteRealMemory( pSprite + 0x140, 0 )
            call WriteRealMemory( pSprite + 0x13C, 0 )
            set flag = ReadRealMemory( pSprite + 0x138 )

            if not IsFlagBitSet( flag, 0x800 ) then
                call WriteRealMemory( pSprite + 0x138, flag + 0x800 )
            endif
        endif
    endfunction

    function SetObjectAlpha takes integer pObject, integer alpha returns nothing
        // Does not work on items/units/destructables/doodads, meaning only works on Effects (they are pure CSpriteUber)
        local integer pSprite = GetObjectSprite( pObject )

        if pSprite != 0 then
            if alpha >= 0x00 and alpha <= 0xFF then
                call fast_call_3( pSetObjectAlpha, pSprite, alpha, 0 )
            endif
        endif
    endfunction

    function GetObjectColour takes integer pObject returns integer
        // Does not work on CSpriteMini, refer to GetObjectSprite for explanation.
        local integer pSprite = GetObjectSprite( pObject )

        if pSprite != 0 then
            return ReadRealMemory( pSprite + 0x148 )
        endif

        return 0
    endfunction

    function SetObjectColour takes integer pObject, integer colour returns nothing
        // Does not work on CSpriteMini, refer to GetObjectSprite for explanation.
        local integer pSprite = GetObjectSprite( pObject )

        if pSprite != 0 then
            call WriteRealMemory( pSprite + 0x148, colour )
            call UpdateObjectColour( pObject )
        endif
    endfunction

    function SetObjectColourEx takes integer pObject, integer red, integer green, integer blue, integer alpha returns nothing
        if pObject != 0 then
            call SetObjectColour( pObject, CreateInteger1( alpha, red, green, blue ) )
        endif
    endfunction
    
    function SetObjectVertexColour takes integer pObject, integer red, integer green, integer blue, integer alpha returns nothing
        call SetObjectColourEx( pObject, red, green, blue, alpha )
        call SetObjectAlpha( pObject, alpha )
    endfunction

    function GetObjectColourA takes integer pObject returns integer
        if pObject != 0 then
            return GetByteFromInteger( GetObjectColour( pObject ), 1 )
        endif
        
        return -1
    endfunction

    function SetObjectColourA takes integer pObject, integer alpha returns nothing
        local integer colour = 0

        if pObject != 0 then
            set colour = GetObjectColour( pObject )
            call SetObjectColour( pObject, CreateInteger1( alpha, GetByteFromInteger( colour, 2 ), GetByteFromInteger( colour, 3 ), GetByteFromInteger( colour, 4 ) ) )
        endif
    endfunction

    function GetObjectColourR takes integer pObject returns integer
        if pObject != 0 then
            return GetByteFromInteger( GetObjectColour( pObject ), 2 )
        endif

        return -1
    endfunction

    function SetObjectColourR takes integer pObject, integer red returns nothing
        local integer colour = 0

        if pObject != 0 then
            set colour = GetObjectColour( pObject )
            call SetObjectColour( pObject, CreateInteger1( GetByteFromInteger( colour, 1 ), red, GetByteFromInteger( colour, 3 ), GetByteFromInteger( colour, 4 ) ) )
        endif
    endfunction
    
    function GetObjectColourG takes integer pObject returns integer
        if pObject != 0 then
            return GetByteFromInteger( GetObjectColour( pObject ), 3 )
        endif

        return -1
    endfunction

    function SetObjectColourG takes integer pObject, integer green returns nothing
        local integer colour = 0

        if pObject != 0 then
            set colour = GetObjectColour( pObject )
            call SetObjectColour( pObject, CreateInteger1( GetByteFromInteger( colour, 1 ), GetByteFromInteger( colour, 2 ), green, GetByteFromInteger( colour, 4 ) ) )
        endif
    endfunction

    function GetObjectColourB takes integer pObject returns integer
        if pObject != 0 then
            return GetByteFromInteger( GetObjectColour( pObject ), 4 )
        endif

        return -1
    endfunction

    function SetObjectColourB takes integer pObject, integer blue returns nothing
        local integer colour = 0

        if pObject != 0 then
            set colour = GetObjectColour( pObject )
            call SetObjectColour( pObject, CreateInteger1( GetByteFromInteger( colour, 1 ), GetByteFromInteger( colour, 2 ), GetByteFromInteger( colour, 3 ), blue ) )
        endif
    endfunction
    
    function SetObjectAnimationByIndex takes integer pObject, integer index returns nothing
        call SetSpriteBaseAnimationByIndex( GetObjectSprite( pObject ), index )
    endfunction

    function SetObjectAnimationByIndexWithRarity takes integer pObject, integer index, integer rarity returns nothing
        call SetSpriteBaseAnimationByIndexWithRarity( GetObjectSprite( pObject ), index, rarity )
    endfunction
    
    function SetObjectModel takes integer pObject, string model returns nothing
        // Works on every handle, even items.
        local integer pData = 0

        if pObject > 0 then
            set pData = ReadRealMemory( pObject ) + 0x88

            if pData > 0 then
                set pData = ReadRealMemory( pData )

                if pData > 0 then
                    call this_call_3( pData, pObject, GetStringAddress( model ), 1 )
                endif
            endif
        endif
    endfunction

    function GetObjectX takes integer pObject returns real
        return GetObjectSpriteFloat( pObject, 0xC0 )
    endfunction

    function SetObjectX takes integer pObject, real x returns nothing
        call SetObjectSpriteFloat( pObject, 0xC0, x )
    endfunction

    function GetObjectY takes integer pObject returns real
        return GetObjectSpriteFloat( pObject, 0xC4 )
    endfunction

    function SetObjectY takes integer pObject, real y returns nothing
        call SetObjectSpriteFloat( pObject, 0xC4, y )
    endfunction

    function GetObjectZ takes integer pObject returns real
        return GetObjectSpriteFloat( pObject, 0xC8 )
    endfunction

    function SetObjectZ takes integer pObject, real z returns nothing
        call SetObjectSpriteFloat( pObject, 0xC8, z )
    endfunction

    function SetObjectPosition takes integer pObject, real x, real y, real z returns nothing
        local integer pSprite = GetObjectSprite( pObject )

        if pSprite != 0 then
            call WriteRealFloat( pSprite + 0xC0, x )
            call WriteRealFloat( pSprite + 0xC4, y )
            call WriteRealFloat( pSprite + 0xC8, z )
        endif
    endfunction

    function GetObjectTimeScale takes integer pObject returns real
        return GetObjectSpriteFloat( pObject, 0x190 )
    endfunction

    function SetObjectTimeScale takes integer pObject, real speed returns nothing
        call SetObjectSpriteFloat( pObject, 0x190, speed )
    endfunction

    function GetObjectScale takes integer pObject returns real
        return GetObjectSpriteFloat( pObject, 0xE8 )
    endfunction

    function SetObjectScale takes integer pObject, real scale returns nothing
        call SetObjectSpriteFloat( pObject, 0xE8, scale )
    endfunction

    // Effect Rotation API Radians
    function GetObjectYawRad takes integer pObject returns real // Z | Yaw | returns Degrees!
        local integer pSprite   = GetObjectSprite( pObject )
        local real r11          = 0.
        local real r21          = 0.
        local real r31          = 0.
        local real yaw          = 0.
        local real pitch        = 0.

        if pSprite != 0 then
            set r11   = ReadRealFloat( pSprite + 0x108 )
            set r21   = ReadRealFloat( pSprite + 0x114 )
            set r31   = ReadRealFloat( pSprite + 0x120 )
            set pitch = -Asin( r31 ) // Atan2( -r31, SquareRoot( Pow( r32, 2 ) + Pow( r33, 2 ) ) )
            set yaw   = -Atan2( r21, r11 )

            if yaw < 0 then
                set yaw = 6.28319 + yaw
            endif
        endif

        return yaw
    endfunction

    function GetObjectPitchRad takes integer pObject returns real // Y | returns Degrees!
        local integer pSprite   = GetObjectSprite( pObject )
        local real r31          = 0.
        local real r32          = 0.
        local real r33          = 0.
        local real pitch        = 0.

        if pSprite != 0 then
            set r31   = ReadRealFloat( pSprite + 0x120 )
            set r32   = ReadRealFloat( pSprite + 0x124 )
            set r33   = ReadRealFloat( pSprite + 0x128 )
            set pitch = -Asin( r31 ) // Atan2( -r31, SquareRoot( Pow( r32, 2 ) + Pow( r33, 2 ) ) )

            if r31 < 0. and r33 > 0. then
                set pitch = pitch
        elseif r31 < 0. and r33 < 0. then
                set pitch = 3.14159 - pitch
        elseif r31 > 0. and r33 < 0. then
                set pitch = 3.14159 - pitch
        elseif r31 > 0. and r33 > 0. then
                set pitch = 6.28319 + pitch
            endif
        endif
        
        return pitch
    endfunction

    function GetObjectRollRad takes integer pObject returns real // X | returns Degrees!
        local integer pSprite   = GetObjectSprite( pObject )
        local real r31          = 0.
        local real r32          = 0.
        local real r33          = 0.
        local real pitch        = 0.
        local real roll         = 0.

        if pSprite != 0 then
            set r31     = ReadRealFloat( pSprite + 0x120 )
            set r32     = ReadRealFloat( pSprite + 0x124 )
            set r33     = ReadRealFloat( pSprite + 0x128 )
            set pitch   = -Asin( r31 )
            set roll    = Atan2( r32 / Cos( pitch ), r33 / Cos( pitch ) )

            if roll < 0. then
                set roll = 6.28319 + roll
            endif
        endif
        
        return roll
    endfunction

    function GetObjectFacingRad takes integer pObject returns real // Z | Yaw | returns Degrees!
        return GetObjectYawRad( pObject )
    endfunction

    function SetObjectSpaceRotationRad takes integer pObject, real yaw, real pitch, real roll returns nothing
        local integer pSprite = GetObjectSprite( pObject )
        local real Sx = Sin( roll )
        local real Sy = Sin( pitch )
        local real Sz = Sin( -yaw )
        local real Cx = Cos( roll )
        local real Cy = Cos( pitch )
        local real Cz = Cos( -yaw )

        if pSprite != 0 then
            call WriteRealFloat( pSprite + 0x108, Cy * Cz )
            call WriteRealFloat( pSprite + 0x10C, -Cy * Sz )
            call WriteRealFloat( pSprite + 0x110, Sy )
            call WriteRealFloat( pSprite + 0x114, Cz * Sx * Sy + Cx * Sz )
            call WriteRealFloat( pSprite + 0x118, Cx * Cz - Sx * Sy * Sz )
            call WriteRealFloat( pSprite + 0x11C, -Cy * Sx )
            call WriteRealFloat( pSprite + 0x120, -Cx * Cz * Sy + Sx * Sz )
            call WriteRealFloat( pSprite + 0x124, Cz * Sx + Cx * Sy * Sz )
            call WriteRealFloat( pSprite + 0x128, Cx * Cy )
        endif
    endfunction

    function SetObjectYawRad takes integer pObject, real angle returns nothing // Z Yaw | In Degrees!
        local integer pSprite   = GetObjectSprite( pObject )
        local real r31          = 0.
        local real r32          = 0.
        local real r33          = 0.
        local real pitch        = 0.
        local real roll         = 0.

        if pSprite != 0 then
            set r31      = ReadRealFloat( pSprite + 0x120 )
            set r32      = ReadRealFloat( pSprite + 0x124 )
            set r33      = ReadRealFloat( pSprite + 0x128 )
            set pitch    = -Asin( r31 ) //Atan2( -r31, SquareRoot( Pow( r32, 2 ) + Pow( r33, 2 ) ) )
            set roll     = Atan2( r32 / Cos( pitch ), r33 / Cos( pitch ) )

            call SetObjectSpaceRotationRad( pObject, angle, pitch, roll )
        endif
    endfunction

    function SetObjectPitchRad takes integer pObject, real angle returns nothing // Y | In Degrees!
        local integer pSprite   = GetObjectSprite( pObject )
        local real r11          = 0.
        local real r21          = 0.
        local real r32          = 0.
        local real r33          = 0.
        local real yaw          = 0.
        local real roll         = 0.

        if pSprite != 0 then
            set r11     = ReadRealFloat( pSprite + 0x108 )
            set r21     = ReadRealFloat( pSprite + 0x114 )
            set r32     = ReadRealFloat( pSprite + 0x124 )
            set r33     = ReadRealFloat( pSprite + 0x128 )
            set yaw     = Atan2( r21 / Cos( angle ), r11 / Cos( angle ) )
            set roll    = Atan2( r32 / Cos( angle ), r33 / Cos( angle ) )

            call SetObjectSpaceRotationRad( pObject, yaw, angle, roll )
        endif
    endfunction

    function SetObjectRollRad takes integer pObject, real angle returns nothing // X | In Degrees!
        local integer pSprite   = GetObjectSprite( pObject )
        local real r11          = 0.
        local real r21          = 0.
        local real r31          = 0.
        local real yaw          = 0.
        local real pitch        = 0.

        if pSprite != 0 then
            set r11     = ReadRealFloat( pSprite + 0x108 )
            set r21     = ReadRealFloat( pSprite + 0x114 )
            set r31     = ReadRealFloat( pSprite + 0x120 )
            set pitch   = -Asin( r31 ) // Atan2( -r31, SquareRoot( Pow( r32, 2 ) + Pow( r33, 2 ) ) )
            set yaw     = Atan2( r21 / Cos( pitch ), r11 / Cos( pitch ) )

            call SetObjectSpaceRotationRad( pObject, yaw, pitch, angle )
        endif
    endfunction

    function SetObjectOrientationRad takes integer pObject, real yaw, real pitch, real roll returns nothing
        if pObject > 0 then
            call SetObjectSpaceRotationRad( pObject, yaw, pitch, roll )
            //call SetObjectRollRad( pObject, roll )
            //call SetObjectPitchRad( pObject, pitch )
            //call SetObjectYawRad( pObject, yaw )
        endif
    endfunction
    //===================================================================
    
    // Effect Rotation API Degrees
    function SetObjectSpaceRotation takes integer pObject, real yaw, real pitch, real roll returns nothing
        call SetObjectSpaceRotationRad( pObject, Deg2Rad( yaw ), Deg2Rad( pitch ), Deg2Rad( roll ) )
    endfunction
    
    function GetObjectYaw takes integer pObject returns real // Z | Yaw | returns Degrees!
        return Rad2Deg( GetObjectYawRad( pObject ) )
    endfunction

    function GetObjectFacing takes integer pObject returns real
        return Rad2Deg( GetObjectFacingRad( pObject ) )
    endfunction
    
    function GetObjectPitch takes integer pObject returns real
        return Rad2Deg( GetObjectPitchRad( pObject ) )
    endfunction

    function GetObjectRoll takes integer pObject returns real
        return Rad2Deg( GetObjectRollRad( pObject ) )
    endfunction

    function SetObjectYaw takes integer pObject, real angle returns nothing
        call SetObjectYawRad( pObject, Deg2Rad( angle ) )
    endfunction

    function SetObjectFacing takes integer pObject, real angle returns nothing
        call SetObjectYawRad( pObject, Deg2Rad( angle ) )
    endfunction

    function SetObjectPitch takes integer pObject, real angle returns nothing
        call SetObjectPitchRad( pObject, Deg2Rad( angle ) )
    endfunction

    function SetObjectRoll takes integer pObject, real angle returns nothing
        call SetObjectRollRad( pObject, Deg2Rad( angle ) )
    endfunction

    function SetObjectOrientation takes integer pObject, real yaw, real pitch, real roll returns nothing
        call SetObjectOrientationRad( pObject, Deg2Rad( yaw ), Deg2Rad( pitch ), Deg2Rad( roll ) )
    endfunction
    //===================================================================

    function SetObjectScaleEx takes integer pObject, real x, real y, real z returns nothing
        local integer pSprite = GetObjectSprite( pObject )

        if pSprite != 0 then
            call WriteRealFloat( pSprite + 0x108, x )
            call WriteRealFloat( pSprite + 0x118, y )
            call WriteRealFloat( pSprite + 0x128, z )
        endif
    endfunction

    function ResetObjectMatrix takes integer pObject returns nothing
        local integer pSprite = GetObjectSprite( pObject )

        if pSprite != 0 then
            call WriteRealFloat( pSprite + 0x108, 1. )
            call WriteRealFloat( pSprite + 0x10C, 0. )
            call WriteRealFloat( pSprite + 0x110, 0. )
            call WriteRealFloat( pSprite + 0x114, 0. )
            call WriteRealFloat( pSprite + 0x118, 1. )
            call WriteRealFloat( pSprite + 0x11C, 0. )
            call WriteRealFloat( pSprite + 0x120, 0. )
            call WriteRealFloat( pSprite + 0x124, 0. )
            call WriteRealFloat( pSprite + 0x128, 1. )
        endif
    endfunction

    function Init_APIMemoryObjectData takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pSetObjectAlpha     = pGameDLL + 0x4D3D50
                set pSetObjectAnimation = pGameDLL + 0x4D8700
        elseif PatchVersion == "1.26a" then
                set pSetObjectAlpha     = pGameDLL + 0x4D3250
                set pSetObjectAnimation = pGameDLL + 0x4D7C00
        elseif PatchVersion == "1.27a" then
                set pSetObjectAlpha     = pGameDLL + 0x186FA0 // (*(int (__stdcall **)(int))(*(_DWORD *)a1 + 52))(a2);
                set pSetObjectAnimation = pGameDLL + 0x186820 // v20 = *v6 & 0x1000000;
        elseif PatchVersion == "1.27b" then
                set pSetObjectAlpha     = pGameDLL + 0x1A4CC0
                set pSetObjectAnimation = pGameDLL + 0x1A4540
        elseif PatchVersion == "1.28f" then
                set pSetObjectAlpha     = pGameDLL + 0x1D7550
                set pSetObjectAnimation = pGameDLL + 0x1D6DD0
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackCObjectAPI takes nothing returns nothing
    //set gg_trg_MemHackCObjectAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: APIMemoryGameUI
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library APIMemoryWC3GameUI
    globals
        integer pGameUI                     = 0
        integer pWorldFrameWar3UI           = 0
        integer pGetGameUI                  = 0
        integer pUpdateUI                   = 0
        integer pTextureLoadImageAnyExt     = 0
        integer pTextureUnloadImage         = 0
    endglobals

    function GetGameUI takes integer bInit, integer bRelease returns integer
        return fast_call_2( pGetGameUI, bInit, bRelease )
    endfunction

    function GetRootFrame takes nothing returns integer
        if pGameUI > 0 then
            return pGameUI + 0xB4 //180
        endif

        return 0
    endfunction

    // Frame Game API Engine
    function GetUIWorldFrameWar3 takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x3BC ) // if ReadRealMemory( GetUIWorldFrameWar3 + 0x1AC ) == 9 ???
        endif

        return 0
    endfunction

    function GetUIMinimap takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x3C0 )
        endif

        return 0
    endfunction

    function GetUIInfoBar takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x3C4 )
        endif

        return 0
    endfunction

    function GetUICommandBar takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x3C8 )
        endif

        return 0
    endfunction

    function GetUIResourceBarFrame takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x3CC )
        endif

        return 0
    endfunction

    function GetUIUpperButtonBarFrame takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x3D0 )
        endif

        return 0
    endfunction

    function GetUIUnknown1 takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x3D4 ) // ?
        endif

        return 0
    endfunction

    function GetUIClickableBlock takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x3D8 )
        endif

        return 0
    endfunction

    function GetUIHeroBar takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x3DC )
        endif

        return 0
    endfunction

    function GetUIPeonBar takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x3E0 )
        endif

        return 0
    endfunction

    function GetUIMessage takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x3E4 )
        endif

        return 0
    endfunction

    function GetUIUnitMessage takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x3E8 )
        endif

        return 0
    endfunction

    function GetUIChatMessage takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x3EC )
        endif

        return 0
    endfunction

    function GetUITopMessage takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x3F0 )
        endif

        return 0
    endfunction

    function GetUIPortrait takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x3F4 )
        endif

        return 0
    endfunction

    function GetUITimeOfDayIndicator takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x3F8 )
        endif

        return 0
    endfunction

    function GetUIChatEditBar takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x3FC )
        endif

        return 0
    endfunction

    function GetUICinematicPanel takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x400 )
        endif

        return 0
    endfunction

    function GetUIUnknown2 takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x404 ) // ?
        endif

        return 0
    endfunction

    function GetUIMinimapButton1 takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x408 )
        endif

        return 0
    endfunction

    function GetUIMinimapButton2 takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x40C )
        endif

        return 0
    endfunction

    function GetUIMinimapButton3 takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x410 )
        endif

        return 0
    endfunction

    function GetUIMinimapButton4 takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x414 )
        endif

        return 0
    endfunction

    function GetUIMinimapButton5 takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x418 )
        endif

        return 0
    endfunction

    function GetUIFrameB takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x41C )
        endif

        return 0
    endfunction

    function GetUIMouseBorders takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x420 )
        endif

        return 0
    endfunction

    function GetUIFrameA takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x424 )
        endif

        return 0
    endfunction

    function GetUISimpleConsole takes nothing returns integer
        if pGameUI > 0 then
            return ReadRealMemory( pGameUI + 0x428 )
        endif

        return 0
    endfunction

    function GetPanelButton takes integer pFrame, integer row, integer column returns integer
        if pFrame > 0 then
            return ReadRealMemory( ReadRealMemory( 0x10 * row + ReadRealMemory( pFrame + 0x154 ) + 0x8 ) + 0x4 * column )
        endif

        return 0
    endfunction

    function GetMinimapButton takes integer id returns integer
        local integer pMiniMap = GetUIMinimap( )

        if pMiniMap > 0 then
            if id >= 0 and id <= 4 then 
                return ReadRealMemory( pMiniMap + id * 4 )
            endif
        endif

        return 0
    endfunction

    function GetUpperButtonBarButton takes integer id returns integer
        local integer pOff              = 0
        local integer pUpperButtonBar   = GetUIUpperButtonBarFrame( )

        if pUpperButtonBar > 0 then
            if id == 0 then
                set pOff = 0x138
            elseif id == 1 then
                set pOff = 0x130
            elseif id == 2 then
                set pOff = 0x134
            elseif id == 3 then
                set pOff = 0x160
            endif

            if pOff > 0 then
                return ReadRealMemory( pUpperButtonBar + pOff )
            endif
        endif

        return 0
    endfunction

    function GetSkillBarButtonXY takes integer row, integer column returns integer
        local integer pCommandBar = GetUICommandBar( )

        if pCommandBar > 0 then
            if row >= 0 and row <= 2 and column >= 0 and column <= 3 then
                return GetPanelButton( pCommandBar, row, column )
            endif
        endif

        return 0
    endfunction
	
    function GetSkillBarButton takes integer id returns integer
        local integer pUIBar = GetUICommandBar( )
        local integer pSkillBar = 0

        if pUIBar > 0 then
            if id >= 0 and id <= 11 then
                set pSkillBar = ReadRealMemory( pUIBar + 0x154 )

                if pSkillBar > 0 then
                    return ReadRealMemory( ReadRealMemory( pSkillBar + 0x8 ) ) + id * 0x1C0
                endif
            endif
        endif

        return 0
    endfunction

    function GetItemBarButton takes integer id returns integer
        local integer pInfoBar = GetUIInfoBar( )
        local integer pItemBar = 0

        if pInfoBar > 0 then
            if id >= 0 and id <= 5 then
                set pItemBar = ReadRealMemory( pInfoBar + 0x148 )

                if pItemBar > 0 then
                    //return ReadRealMemory( ReadRealMemory( pItemBar + 0x130 ) + id * 0x8 + 0x4 )
                    return ReadRealMemory( ReadRealMemory( pItemBar + 0x130 ) + 0x4 ) + id * 0x1C0
                endif
            endif
        endif

        return 0
    endfunction
    
    function GetCommandBarButton takes integer id returns integer
        if id >= 0 and id <= 11 then
            return GetSkillBarButton( id )
    elseif id >= 12 and id <= 17 then
            return GetSkillBarButton( id - 12 )
        endif

        return 0
    endfunction

    function GetHeroBarButton takes integer id returns integer
        local integer pHeroBar = GetUIHeroBar( )

        if pHeroBar > 0 then
            if id >= 0 and id <= 6 then
                return GetPanelButton( pHeroBar, id, 0 )
            endif
        endif

        return 0
    endfunction
    
    function GetHeroBarHealthBar takes integer id returns integer
        local integer pHeroBar = GetHeroBarButton( id )
        
        if pHeroBar > 0 then
            return ReadRealMemory( pHeroBar + 0x1CC )
        endif

        return 0
    endfunction

    function GetHeroBarManaBar takes integer id returns integer
        local integer pHeroBar = GetHeroBarButton( id )
        
        if pHeroBar > 0 then
            return ReadRealMemory( pHeroBar + 0x1D0 )
        endif

        return 0
    endfunction

    function UpdateGameUI takes nothing returns nothing
        if pUpdateUI > 0 then
            call this_call_1( pUpdateUI, 0 )
        endif
    endfunction

    function GetFrameType takes integer pFrame returns integer
        if pFrame > 0 then
            return LoadInteger( MemHackTable, StringHash( "FrameTypeTable" ), ReadRealMemory( pFrame ) )
        endif

        return 0
    endfunction

    function SetWar3MapMap takes string minimap returns integer
        local integer pMiniMap      = GetUIMinimap( )
        local integer pTexture      = 0
        local integer pOldTexture   = 0

        if pMiniMap > 0 then
            if minimap != "" then
                if pMiniMap > 0 then
                    call WriteRealMemory( pReservedIntArg1, 0 )
                    call WriteRealMemory( pReservedIntArg2, 0 )
                    set pTexture = fast_call_3( pTextureLoadImageAnyExt, GetStringAddress( minimap ), pReservedIntArg1, pReservedIntArg2 )

                    if pTexture > 0 then
                        set pOldTexture = ReadRealMemory( pMiniMap + 0x17C ) // if 1.29+ then 0x188

                        if pOldTexture > 0 then
                            call WriteRealMemory( pMiniMap + 0x17C, pTexture )
                            return this_call_1( pTextureUnloadImage, pOldTexture )
                        else
                            call this_call_1( pTextureUnloadImage, pTexture )
                        endif
                    endif
                endif
            endif
        endif

        return 0
    endfunction

    function Init_APIMemoryGameUI takes nothing returns nothing
        if PatchVersion != "" then
           if PatchVersion == "1.24e" then
                set pGetGameUI                  = pGameDLL + 0x301250
                set pUpdateUI                   = pGameDLL + 0x333240
                set pTextureLoadImageAnyExt     = pGameDLL + 0x7283A0
                set pTextureUnloadImage         = pGameDLL + 0x4DECB0
                set pWorldFrameWar3UI           = pGameDLL + 0x9536A8
        elseif PatchVersion == "1.26a" then
                set pGetGameUI                  = pGameDLL + 0x300710
                set pUpdateUI                   = pGameDLL + 0x332700
                set pTextureLoadImageAnyExt     = pGameDLL + 0x727C00
                set pTextureUnloadImage         = pGameDLL + 0x4DE1B0
                set pWorldFrameWar3UI           = pGameDLL + 0x941550
        elseif PatchVersion == "1.27a" then
                set pGetGameUI                  = pGameDLL + 0x34F3A0
                set pUpdateUI                   = pGameDLL + 0x3599F0
                set pTextureLoadImageAnyExt     = pGameDLL + 0x6FEA00 // ((int)"war3mapMap.tga", &
                set pTextureUnloadImage         = pGameDLL + 0x197AB0 // Storm_403(this, "Texture.cpp", 965, 0);
                set pWorldFrameWar3UI           = pGameDLL + 0x98DCD0 // *CWorldFrameWar3::`vftable`;
        elseif PatchVersion == "1.27b" then
                set pGetGameUI                  = pGameDLL + 0x36CB20
                set pUpdateUI                   = pGameDLL + 0x377190
                set pTextureLoadImageAnyExt     = pGameDLL + 0x71C150
                set pTextureUnloadImage         = pGameDLL + 0x1B57E0
                set pWorldFrameWar3UI           = pGameDLL + 0xABB66C
        elseif PatchVersion == "1.28f" then
                set pGetGameUI                  = pGameDLL + 0x3A0B70
                set pUpdateUI                   = pGameDLL + 0x3AB2A0
                set pTextureLoadImageAnyExt     = pGameDLL + 0x750320
                set pTextureUnloadImage         = pGameDLL + 0x1E8060 // Storm_403(this, "Texture.cpp", 901,
                set pWorldFrameWar3UI           = pGameDLL + 0xAAC008
            endif

            if pGetGameUI > 0 then
                set pGameUI = GetGameUI( 0, 0 )
            endif
        endif
    endfunction
endlibrary

function InitTrig_APIMemoryGameUI takes nothing returns nothing
    //set gg_trg_APIMemoryGameUI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: APIMemoryGameUIButton
//===========================================================================
//TESH.scrollpos=30
//TESH.alwaysfold=0
//! nocjass
library APIMemoryWC3GameUIButton
    globals
        
    endglobals

    function IsCommandButton takes integer pButton returns boolean
        return GetFrameType( pButton ) == 4
    endfunction

    function GetButtonData takes integer pCommandButton returns integer
        if IsCommandButton( pCommandButton ) then
            return ReadRealMemory( pCommandButton + 0x190 )
        endif

        return 0
    endfunction

    function GetButtonGoldCost takes integer pCommandButton returns integer
        local integer pButton = GetButtonData( pCommandButton )

        if pButton > 0 then
            return ReadRealMemory( pButton + 0x58C )
        endif

        return -1
    endfunction

    function GetButtonLumberCost takes integer pCommandButton returns integer
        local integer pButton = GetButtonData( pCommandButton )

        if pButton > 0 then
            return ReadRealMemory( pButton + 0x590 )
        endif

        return -1
    endfunction

    function GetButtonManaCost takes integer pCommandButton returns integer
        local integer pButton = GetButtonData( pCommandButton )

        if pButton > 0 then
            return ReadRealMemory( pButton + 0x594 )
        endif

        return -1
    endfunction

    function GetButtonCooldown takes integer pCommandButton returns real
        local integer pAbil     = 0
        local integer pAbilId   = 0
        local integer pOrderId  = 0
        local integer goldcost  = 0
        local integer pAbilVal2 = 0
        local integer pButton   = 0
        local real prAbilVal1   = 0.
        local real prAbilVal2   = 0.

        if IsCommandButton( pCommandButton ) then
            set pButton = ReadRealMemory( pCommandButton + 0x190 )

            if pButton > 0 then
                set pAbil    = ReadRealMemory( pButton + 0x6D4 )
                set pAbilId  = ReadRealMemory( pButton + 0x4   )
                set pOrderId = ReadRealMemory( pButton + 0x8   )
                set goldcost = ReadRealMemory( pButton + 0x58C )

                //call DisplayTextToPlayer( GetLocalPlayer( ), 0, 0, "pButton = " + IntToHex( pButton ) )
                //call DisplayTextToPlayer( GetLocalPlayer( ), 0, 0, "pButton + 0x6D4 = " + IntToHex( pAbil ) )

                if pAbil > 0 and pAbilId != 'AHer' and pAbilId != 'Amai' and pAbilId != 'Asei' and pAbilId != 'Asel' then //  and goldcost == 0
                    set pAbil = ReadRealMemory( pAbil + 0xDC )
                    //call DisplayTextToPlayer( GetLocalPlayer( ), 0, 0, "pAbil + 0xDC = " + IntToHex( pAbil ) )

                    if pAbil > 0 then
                        set pAbilVal2 = ReadRealMemory( pAbil + 0x0C )
                        //call DisplayTextToPlayer( GetLocalPlayer( ), 0, 0, "ReadRealMemory( pAbil + 0x0C ) = " + IntToHex( pAbilVal2 ) )

                        if pAbilVal2 > 0 then
                            set prAbilVal1 = GetRealFromMemory( ReadRealMemory( pAbil + 0x04 ) )
                            set prAbilVal2 = GetRealFromMemory( ReadRealMemory( pAbilVal2 + 0x40 ) )
                            
                            //call DisplayTextToPlayer( GetLocalPlayer( ), 0, 0, "prAbilVal1 = " + R2S( pAbilVal2 ) )
                            //call DisplayTextToPlayer( GetLocalPlayer( ), 0, 0, "prAbilVal2 = " + R2S( pAbilVal2 ) )
                            return prAbilVal1 - prAbilVal2
                        endif
                    endif
                endif
            endif
        endif

        return 0.
    endfunction

    function IsButtonOnCooldown takes integer pCommandButton returns boolean
        return GetButtonCooldown( pCommandButton ) > 0
    endfunction

    function AddFrameType takes string name, integer vtype, integer pVtable, integer pVTableObj returns nothing
        local integer hid = StringHash( "FrameTypeTable" )

        call SaveStr(       MemHackTable, hid, pGameDLL + pVtable,     name  )
        call SaveStr(       MemHackTable, hid, pGameDLL + pVTableObj, name  )
        call SaveInteger( MemHackTable, hid, pGameDLL + pVtable,     vtype )
        call SaveInteger( MemHackTable, hid, pGameDLL + pVTableObj, vtype )
    endfunction

    function Init_APIMemoryGameUIButton takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                if true then // Generation of Frame Type Table
                    call AddFrameType( "CBackdropFrame",                1, 0x98109C, 0x981074 )
                    call AddFrameType( "CButtonFrame",                  2, 0x9813A4, 0x98137C )
                    call AddFrameType( "CChatMode",                     3, 0x94CA1C, 0x000000 )
                    call AddFrameType( "CCommandButton",                4, 0x94EA04, 0x000000 )
                    call AddFrameType( "CCursorFrame",                  5, 0x9822E4, 0x9822B8 )
                    call AddFrameType( "CEditBox",                      6, 0x980994, 0x980968 )
                    call AddFrameType( "CFrame",                        7, 0x97FB5C, 0x97FB34 )
                    call AddFrameType( "CFloatingFrame",                8, 0x98175C, 0x981730 )
                    call AddFrameType( "CGameUI",                       9, 0x94847C, 0x948454 )
                    call AddFrameType( "CHeroBarButton",               10, 0x951A34, 0x951A14 )
                    call AddFrameType( "CHighlightFrame",              11, 0x98161C, 0x9815F4 )
                    call AddFrameType( "CLayoutFrame",                 12, 0x97FAF0, 0x000000 )
                    call AddFrameType( "CMessageFrame",                13, 0x98150C, 0x9814E4 )
                    call AddFrameType( "CMinimap",                     14, 0x952184, 0x95215C )
                    call AddFrameType( "CModelFrame",                  15, 0x981254, 0x98122C )
                    call AddFrameType( "CPortraitButton",              16, 0x95233C, 0x952314 )
                    call AddFrameType( "CScreenFrame",                 17, 0x97FD24, 0x97FCFC )
                    call AddFrameType( "CSimpleButton",                18, 0x97F934, 0x000000 )
                    call AddFrameType( "CSimpleFontString",            19, 0x9800AC, 0x000000 )
                    call AddFrameType( "CSimpleFrame",                 20, 0x97FC5C, 0x000000 )
                    call AddFrameType( "CSimpleGlueFrame",             21, 0x980AAC, 0x000000 )
                    call AddFrameType( "CUknown_1",                    22, 0x000000, 0x000000 )
                    call AddFrameType( "CSimpleMessageFrame",          23, 0x97FA2C, 0x000000 )
                    call AddFrameType( "CSlider",                      24, 0x980F1C, 0x980EF4 )
                    call AddFrameType( "CSpriteFrame",                 25, 0x98022C, 0x980200 )
                    call AddFrameType( "CStatBar",                     26, 0x95075C, 0x000000 )
                    call AddFrameType( "CTextArea",                    27, 0x980C7C, 0x980C54 )
                    call AddFrameType( "CTextButtonFrame",             28, 0x980DBC, 0x980D90 )
                    call AddFrameType( "CTextFrame",                   29, 0x98065C, 0x980630 )
                    call AddFrameType( "CUberToolTipWar3",             30, 0x9517E4, 0x000000 )
                    call AddFrameType( "CWorldFrameWar3",              31, 0x9536D4, 0x9536A8 )
                    call AddFrameType( "CGlueButtonWar3",              32, 0x96EA84, 0x96EA58 )
                    call AddFrameType( "CGlueTextButtonWar3",          33, 0x96C164, 0x96C138 )
                    call AddFrameType( "CGlueCheckBoxWar3",            34, 0x96E944, 0x96E918 )
                    call AddFrameType( "CGluePopupMenuWar3",           35, 0x96BFDC, 0x96BFB4 )
                    call AddFrameType( "CGlueEditBoxWar3",             36, 0x96EBC4, 0x96EB98 )
                    call AddFrameType( "CSlashChatBox",                37, 0x96FC44, 0x96FC1C )
                    call AddFrameType( "CTimerTextFrame",              38, 0x96C6BC, 0x96C690 )
                    call AddFrameType( "CSimpleStatusBar",             39, 0x980134, 0x000000 )
                    call AddFrameType( "CStatusBar",                   40, 0x981F0C, 0x981EE4 )
                    call AddFrameType( "CUpperButtonBar",              41, 0x94E544, 0x94E524 )
                    call AddFrameType( "CResourceBar",                 42, 0x94F38C, 0x000000 )
                    call AddFrameType( "CSimpleConsole",               43, 0x94DE8C, 0x000000 )
                    call AddFrameType( "CPeonBar",                     44, 0x951D64, 0x951D48 )
                    call AddFrameType( "CHeroBar",                     45, 0x951ACC, 0x951AB0 )
                    call AddFrameType( "CTimeOfDayIndicator",          46, 0x951FBC, 0x951F90 )
                    call AddFrameType( "CInfoBar",                     47, 0x9527C4, 0x000000 )
                    call AddFrameType( "CTimeCover",                   48, 0x94E1B4, 0x94E188 )
                    call AddFrameType( "CProgressIndicator",           49, 0x94A4AC, 0x000000 )
                    call AddFrameType( "CHeroLevelBar",                50, 0x951B7C, 0x000000 )
                    call AddFrameType( "CBuildTimeIndicator",          51, 0x94F7E4, 0x000000 )
                    call AddFrameType( "CInfoPanelDestructableDetail", 52, 0x94EFB4, 0x000000 )
                    call AddFrameType( "CInfoPanelItemDetail",         53, 0x94D624, 0x000000 )
                    call AddFrameType( "CInfoPanelIconAlly",           54, 0x94D4D4, 0x000000 )
                    call AddFrameType( "CInfoPanelIconHero",           55, 0x94D3E4, 0x000000 )
                    call AddFrameType( "CInfoPanelIconGold",           56, 0x94D36C, 0x000000 )
                    call AddFrameType( "CInfoPanelIconFood",           57, 0x94D2F4, 0x000000 )
                    call AddFrameType( "CInfoPanelIconRank",           58, 0x94D27C, 0x000000 )
                    call AddFrameType( "CInfoPanelIconArmor",          59, 0x94D204, 0x000000 )
                    call AddFrameType( "CInfoPanelIconDamage",         60, 0x94D18C, 0x000000 )
                    call AddFrameType( "CInfoPanelCargoDetail",        61, 0x94F0EC, 0x000000 )
                    call AddFrameType( "CInfoPanelBuildingDetail",     62, 0x94FFFC, 0x000000 )
                    call AddFrameType( "CInfoPanelUnitDetail",         63, 0x94F06C, 0x000000 )
                    call AddFrameType( "CSimpleTexture",               64, 0x9800E8, 0x000000 )
                endif
            elseif PatchVersion == "1.26a" then
                if true then // Generation of Frame Type Table
                    call AddFrameType( "CBackdropFrame",                1, 0x96F3F4, 0x96F3CC )
                    call AddFrameType( "CButtonFrame",                  2, 0x96F6FC, 0x96F6D4 )
                    call AddFrameType( "CChatMode",                     3, 0x93A8BC, 0x000000 )
                    call AddFrameType( "CCommandButton",                4, 0x93EBC4, 0x000000 )
                    call AddFrameType( "CCursorFrame",                  5, 0x97063C, 0x970610 )
                    call AddFrameType( "CEditBox",                      6, 0x96ECEC, 0x96ECC0 )
                    call AddFrameType( "CFrame",                        7, 0x96DEB4, 0x96DE8C )
                    call AddFrameType( "CFloatingFrame",                8, 0x96FAB4, 0x96FA88 )
                    call AddFrameType( "CGameUI",                       9, 0x93631C, 0x9362F4 )
                    call AddFrameType( "CHeroBarButton",               10, 0x93F8DC, 0x93F8BC )
                    call AddFrameType( "CHighlightFrame",              11, 0x96F974, 0x96F94C )
                    call AddFrameType( "CLayoutFrame",                 12, 0x96DE48, 0x000000 )
                    call AddFrameType( "CMessageFrame",                13, 0x96F864, 0x96F83C )
                    call AddFrameType( "CMinimap",                     14, 0x94002C, 0x940004 )
                    call AddFrameType( "CModelFrame",                  15, 0x96F5AC, 0x96F584 )
                    call AddFrameType( "CPortraitButton",              16, 0x9401E4, 0x9401BC )
                    call AddFrameType( "CScreenFrame",                 17, 0x96E07C, 0x96E054 )
                    call AddFrameType( "CSimpleButton",                18, 0x96DC8C, 0x000000 )
                    call AddFrameType( "CSimpleFontString",            19, 0x96E404, 0x000000 )
                    call AddFrameType( "CSimpleFrame",                 20, 0x96DFB4, 0x000000 )
                    call AddFrameType( "CSimpleGlueFrame",             21, 0x96EE04, 0x000000 )
                    call AddFrameType( "CUknown_1",                    22, 0x000000, 0x000000 )
                    call AddFrameType( "CSimpleMessageFrame",          23, 0x96DD84, 0x000000 )
                    call AddFrameType( "CSlider",                      24, 0x96F274, 0x96F24C )
                    call AddFrameType( "CSpriteFrame",                 25, 0x96E584, 0x96E558 )
                    call AddFrameType( "CStatBar",                     26, 0x93E604, 0x000000 )
                    call AddFrameType( "CTextArea",                    27, 0x96EFD4, 0x96EFAC )
                    call AddFrameType( "CTextButtonFrame",             28, 0x96F114, 0x96F0E8 )
                    call AddFrameType( "CTextFrame",                   29, 0x96E9B4, 0x96E988 )
                    call AddFrameType( "CUberToolTipWar3",             30, 0x93F68C, 0x000000 )
                    call AddFrameType( "CWorldFrameWar3",              31, 0x94157C, 0x941550 )
                    call AddFrameType( "CGlueButtonWar3",              32, 0x95C92C, 0x95C900 )
                    call AddFrameType( "CGlueTextButtonWar3",          33, 0x95A00C, 0x959FE0 )
                    call AddFrameType( "CGlueCheckBoxWar3",            34, 0x95C7EC, 0x95C7C0 )
                    call AddFrameType( "CGluePopupMenuWar3",           35, 0x959E84, 0x959E5C )
                    call AddFrameType( "CGlueEditBoxWar3",             36, 0x95CA6C, 0x95CA40 )
                    call AddFrameType( "CSlashChatBox",                37, 0x95DAEC, 0x95DAC4 )
                    call AddFrameType( "CTimerTextFrame",              38, 0x95A564, 0x95A538 )
                    call AddFrameType( "CSimpleStatusBar",             39, 0x96E48C, 0x000000 )
                    call AddFrameType( "CStatusBar",                   40, 0x970264, 0x97023C )
                    call AddFrameType( "CUpperButtonBar",              41, 0x93C3E4, 0x93C3C4 )
                    call AddFrameType( "CResourceBar",                 42, 0x93D22C, 0x000000 )
                    call AddFrameType( "CSimpleConsole",               43, 0x93BD2C, 0x000000 )
                    call AddFrameType( "CPeonBar",                     44, 0x93FC0C, 0x93FBF0 )
                    call AddFrameType( "CHeroBar",                     45, 0x93F974, 0x93F958 )
                    call AddFrameType( "CTimeOfDayIndicator",          46, 0x93FE64, 0x93FE38 )
                    call AddFrameType( "CInfoBar",                     47, 0x94066C, 0x000000 )
                    call AddFrameType( "CTimeCover",                   48, 0x93C054, 0x93C028 )
                    call AddFrameType( "CProgressIndicator",           49, 0x93834C, 0x000000 )
                    call AddFrameType( "CHeroLevelBar",                50, 0x93FA24, 0x000000 )
                    call AddFrameType( "CBuildTimeIndicator",          51, 0x93D684, 0x000000 )
                    call AddFrameType( "CInfoPanelDestructableDetail", 52, 0x93CE54, 0x000000 )
                    call AddFrameType( "CInfoPanelItemDetail",         53, 0x93B4C4, 0x000000 )
                    call AddFrameType( "CInfoPanelIconAlly",           54, 0x93B374, 0x000000 )
                    call AddFrameType( "CInfoPanelIconHero",           55, 0x93B284, 0x000000 )
                    call AddFrameType( "CInfoPanelIconGold",           56, 0x93B20C, 0x000000 )
                    call AddFrameType( "CInfoPanelIconFood",           57, 0x93B194, 0x000000 )
                    call AddFrameType( "CInfoPanelIconRank",           58, 0x93B11C, 0x000000 )
                    call AddFrameType( "CInfoPanelIconArmor",          59, 0x93B0A4, 0x000000 )
                    call AddFrameType( "CInfoPanelIconDamage",         60, 0x93B02C, 0x000000 )
                    call AddFrameType( "CInfoPanelCargoDetail",        61, 0x93CF8C, 0x000000 )
                    call AddFrameType( "CInfoPanelBuildingDetail",     62, 0x93DE9C, 0x000000 )
                    call AddFrameType( "CInfoPanelUnitDetail",         63, 0x93CF0C, 0x000000 )
                    call AddFrameType( "CSimpleTexture",               64, 0x96E440, 0x000000 )
                endif
        elseif PatchVersion == "1.27a" then
                if true then // Generation of Frame Type Table
                    call AddFrameType( "CBackdropFrame",                1, 0x95AC3C, 0x95AD38 )
                    call AddFrameType( "CButtonFrame",                  2, 0x95B318, 0x95B42C )
                    call AddFrameType( "CChatMode",                     3, 0x98FB4C, 0x000000 )
                    call AddFrameType( "CCommandButton",                4, 0x98F6A8, 0x000000 )
                    call AddFrameType( "CCursorFrame",                  5, 0x95D0BC, 0x95D1AC )
                    call AddFrameType( "CEditBox",                      6, 0x95BCBC, 0x95BDD4 )
                    call AddFrameType( "CFrame",                        7, 0x95A760, 0x95A848 )
                    call AddFrameType( "CFloatingFrame",                8, 0x95D1D4, 0x95D2BC )
                    call AddFrameType( "CGameUI",                       9, 0x98C3EC, 0x98C4D4 )
                    call AddFrameType( "CHeroBarButton",               10, 0x990E44, 0x990EBC )
                    call AddFrameType( "CHighlightFrame",              11, 0x95ADD4, 0x95AEBC )
                    call AddFrameType( "CLayoutFrame",                 12, 0x95CB54, 0x000000 )
                    call AddFrameType( "CMessageFrame",                13, 0x95AF28, 0x95B010 )
                    call AddFrameType( "CMinimap",                     14, 0x99244C, 0x992538 )
                    call AddFrameType( "CModelFrame",                  15, 0x95AAE4, 0x95ABE0 )
                    call AddFrameType( "CPortraitButton",              16, 0x9922FC, 0x992424 )
                    call AddFrameType( "CScreenFrame",                 17, 0x95D2E4, 0x95D3CC )
                    call AddFrameType( "CSimpleButton",                18, 0x95C9A4, 0x000000 )
                    call AddFrameType( "CSimpleFontString",            19, 0x95CE00, 0x000000 )
                    call AddFrameType( "CSimpleFrame",                 20, 0x95C8A4, 0x000000 )
                    call AddFrameType( "CSimpleGlueFrame",             21, 0x95CE64, 0x000000 )
                    call AddFrameType( "CUknown_1",                    22, 0x000000, 0x000000 )
                    call AddFrameType( "CSimpleMessageFrame",          23, 0x95CF38, 0x000000 )
                    call AddFrameType( "CSlider",                      24, 0x95B468, 0x95B584 )
                    call AddFrameType( "CSpriteFrame",                 25, 0x95A8A4, 0x95A994 )
                    call AddFrameType( "CStatBar",                     26, 0x98F52C, 0x000000 )
                    call AddFrameType( "CTextArea",                    27, 0x95C610, 0x95C724 )
                    call AddFrameType( "CTextButtonFrame",             28, 0x95BF60, 0x95C074 )
                    call AddFrameType( "CTextFrame",                   29, 0x95B050, 0x95B164 )
                    call AddFrameType( "CUberToolTipWar3",             30, 0x98F364, 0x000000 )
                    call AddFrameType( "CWorldFrameWar3",              31, 0x98DCD0, 0x98DDB8 )
                    call AddFrameType( "CGlueButtonWar3",              32, 0x975D40, 0x975E54 )
                    call AddFrameType( "CGlueTextButtonWar3",          33, 0x975E7C, 0x975F90 )
                    call AddFrameType( "CGlueCheckBoxWar3",            34, 0x977A44, 0x977B58 )
                    call AddFrameType( "CGluePopupMenuWar3",           35, 0x975FB8, 0x9760CC )
                    call AddFrameType( "CGlueEditBoxWar3",             36, 0x9760F4, 0x97620C )
                    call AddFrameType( "CSlashChatBox",                37, 0x977278, 0x977390 )
                    call AddFrameType( "CTimerTextFrame",              38, 0x979FBC, 0x97A0D0 )
                    call AddFrameType( "CSimpleStatusBar",             39, 0x95CABC, 0x000000 )
                    call AddFrameType( "CStatusBar",                   40, 0x95B1B0, 0x95B2B8 )
                    call AddFrameType( "CUpperButtonBar",              41, 0x98EF64, 0x98EFD4 )
                    call AddFrameType( "CResourceBar",                 42, 0x993E54, 0x000000 )
                    call AddFrameType( "CSimpleConsole",               43, 0x992D68, 0x000000 )
                    call AddFrameType( "CPeonBar",                     44, 0x992C60, 0x992CD4 )
                    call AddFrameType( "CHeroBar",                     45, 0x990ED8, 0x990F4C )
                    call AddFrameType( "CTimeOfDayIndicator",          46, 0x994620, 0x994710 )
                    call AddFrameType( "CInfoBar",                     47, 0x99197C, 0x000000 )
                    call AddFrameType( "CTimeCover",                   48, 0x994510, 0x9945F8 )
                    call AddFrameType( "CProgressIndicator",           49, 0x98B0E4, 0x000000 )
                    call AddFrameType( "CHeroLevelBar",                50, 0x991010, 0x000000 )
                    call AddFrameType( "CBuildTimeIndicator",          51, 0x98F438, 0x000000 )
                    call AddFrameType( "CInfoPanelDestructableDetail", 52, 0x991778, 0x000000 )
                    call AddFrameType( "CInfoPanelItemDetail",         53, 0x9916F8, 0x000000 )
                    call AddFrameType( "CInfoPanelIconAlly",           54, 0x991584, 0x000000 )
                    call AddFrameType( "CInfoPanelIconHero",           55, 0x991510, 0x000000 )
                    call AddFrameType( "CInfoPanelIconGold",           56, 0x99149C, 0x000000 )
                    call AddFrameType( "CInfoPanelIconFood",           57, 0x991428, 0x000000 )
                    call AddFrameType( "CInfoPanelIconRank",           58, 0x9913B4, 0x000000 )
                    call AddFrameType( "CInfoPanelIconArmor",          59, 0x991340, 0x000000 )
                    call AddFrameType( "CInfoPanelIconDamage",         60, 0x9912CC, 0x000000 )
                    call AddFrameType( "CInfoPanelCargoDetail",        61, 0x991678, 0x000000 )
                    call AddFrameType( "CInfoPanelBuildingDetail",     62, 0x99116C, 0x000000 )
                    call AddFrameType( "CInfoPanelUnitDetail",         63, 0x9915F8, 0x000000 )
                    call AddFrameType( "CSimpleTexture",               64, 0x95CDC4, 0x000000 )
                endif
        elseif PatchVersion == "1.27b" then
                if true then // Generation of Frame Type Table
                    call AddFrameType( "CBackdropFrame",                1, 0xA8B5AC, 0xA8B6A8 )
                    call AddFrameType( "CButtonFrame",                  2, 0xA8BC88, 0xA8BD9C )
                    call AddFrameType( "CChatMode",                     3, 0xABD488, 0x000000 )
                    call AddFrameType( "CCommandButton",                4, 0xABCFF4, 0x000000 )
                    call AddFrameType( "CCursorFrame",                  5, 0xA8DA14, 0xA8DB04 )
                    call AddFrameType( "CEditBox",                      6, 0xA8C62C, 0xA8C744 )
                    call AddFrameType( "CFrame",                        7, 0xA8B0D0, 0xA8B1B8 )
                    call AddFrameType( "CFloatingFrame",                8, 0xA8DB2C, 0xA8DC14 )
                    call AddFrameType( "CGameUI",                       9, 0xAB9D90, 0xAB9E78 )
                    call AddFrameType( "CHeroBarButton",               10, 0xABE768, 0xABE7E0 )
                    call AddFrameType( "CHighlightFrame",              11, 0xA8B744, 0xA8B82C )
                    call AddFrameType( "CLayoutFrame",                 12, 0xA8D4B4, 0x000000 )
                    call AddFrameType( "CMessageFrame",                13, 0xA8B898, 0xA8B980 )
                    call AddFrameType( "CMinimap",                     14, 0xAB0EE4, 0xAB0FD4 )
                    call AddFrameType( "CModelFrame",                  15, 0xA8B454, 0xA8B550 )
                    call AddFrameType( "CPortraitButton",              16, 0xABFBC0, 0xABFCE8 )
                    call AddFrameType( "CScreenFrame",                 17, 0xA8DC3C, 0xA8DD24 )
                    call AddFrameType( "CSimpleButton",                18, 0xA8D304, 0x000000 )
                    call AddFrameType( "CSimpleFontString",            19, 0xA8D760, 0x000000 )
                    call AddFrameType( "CSimpleFrame",                 20, 0xA8D204, 0x000000 )
                    call AddFrameType( "CSimpleGlueFrame",             21, 0xA8D7C4, 0x000000 )
                    call AddFrameType( "CUknown_1",                    22, 0x000000, 0x000000 )
                    call AddFrameType( "CSimpleMessageFrame",          23, 0xA8D88C, 0x000000 )
                    call AddFrameType( "CSlider",                      24, 0xA8BDD8, 0xA8BEF4 )
                    call AddFrameType( "CSpriteFrame",                 25, 0xA8B214, 0xA8B304 )
                    call AddFrameType( "CStatBar",                     26, 0xABCE78, 0x000000 )
                    call AddFrameType( "CTextArea",                    27, 0xA8CF7C, 0xA8D090 )
                    call AddFrameType( "CTextButtonFrame",             28, 0xA8C8CC, 0xA8C9E0 )
                    call AddFrameType( "CTextFrame",                   29, 0xA8B9C0, 0xA8BAD4 )
                    call AddFrameType( "CUberToolTipWar3",             30, 0xABCCC8, 0x000000 )
                    call AddFrameType( "CWorldFrameWar3",              31, 0xABB66C, 0xABB754 )
                    call AddFrameType( "CGlueButtonWar3",              32, 0xAA3D00, 0xAA3E14 )
                    call AddFrameType( "CGlueTextButtonWar3",          33, 0xAA3E3C, 0xAA3F50 )
                    call AddFrameType( "CGlueCheckBoxWar3",            34, 0xAA59C0, 0xAA5AD4 )
                    call AddFrameType( "CGluePopupMenuWar3",           35, 0xAA3F78, 0xAA408C )
                    call AddFrameType( "CGlueEditBoxWar3",             36, 0xAA40B4, 0xAA41CC )
                    call AddFrameType( "CSlashChatBox",                37, 0xAA5238, 0xAA5350 )
                    call AddFrameType( "CTimerTextFrame",              38, 0xAA7E70, 0xAA7F84 )
                    call AddFrameType( "CSimpleStatusBar",             39, 0xA8D41C, 0x000000 )
                    call AddFrameType( "CStatusBar",                   40, 0xA8BB20, 0xA8BC28 )
                    call AddFrameType( "CUpperButtonBar",              41, 0xABC8D8, 0xABC948 )
                    call AddFrameType( "CResourceBar",                 42, 0xAC16A8, 0x000000 )
                    call AddFrameType( "CSimpleConsole",               43, 0xAC05FC, 0x000000 )
                    call AddFrameType( "CPeonBar",                     44, 0xAC0504, 0xAC0578 )
                    call AddFrameType( "CHeroBar",                     45, 0xABE7FC, 0xABE870 )
                    call AddFrameType( "CTimeOfDayIndicator",          46, 0xAC1E58, 0xAC1F48 )
                    call AddFrameType( "CInfoBar",                     47, 0xABF288, 0x000000 )
                    call AddFrameType( "CTimeCover",                   48, 0xAC1D48, 0xAC1E30 )
                    call AddFrameType( "CProgressIndicator",           49, 0xAB8BE8, 0x000000 )
                    call AddFrameType( "CHeroLevelBar",                50, 0xABE924, 0x000000 )
                    call AddFrameType( "CBuildTimeIndicator",          51, 0xABCD94, 0x000000 )
                    call AddFrameType( "CInfoPanelDestructableDetail", 52, 0xABF084, 0x000000 )
                    call AddFrameType( "CInfoPanelItemDetail",         53, 0xABF004, 0x000000 )
                    call AddFrameType( "CInfoPanelIconAlly",           54, 0xABEE90, 0x000000 )
                    call AddFrameType( "CInfoPanelIconHero",           55, 0xABEE1C, 0x000000 )
                    call AddFrameType( "CInfoPanelIconGold",           56, 0xABEDA8, 0x000000 )
                    call AddFrameType( "CInfoPanelIconFood",           57, 0xABED34, 0x000000 )
                    call AddFrameType( "CInfoPanelIconRank",           58, 0xABECC0, 0x000000 )
                    call AddFrameType( "CInfoPanelIconArmor",          59, 0xABEC4C, 0x000000 )
                    call AddFrameType( "CInfoPanelIconDamage",         60, 0xABEBD8, 0x000000 )
                    call AddFrameType( "CInfoPanelCargoDetail",        61, 0xABEF84, 0x000000 )
                    call AddFrameType( "CInfoPanelBuildingDetail",     62, 0xABEA78, 0x000000 )
                    call AddFrameType( "CInfoPanelUnitDetail",         63, 0xABEF04, 0x000000 )
                    call AddFrameType( "CSimpleTexture",               64, 0xA8D724, 0x000000 )
                endif
        elseif PatchVersion == "1.28f" then
                if true then // Generation of Frame Type Table
                    call AddFrameType( "CBackdropFrame",                1, 0xA7AFBC, 0xA7B0B8 )
                    call AddFrameType( "CButtonFrame",                  2, 0xA7B698, 0xA7B7AC )
                    call AddFrameType( "CChatMode",                     3, 0xAADE54, 0x000000 )
                    call AddFrameType( "CCommandButton",                4, 0xAAD9B8, 0x000000 )
                    call AddFrameType( "CCursorFrame",                  5, 0xA7D42C, 0xA7D51C )
                    call AddFrameType( "CEditBox",                      6, 0xA7C03C, 0xA7C154 )
                    call AddFrameType( "CFrame",                        7, 0xA7AAE0, 0xA7ABC8 )
                    call AddFrameType( "CFloatingFrame",                8, 0xA7D544, 0xA7D62C )
                    call AddFrameType( "CGameUI",                       9, 0xAAA730, 0xAAA818 )
                    call AddFrameType( "CHeroBarButton",               10, 0xAAF130, 0xAAF1A8 )
                    call AddFrameType( "CHighlightFrame",              11, 0xA7B154, 0xA7B23C )
                    call AddFrameType( "CLayoutFrame",                 12, 0xA7CEC4, 0x000000 )
                    call AddFrameType( "CMessageFrame",                13, 0xA7B2A8, 0xA7B390 )
                    call AddFrameType( "CMinimap",                     14, 0xAB0704, 0xAB07F0 )
                    call AddFrameType( "CModelFrame",                  15, 0xA7AE64, 0xA7AF60 )
                    call AddFrameType( "CPortraitButton",              16, 0xAB05B4, 0xAB06DC )
                    call AddFrameType( "CScreenFrame",                 17, 0xA7D654, 0xA7D73C )
                    call AddFrameType( "CSimpleButton",                18, 0xA7CD14, 0x000000 )
                    call AddFrameType( "CSimpleFontString",            19, 0xA7D178, 0x000000 )
                    call AddFrameType( "CSimpleFrame",                 20, 0xA7CC14, 0x000000 )
                    call AddFrameType( "CSimpleGlueFrame",             21, 0xA7D1DC, 0x000000 )
                    call AddFrameType( "CUknown_1",                    22, 0x000000, 0x000000 )
                    call AddFrameType( "CSimpleMessageFrame",          23, 0xA7D2A8, 0x000000 )
                    call AddFrameType( "CSlider",                      24, 0xA7B7E8, 0xA7B904 )
                    call AddFrameType( "CSpriteFrame",                 25, 0xA7AC24, 0xA7AD14 )
                    call AddFrameType( "CStatBar",                     26, 0xAAD83C, 0x000000 )
                    call AddFrameType( "CTextArea",                    27, 0xA7C98C, 0xA7CAA0 )
                    call AddFrameType( "CTextButtonFrame",             28, 0xA7C2DC, 0xA7C3F0 )
                    call AddFrameType( "CTextFrame",                   29, 0xA7B3D0, 0xA7B4E4 )
                    call AddFrameType( "CUberToolTipWar3",             30, 0xAAD684, 0x000000 )
                    call AddFrameType( "CWorldFrameWar3",              31, 0xAAC008, 0xAAC0F0 )
                    call AddFrameType( "CGlueButtonWar3",              32, 0xA93B68, 0xA93C7C )
                    call AddFrameType( "CGlueTextButtonWar3",          33, 0xA93CA4, 0xA93DB8 )
                    call AddFrameType( "CGlueCheckBoxWar3",            34, 0xA95844, 0xA95958 )
                    call AddFrameType( "CGluePopupMenuWar3",           35, 0xA93DE0, 0xA93EF4 )
                    call AddFrameType( "CGlueEditBoxWar3",             36, 0xA93F1C, 0xA94034 )
                    call AddFrameType( "CSlashChatBox",                37, 0xA950A0, 0xA951B8 )
                    call AddFrameType( "CTimerTextFrame",              38, 0xA97D38, 0xA97E4C )
                    call AddFrameType( "CSimpleStatusBar",             39, 0xA7CE2C, 0x000000 )
                    call AddFrameType( "CStatusBar",                   40, 0xA7B530, 0xA7B638 )
                    call AddFrameType( "CUpperButtonBar",              41, 0xAAD28C, 0xAAD2FC )
                    call AddFrameType( "CResourceBar",                 42, 0xAB20D4, 0x000000 )
                    call AddFrameType( "CSimpleConsole",               43, 0xAB1008, 0x000000 )
                    call AddFrameType( "CPeonBar",                     44, 0xAB0F08, 0xAB0F7C )
                    call AddFrameType( "CHeroBar",                     45, 0xAAF1C4, 0xAAF238 )
                    call AddFrameType( "CTimeOfDayIndicator",          46, 0xAB2890, 0xAB2980 )
                    call AddFrameType( "CInfoBar",                     47, 0xAAFC58, 0x000000 )
                    call AddFrameType( "CTimeCover",                   48, 0xAB2780, 0xAB2868 )
                    call AddFrameType( "CProgressIndicator",           49, 0xAA950C, 0x000000 )
                    call AddFrameType( "CHeroLevelBar",                50, 0xAAF2F0, 0x000000 )
                    call AddFrameType( "CBuildTimeIndicator",          51, 0xAAD750, 0x000000 )
                    call AddFrameType( "CInfoPanelDestructableDetail", 52, 0xAAFA54, 0x000000 )
                    call AddFrameType( "CInfoPanelItemDetail",         53, 0xAAF9D4, 0x000000 )
                    call AddFrameType( "CInfoPanelIconAlly",           54, 0xAAF860, 0x000000 )
                    call AddFrameType( "CInfoPanelIconHero",           55, 0xAAF7EC, 0x000000 )
                    call AddFrameType( "CInfoPanelIconGold",           56, 0xAAF778, 0x000000 )
                    call AddFrameType( "CInfoPanelIconFood",           57, 0xAAF704, 0x000000 )
                    call AddFrameType( "CInfoPanelIconRank",           58, 0xAAF690, 0x000000 )
                    call AddFrameType( "CInfoPanelIconArmor",          59, 0xAAF61C, 0x000000 )
                    call AddFrameType( "CInfoPanelIconDamage",         60, 0xAAF5A8, 0x000000 )
                    call AddFrameType( "CInfoPanelCargoDetail",        61, 0xAAF954, 0x000000 )
                    call AddFrameType( "CInfoPanelBuildingDetail",     62, 0xAAF448, 0x000000 )
                    call AddFrameType( "CInfoPanelUnitDetail",         63, 0xAAF8D4, 0x000000 )
                    call AddFrameType( "CSimpleTexture",               64, 0xA7D13C, 0x000000 )
                endif
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_APIMemoryGameUIButton takes nothing returns nothing
    //set gg_trg_APIMemoryGameUIButton = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: APIMemoryGameWindow
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library APIMemoryWC3GameWindow
    globals
        integer pGetWarcraftWindow          = 0
        integer pGetWindowWidth             = 0
        integer pGetWindowHeight            = 0
    endglobals

    // Window API Engine
    function GetWindowWidth takes nothing returns real
        if pGetWindowWidth > 0 then
            return GetRealFromMemory( ReadRealMemory( pGetWindowWidth ) )
        endif

        return 0.
    endfunction

    function GetWindowHeight takes nothing returns real
        if pGetWindowHeight > 0 then
            return GetRealFromMemory( ReadRealMemory( pGetWindowHeight ) )
        endif

        return 0.
    endfunction
    
    function GetWindowCenterX takes nothing returns real
        return GetWindowX( pHWND_WC3 ) + GetWindowWidth( ) * 0.5
    endfunction

    function GetWindowCenterY takes nothing returns real
        return GetWindowY( pHWND_WC3 ) + GetWindowHeight( ) * 0.5
    endfunction

    function GetWarcraftWindow takes nothing returns integer
        local integer hwnd = 0

        if pGetWarcraftWindow > 0 then
            set hwnd = this_call_1( pGetWarcraftWindow, 0 )
        else
            set hwnd = FindWindow( "Warcraft III", "Warcraft III" )
        endif

        return hwnd
    endfunction
    
    function FromPixelX takes integer i returns real
        return i * 0.8 / GetWindowWidth( )
    endfunction

    function FromPixelY takes integer i returns real
        return i * 0.6 / GetWindowHeight( )
    endfunction
    //===========================================

    function Init_APIMemoryGameWindow takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pGetWindowWidth     = pGameDLL + 0xAF577C
                set pGetWindowHeight    = pGameDLL + 0xAF5778
                set pGetWarcraftWindow  = pGameDLL + 0x6BB510
        elseif PatchVersion == "1.26a" then
                set pGetWindowWidth     = pGameDLL + 0xADE91C
                set pGetWindowHeight    = pGameDLL + 0xADE918
                set pGetWarcraftWindow  = pGameDLL + 0x6BAD70
        elseif PatchVersion == "1.27a" then
                set pGetWindowWidth     = pGameDLL + 0xBBA22C // "config.txt", 0) -> sub_6F first func no params -> above return variable under |= 1u = pGetWindow | pGetWindow + 0xC
                set pGetWindowHeight    = pGameDLL + 0xBBA228 // pGetWindow + 0x8
                set pGetWarcraftWindow  = pGameDLL + 0x14D670 // return GetActiveWindow();
        elseif PatchVersion == "1.27b" then
                set pGetWindowWidth     = pGameDLL + 0xD47CC4
                set pGetWindowHeight    = pGameDLL + 0xD47CC0
                set pGetWarcraftWindow  = pGameDLL + 0x08B0A0
        elseif PatchVersion == "1.28f" then
                set pGetWindowWidth     = pGameDLL + 0xD0FAB4
                set pGetWindowHeight    = pGameDLL + 0xD0FAB0
                set pGetWarcraftWindow  = pGameDLL + 0x0B49B0
            endif

            if pGetWarcraftWindow > 0 then
                set pHWND_WC3 = GetWarcraftWindow( )
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_APIMemoryGameWindow takes nothing returns nothing
    //set gg_trg_APIMemoryGameWindow = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackConstantsAPI
//===========================================================================
//TESH.scrollpos=31
//TESH.alwaysfold=0
//! nocjass
library MemoryHackConstantsAPI
    globals
        integer pOPLimitPos = 0
        integer pGetOPLimit = 0
    endglobals

    function IsOPLimitEnabled takes nothing returns boolean
        return ReadRealMemory( pOPLimitPos ) == 0x6A570FFF
    endfunction

    function EnableOPLimit takes boolean flag returns nothing
        local integer oldprotection1 = 0
        local integer value          = 0

        if pOPLimitPos > 0 then
            if pGetOPLimit == 0 then
                set pGetOPLimit = ReadRealMemory( pOPLimitPos )
            endif
            
            if pGetOPLimit > 0 then
                if flag then
                    set value = pGetOPLimit
                else
                    set value = 0x6A570FFF
                endif

                set oldprotection1 = ChangeOffsetProtection( pOPLimitPos, 0x4, 0x40 )
                call WriteRealMemory( pOPLimitPos, value )
                call ChangeOffsetProtection( pOPLimitPos, 0x4, oldprotection1 )
            endif
        endif
    endfunction
    
    function Init_MemHackConstantsAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pOPLimitPos = pGameDLL + 0x3A8ECC
        elseif PatchVersion == "1.26a" then
                set pOPLimitPos = pGameDLL + 0x3A838C
        elseif PatchVersion == "1.27a" then
                set pOPLimitPos = pGameDLL + 0x1BFB4B // 0, a3, 300000, a5, a6); or check "Script function timeout!" | addr + 0x3
        elseif PatchVersion == "1.27b" then
                set pOPLimitPos = pGameDLL + 0x1DD83B
        elseif PatchVersion == "1.28f" then
                set pOPLimitPos = pGameDLL + 0x2100BB
            endif
        endif
    endfunction
endlibrary
    
//===========================================================================
function InitTrig_MemHackConstantsAPI takes nothing returns nothing
    //set gg_trg_MemHackConstantsAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCFrameAPI
//===========================================================================
//TESH.scrollpos=133
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCFrameAPI
    globals
        integer pStringManager                  = 0
        integer pFDFHashTableList               = 0
        integer pStringHashNodeGrowListArray    = 0
        integer pBaseFrameHashNodeGrowListArray = 0
        integer pReadTOCFile                    = 0
        integer pDefaultCStatus                 = 0
        integer pGetCFrameByName                = 0
        integer pCreateCFrame                   = 0
    endglobals

    function SetStringHashNodeListSize takes integer size returns boolean
        if pStringHashNodeGrowListArray != 0 and pStringManager != 0 then
            if ReadRealMemory( pStringManager + 0x14 ) < size then // if 1.29+ + 0x18
                call this_call_2( pStringHashNodeGrowListArray, pStringManager, size )
            endif

            return true
        endif

        return false
    endfunction
    
    function SetBaseFrameHashNodeListSize takes integer size returns boolean
        if pBaseFrameHashNodeGrowListArray != 0 and pFDFHashTableList != 0 then
            if ReadRealMemory( pFDFHashTableList + 0x14 ) < size then // if 1.29+ + 0x18
                call this_call_2( pBaseFrameHashNodeGrowListArray, pFDFHashTableList, size )
            endif

            return true
        endif

        return false
    endfunction
    
    function LoadTOCFile takes string filename returns integer
        local integer retval = 0

        if pReadTOCFile != 0 and pDefaultCStatus != 0 and SetStringHashNodeListSize( 0xFFFF ) and SetBaseFrameHashNodeListSize( 0xFFFF ) then
            set retval = fast_call_4( pReadTOCFile, GetStringAddress( filename ), pStringManager, pFDFHashTableList, pDefaultCStatus )
            //call ReallocateCallMemory( ) // no longer needed, now also causes crash, as the data integrity even after TOC call is fine.
        endif

        return retval
    endfunction

    function GetCFrameByName takes string name, integer id returns integer
        if pGetCFrameByName > 0 then
            if name != "" then
                return fast_call_2( pGetCFrameByName, GetStringAddress( name ), id )
            endif
        endif

        return 0
    endfunction

    function CreateCFrameEx takes string baseframe, integer parent, integer point, integer relativepoint, integer id returns integer
        if pCreateCFrame > 0 then
            if baseframe != "" then
                return fast_call_5( pCreateCFrame, GetStringAddress( baseframe ), parent, point, relativepoint, id )
            endif
        endif

        return 0
    endfunction

    function CreateCFrame takes string baseframe, integer parent, integer id returns integer
        return CreateCFrameEx( baseframe, parent, 0, 0, id )
    endfunction

    function GetFrameLayoutByType takes integer pFrame, integer fid returns integer
        local boolean case1 = fid ==  4 or fid == 10 or fid == 12 or ( fid >= 18 and fid <= 23 )
        local boolean case2 = fid == 26 or fid == 30 or fid == 39 or ( fid >= 41 and fid <= 45 )
        local boolean case3 = fid == 47 or ( fid >= 49 and fid <= 64 )

        if fid != 0 then
            if case1 or case2 or case3 then
                return pFrame
            else
                return pFrame + 0xB4 // if 1.29+ 0xBC
            endif
        endif

        return 0
    endfunction

    function GetFrameLayout takes integer pFrame returns integer
        return GetFrameLayoutByType( pFrame, GetFrameType( pFrame ) )
    endfunction

    function IsFrameLayoutByType takes integer pFrame, integer fid returns boolean
        return GetFrameLayoutByType( pFrame, fid ) == pFrame
    endfunction

    function IsFrameLayout takes integer pFrame returns boolean
        return GetFrameLayout( pFrame ) == pFrame
    endfunction

    function Init_MemHackCFrameAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pDefaultCStatus                 = pGameDLL + 0xAA2824
                set pStringManager                  = pGameDLL + 0xAE4074
                set pFDFHashTableList               = pGameDLL + 0xAE40C4
                set pStringHashNodeGrowListArray    = pGameDLL + 0x5CB150
                set pBaseFrameHashNodeGrowListArray = pGameDLL + 0x5D5DF0
                set pReadTOCFile                    = pGameDLL + 0x5D9580
                set pGetCFrameByName                = pGameDLL + 0x5FB110
                set pCreateCFrame                   = pGameDLL + 0x5C9D00
        elseif PatchVersion == "1.26a" then
                set pDefaultCStatus                 = pGameDLL + 0xA8C804
                set pStringManager                  = pGameDLL + 0xACD214
                set pFDFHashTableList               = pGameDLL + 0xACD264
                set pStringHashNodeGrowListArray    = pGameDLL + 0x5CA9B0
                set pBaseFrameHashNodeGrowListArray = pGameDLL + 0x5D5650
                set pReadTOCFile                    = pGameDLL + 0x5D8DE0
                set pDefaultCStatus                 = pGameDLL + 0xA8C804
                set pGetCFrameByName                = pGameDLL + 0x5FA970
                set pCreateCFrame                   = pGameDLL + 0x5C9560
        elseif PatchVersion == "1.27a" then
                set pDefaultCStatus                 = pGameDLL + 0xB662CC
                set pStringManager                  = pGameDLL + 0xBB9CAC
                set pFDFHashTableList               = pGameDLL + 0xBB9CFC
                set pStringHashNodeGrowListArray    = pGameDLL + 0x067560
                set pBaseFrameHashNodeGrowListArray = pGameDLL + 0x066ED0
                set pReadTOCFile                    = pGameDLL + 0x066590
                set pGetCFrameByName                = pGameDLL + 0x09EF40
                set pCreateCFrame                   = pGameDLL + 0x0909C0
        elseif PatchVersion == "1.27b" then
                set pDefaultCStatus                 = pGameDLL + 0xCE3A4C
                set pStringManager                  = pGameDLL + 0xD47744
                set pFDFHashTableList               = pGameDLL + 0xD47794
                set pStringHashNodeGrowListArray    = pGameDLL + 0x0BB550
                set pBaseFrameHashNodeGrowListArray = pGameDLL + 0x0BAEC0
                set pReadTOCFile                    = pGameDLL + 0x0BA580
                set pGetCFrameByName                = pGameDLL + 0x0F2CA0
                set pCreateCFrame                   = pGameDLL + 0x0E4740
        elseif PatchVersion == "1.28f" then
                set pDefaultCStatus                 = pGameDLL + 0xCB1A94
                set pStringManager                  = pGameDLL + 0xD0F524
                set pFDFHashTableList               = pGameDLL + 0xD0F574
                set pStringHashNodeGrowListArray    = pGameDLL + 0x0E9D40
                set pBaseFrameHashNodeGrowListArray = pGameDLL + 0x0E96B0
                set pReadTOCFile                    = pGameDLL + 0x0E8D70
                set pGetCFrameByName                = pGameDLL + 0x1212F0
                set pCreateCFrame                   = pGameDLL + 0x112D90
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackCFrameAPI takes nothing returns nothing
    //set gg_trg_MemHackCFrameAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCLayerAPI
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCLayerAPI
    globals
        integer pFindCLayerUnderCursor          = 0
        integer pSetCLayerOwner                 = 0
        integer pHideCLayer                     = 0
        integer pShowCLayer                     = 0
        integer pSetCLayerAlpha                 = 0
        integer pSetCLayerFont                  = 0
        integer pSetCLayerTooltip               = 0

        integer pActiveCLayer                   = 0
    endglobals

    function FindCLayerUnderCursorEx takes integer pActiveLayer, integer pMouseEvent returns integer
        local integer pData = 0
        local integer value = 0

        if pActiveLayer > 0 then
            set pData = ReadRealMemory( pActiveLayer )
            
            if pData > 0 then
                set pData = this_call_2( pFindCLayerUnderCursor, pData, pMouseEvent )

                if pData > 0 then
                    if ReadRealMemory( pData ) != pWorldFrameWar3UI then
                        return pData
                    endif
                endif
            endif
        endif

        return 0
    endfunction

    function FindCLayerUnderCursor takes nothing returns integer
        return FindCLayerUnderCursorEx( pActiveCLayer, pGlobalMouseEvent )
    endfunction
    
    function SetCLayerOwner takes integer pFrame, integer pParentFrame returns integer
        if pSetCLayerOwner > 0 then
            if pFrame > 0 and pParentFrame > 0 then
                return this_call_4( pSetCLayerOwner, pFrame, pParentFrame, 1, 0 )
            endif
        endif

        return 0
    endfunction

    function HideCLayer takes integer pFrame returns integer
        if pHideCLayer > 0 then
            if pFrame > 0 then
                return this_call_1( pHideCLayer, pFrame )
            endif
        endif

        return 0
    endfunction

    function ShowCLayer takes integer pFrame returns integer
        if pShowCLayer > 0 then
            if pFrame > 0 then
                return this_call_1( pShowCLayer, pFrame )
            endif
        endif

        return 0
    endfunction

    function SetCLayerAlpha takes integer pFrame, integer alpha returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCLayerAlpha > 0 then
            if fid > 0 and fid != 6 then
                return this_call_3( pSetCLayerAlpha, pFrame, alpha, 0 )
            endif
        endif

        return 0
    endfunction

    function SetCLayerFont takes integer pFrame, string filename, real height, integer flag returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCLayerFont > 0 then
            if fid != 6 and fid != 19 and fid != 23 then
                if not IsFrameLayoutByType( pFrame, fid ) then
                    return this_call_4( pSetCLayerFont, pFrame, GetStringAddress( filename ), SetRealIntoMemory( height ), flag )
                endif
            endif
        endif

        return 0
    endfunction

    function SetCLayerTooltip takes integer pFrame, integer pTooltip returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCLayerTooltip > 0 then
            if fid > 0 then
                if pTooltip > 0 then
                    call WriteRealMemory( pFrame + 0x230, 1 )
                    call this_call_2( pClearCLayoutFrameAllPoints, pTooltip + 0xB4, 1 ) //if 1.29+ then 0xBC
                endif

                return this_call_2( pSetCLayerTooltip, pFrame, pTooltip )
            endif
        endif

        return 0
    endfunction

    function Init_MemHackCLayerAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pFindCLayerUnderCursor  = pGameDLL + 0x5FE1C0
                set pSetCLayerOwner         = pGameDLL + 0x5FFE70
                set pHideCLayer             = pGameDLL + 0x5FEE90
                set pShowCLayer             = pGameDLL + 0x5FEE30
                set pSetCLayerAlpha         = pGameDLL + 0x5FE660
                set pSetCLayerFont          = pGameDLL + 0x5FC100
                set pSetCLayerTooltip       = pGameDLL + 0x5FFFA0
                set pActiveCLayer           = pGameDLL + 0xAE54CC
        elseif PatchVersion == "1.26a" then
                set pFindCLayerUnderCursor  = pGameDLL + 0x5FDA20
                set pSetCLayerOwner         = pGameDLL + 0x5FF6D0
                set pHideCLayer             = pGameDLL + 0x5FE6F0
                set pShowCLayer             = pGameDLL + 0x5FE690
                set pSetCLayerAlpha         = pGameDLL + 0x5FDEC0
                set pSetCLayerFont          = pGameDLL + 0x5FB960
                set pSetCLayerTooltip       = pGameDLL + 0x5FF800
                set pActiveCLayer           = pGameDLL + 0xACE66C
        elseif PatchVersion == "1.27a" then
                set pFindCLayerUnderCursor  = pGameDLL + 0x0996E0
                set pSetCLayerOwner         = pGameDLL + 0x09D2B0
                set pHideCLayer             = pGameDLL + 0x09A320
                set pShowCLayer             = pGameDLL + 0x09D450
                set pSetCLayerAlpha         = pGameDLL + 0x09CA50
                set pSetCLayerFont          = pGameDLL + 0x09CE60
                set pSetCLayerTooltip       = pGameDLL + 0x09D3D0
                set pActiveCLayer           = pGameDLL + 0xBB9D88
        elseif PatchVersion == "1.27b" then
                set pFindCLayerUnderCursor  = pGameDLL + 0x0ED440
                set pSetCLayerOwner         = pGameDLL + 0x0F1010
                set pHideCLayer             = pGameDLL + 0x0EE080
                set pShowCLayer             = pGameDLL + 0x0F11B0
                set pSetCLayerAlpha         = pGameDLL + 0x0F07B0
                set pSetCLayerFont          = pGameDLL + 0x0F0BC0
                set pSetCLayerTooltip       = pGameDLL + 0x0F1130
                set pActiveCLayer           = pGameDLL + 0xD47820
        elseif PatchVersion == "1.28f" then
                set pFindCLayerUnderCursor  = pGameDLL + 0x11BA90
                set pSetCLayerOwner         = pGameDLL + 0x11F660
                set pHideCLayer             = pGameDLL + 0x11C6D0
                set pShowCLayer             = pGameDLL + 0x11F800
                set pSetCLayerAlpha         = pGameDLL + 0x11EE00
                set pSetCLayerFont          = pGameDLL + 0x11F210
                set pSetCLayerTooltip       = pGameDLL + 0x11F780
                set pActiveCLayer           = pGameDLL + 0xD0F600
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackCLayerAPI takes nothing returns nothing
    //set gg_trg_MemHackCLayerAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCLayoutFrameAPI
//===========================================================================
//TESH.scrollpos=81
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCLayoutFrameAPI
    globals
        integer pSetCLayoutFrameScale           = 0
        integer pGetCLayoutFrameHeight          = 0
        
        integer pSetCLayoutFramePoint           = 0
        integer pClearCLayoutFrameAllPoints     = 0
        integer pSetCLayoutFrameWidth           = 0
        integer pSetCLayoutFrameHeight          = 0
        integer pSetCLayoutFrameAbsolutePoint   = 0
        integer pSetCLayoutFrameCageMouse       = 0
        integer pSetCLayoutFrameAllPoints       = 0
    endglobals

    function SetCLayoutFrameAbsolutePoint takes integer pFrame, integer point, real offsetX, real offsetY returns integer
        if pSetCLayoutFrameAbsolutePoint > 0 then
            if GetFrameLayout( pFrame ) > 0 then
                return this_call_5( pSetCLayoutFrameAbsolutePoint, pFrame, point, SetRealIntoMemory( offsetX ), SetRealIntoMemory( offsetY ), 1 )
            endif
        endif

        return 0
    endfunction

    function SetCLayoutFrameCageMouse takes integer pFrame, boolean flag returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCLayoutFrameCageMouse > 0 then
            if fid > 0 then
                return this_call_2( pSetCLayoutFrameCageMouse, pFrame, B2I( flag ) )
            endif
        endif

        return 0
    endfunction

    function ClearCLayoutFrameAllPoints takes integer pFrame returns integer
        if pClearCLayoutFrameAllPoints > 0 then
            set pFrame = GetFrameLayout( pFrame )

            if pFrame > 0 then
                return this_call_2( pClearCLayoutFrameAllPoints, pFrame, 1 )
            endif
        endif

        return 0
    endfunction

    function SetCLayoutFrameWidth takes integer pFrame, real width returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCLayoutFrameWidth > 0 then
            if fid > 0 then
                return this_call_2( pSetCLayoutFrameWidth, pFrame, SetRealIntoMemory( width ) )
            endif
        endif

        return 0
    endfunction

    function SetCLayoutFrameHeight takes integer pFrame, real height returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCLayoutFrameHeight > 0 then
            if fid > 0 then
                return this_call_2( pSetCLayoutFrameHeight, pFrame, SetRealIntoMemory( height ) )
            endif
        endif

        return 0
    endfunction

    function SetCLayoutFrameAllPoints takes integer pFrame, integer relativeframe returns integer
         if pSetCLayoutFrameAllPoints > 0 then
            set pFrame = GetFrameLayout( pFrame )

            if pFrame > 0 and GetFrameLayout( relativeframe ) > 0 then
                return this_call_3( pSetCLayoutFrameAllPoints, pFrame, relativeframe, 1 )
            endif
        endif

        return 0
    endfunction

    function SetCLayoutFrameSize takes integer pFrame, real width, real height returns integer
        local integer fid = GetFrameLayout( pFrame )

        if pSetCLayoutFrameWidth > 0 and pSetCLayoutFrameHeight > 0 then
            if fid != 0 then
                call this_call_2( pSetCLayoutFrameWidth, fid, SetRealIntoMemory( width ) )
                call this_call_2( pSetCLayoutFrameHeight, fid, SetRealIntoMemory( height ) )
                return 1
            endif
        endif

        return 0
    endfunction

    function SetCLayoutFramePoint takes integer pFrame, integer point, integer pParentFrame, integer relativePoint, real x, real y returns integer
        if pSetCLayoutFramePoint > 0 then
            if pFrame > 0 and pParentFrame > 0 then
                return B2I( this_call_7( pSetCLayoutFramePoint, pFrame, point, pParentFrame, relativePoint, SetRealIntoMemory( x ), SetRealIntoMemory( y ), 1 ) > 0 )
            endif
        endif

        return 0
    endfunction

    function SetCLayoutFrameScale takes integer pFrame, real scale returns integer
        set pFrame = GetFrameLayout( pFrame )

        if pSetCLayoutFrameScale > 0 then
            if pFrame > 0 then
                return this_call_2( pSetCLayoutFrameScale, pFrame, SetRealIntoMemory( scale ) )
            endif
        endif

        return 0
    endfunction

    function GetCLayoutFrameHeight takes integer pFrame returns real
        local integer fid = GetFrameType( pFrame )

        if pGetCLayoutFrameHeight > 0 then
            if fid != 15 and fid != 19 and fid != 25 and fid != 29 then
                set pFrame = GetFrameLayoutByType( pFrame, fid )

                if pFrame > 0 then
                    return GetRealFromMemory( this_call_1( pGetCLayoutFrameHeight, pFrame ) )
                endif
            endif
        endif

        return 0.
    endfunction

    function Init_MemHackCLayoutFrameAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pGetCLayoutFrameHeight          = pGameDLL + 0x605740
                set pSetCLayoutFrameScale           = pGameDLL + 0x6064E0
                set pSetCLayoutFramePoint           = pGameDLL + 0x606F10
                set pClearCLayoutFrameAllPoints     = pGameDLL + 0x606A10
                set pSetCLayoutFrameWidth           = pGameDLL + 0x606530
                set pSetCLayoutFrameHeight          = pGameDLL + 0x606550
                set pSetCLayoutFrameAbsolutePoint   = pGameDLL + 0x606950
                set pSetCLayoutFrameCageMouse       = pGameDLL + 0x605760
                set pSetCLayoutFrameAllPoints       = pGameDLL + 0x606F90
        elseif PatchVersion == "1.26a" then
                set pGetCLayoutFrameHeight          = pGameDLL + 0x604FA0
                set pSetCLayoutFrameScale           = pGameDLL + 0x605D40
                set pSetCLayoutFramePoint           = pGameDLL + 0x606770
                set pClearCLayoutFrameAllPoints     = pGameDLL + 0x606270
                set pSetCLayoutFrameWidth           = pGameDLL + 0x605D90
                set pSetCLayoutFrameHeight          = pGameDLL + 0x605DB0
                set pSetCLayoutFrameAbsolutePoint   = pGameDLL + 0x6061B0
                set pSetCLayoutFrameCageMouse       = pGameDLL + 0x604FC0
                set pSetCLayoutFrameAllPoints       = pGameDLL + 0x6067F0
        elseif PatchVersion == "1.27a" then
                set pGetCLayoutFrameHeight          = pGameDLL + 0x0BCDF0
                set pSetCLayoutFrameScale           = pGameDLL + 0x0BD7E0
                set pSetCLayoutFramePoint           = pGameDLL + 0x0BD8A0
                set pClearCLayoutFrameAllPoints     = pGameDLL + 0x0BCB50
                set pSetCLayoutFrameWidth           = pGameDLL + 0x0BD960
                set pSetCLayoutFrameHeight          = pGameDLL + 0x0BD7C0
                set pSetCLayoutFrameAbsolutePoint   = pGameDLL + 0x0BD830
                set pSetCLayoutFrameCageMouse       = pGameDLL + 0x0BC8D0
                set pSetCLayoutFrameAllPoints       = pGameDLL + 0x0BD750
        elseif PatchVersion == "1.27b" then
                set pGetCLayoutFrameHeight          = pGameDLL + 0x110B50
                set pSetCLayoutFrameScale           = pGameDLL + 0x111540
                set pSetCLayoutFramePoint           = pGameDLL + 0x111600
                set pClearCLayoutFrameAllPoints     = pGameDLL + 0x1108B0
                set pSetCLayoutFrameWidth           = pGameDLL + 0x1116C0
                set pSetCLayoutFrameHeight          = pGameDLL + 0x111520
                set pSetCLayoutFrameAbsolutePoint   = pGameDLL + 0x111590
                set pSetCLayoutFrameCageMouse       = pGameDLL + 0x110630
                set pSetCLayoutFrameAllPoints       = pGameDLL + 0x1114B0
        elseif PatchVersion == "1.28f" then
                set pGetCLayoutFrameHeight          = pGameDLL + 0x13F170
                set pSetCLayoutFrameScale           = pGameDLL + 0x13FB60
                set pSetCLayoutFramePoint           = pGameDLL + 0x13FC20
                set pClearCLayoutFrameAllPoints     = pGameDLL + 0x13EE90
                set pSetCLayoutFrameWidth           = pGameDLL + 0x13FCE0
                set pSetCLayoutFrameHeight          = pGameDLL + 0x13FB40
                set pSetCLayoutFrameAbsolutePoint   = pGameDLL + 0x13FBB0
                set pSetCLayoutFrameCageMouse       = pGameDLL + 0x13EB60
                set pSetCLayoutFrameAllPoints       = pGameDLL + 0x13FAD0
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackCLayoutFrameAPI takes nothing returns nothing
    //set gg_trg_MemHackCLayoutFrameAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCBackDropFrameAPI
//===========================================================================
//TESH.scrollpos=14
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCFrameBackDropAPI
    globals
        integer pCreateCBackdropFrame       = 0
        integer pLoadCBackDropFrameTexture  = 0
        integer pSetCBackDropFrameTexture   = 0
    endglobals
    
    function AllocateCBackdropFrameMemory takes nothing returns integer
        return StormAllocateMemory( 0x1DC, "MemHackCBackdropFrame", 23, 0 )
    endfunction
    
    function CreateCBackdropFrameEx takes integer pBackDrop, integer pParent, integer unk1, integer priority returns integer
        if pCreateCBackdropFrame != 0 and pBackDrop != 0 then
            return this_call_4( pCreateCBackdropFrame, pBackDrop, pParent, unk1, priority )
        endif

        return 0
    endfunction
    
    function CreateCBackdropFrame takes integer pParent, integer priority returns integer
        return CreateCBackdropFrameEx( AllocateCBackdropFrameMemory( ), pParent, 0, priority )
    endfunction
    
    function LoadCBackDropFrameTexture takes string texturepath, boolean create returns integer
        if pLoadCBackDropFrameTexture > 0 then
            if texturepath != "" then
                return std_call_2( pLoadCBackDropFrameTexture, GetStringAddress( texturepath ), B2I( create ) )
            endif
        endif

        return 0
    endfunction

    function SetCBackDropFrameTexture takes integer pFrame, string texturepath, boolean flag returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCBackDropFrameTexture > 0 then
            if fid == 1 then
                return this_call_6( pSetCBackDropFrameTexture, pFrame, GetStringAddress( texturepath ), 0, B2I( flag ), 0, 1 )
            endif
        endif

        return 0
    endfunction

    function Init_MemHackCBackDropFrameAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pCreateCBackdropFrame       = pGameDLL + 0x621670
                set pLoadCBackDropFrameTexture  = pGameDLL + 0x621780
                set pSetCBackDropFrameTexture   = pGameDLL + 0x621A70
        elseif PatchVersion == "1.26a" then
                set pCreateCBackdropFrame       = pGameDLL + 0x620ED0
                set pLoadCBackDropFrameTexture  = pGameDLL + 0x620FE0
                set pSetCBackDropFrameTexture   = pGameDLL + 0x6212D0
        elseif PatchVersion == "1.27a" then
                set pCreateCBackdropFrame       = pGameDLL + 0x0A4700
                set pLoadCBackDropFrameTexture  = pGameDLL + 0x0A4AE0
                set pSetCBackDropFrameTexture   = pGameDLL + 0x0A62A0
        elseif PatchVersion == "1.27b" then
                set pCreateCBackdropFrame       = pGameDLL + 0x0F8460
                set pLoadCBackDropFrameTexture  = pGameDLL + 0x0F8840
                set pSetCBackDropFrameTexture   = pGameDLL + 0x0FA000
        elseif PatchVersion == "1.28f" then
                set pCreateCBackdropFrame       = pGameDLL + 0x126AD0
                set pLoadCBackDropFrameTexture  = pGameDLL + 0x126EB0
                set pSetCBackDropFrameTexture   = pGameDLL + 0x128670
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackCBackDropFrameAPI takes nothing returns nothing
    //set gg_trg_MemHackCBackDropFrameAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCEditBoxAPI
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCFrameEditBoxAPI
    globals
        integer pGetCEditBoxText    = 0
        integer pSetCEditBoxText    = 0
        integer pSetCEditBoxFont    = 0
        integer pSetCEditBoxFocus   = 0
    endglobals

    function SetCEditBoxFocus takes integer pFrame, boolean flag returns integer
        if GetFrameType( pFrame ) == 6 then
            return this_call_2( pSetCEditBoxFocus, pFrame, B2I( flag ) )
        endif

        return 0
    endfunction

    function SetCEditBoxFont takes integer pFrame, string filename, real height, integer flag returns integer
        local integer fid = GetFrameType( pFrame )
        
        if pSetCEditBoxFont > 0 then
            if fid == 6 then
                return this_call_4( pSetCEditBoxFont, pFrame, GetStringAddress( filename ), SetRealIntoMemory( height ), flag )
            endif
        endif

        return 0
    endfunction

    function GetCEditBoxText takes integer pFrame returns string
        local integer fid = GetFrameType( pFrame )

        if pGetCEditBoxText > 0 then
            if fid == 6 then
                return ToJString( this_call_1( pGetCEditBoxText, pFrame ) )
            endif
        endif

        return ""
    endfunction

    function SetCEditBoxText takes integer pFrame, string text returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCEditBoxText > 0 then
            if fid == 6 or fid == 36 or fid == 37 then
                return B2I( this_call_3( pSetCEditBoxText, pFrame, GetStringAddress( text ), 1 ) > 0 )
            endif
        endif

        return 0
    endfunction

    function Init_MemHackCEditBoxAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pGetCEditBoxText    = pGameDLL + 0x614640
                set pSetCEditBoxText    = pGameDLL + 0x6162F0
                set pSetCEditBoxFont    = pGameDLL + 0x614440
                set pSetCEditBoxFocus   = pGameDLL + 0x615920
        elseif PatchVersion == "1.26a" then
                set pGetCEditBoxText    = pGameDLL + 0x613EA0
                set pSetCEditBoxText    = pGameDLL + 0x615B50
                set pSetCEditBoxFont    = pGameDLL + 0x613CA0
                set pSetCEditBoxFocus   = pGameDLL + 0x615180
        elseif PatchVersion == "1.27a" then
                set pGetCEditBoxText    = pGameDLL + 0x0AEDF0
                set pSetCEditBoxText    = pGameDLL + 0x0B0450
                set pSetCEditBoxFont    = pGameDLL + 0x0B0350
                set pSetCEditBoxFocus   = pGameDLL + 0x0B0260
        elseif PatchVersion == "1.27b" then
                set pGetCEditBoxText    = pGameDLL + 0x102B50
                set pSetCEditBoxText    = pGameDLL + 0x1041B0
                set pSetCEditBoxFont    = pGameDLL + 0x1040B0
                set pSetCEditBoxFocus   = pGameDLL + 0x103FC0
        elseif PatchVersion == "1.28f" then
                set pGetCEditBoxText    = pGameDLL + 0x1311C0
                set pSetCEditBoxText    = pGameDLL + 0x132820
                set pSetCEditBoxFont    = pGameDLL + 0x132720
                set pSetCEditBoxFocus   = pGameDLL + 0x132630
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackCEditBoxAPI takes nothing returns nothing
    //set gg_trg_MemHackCEditBoxAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCModelFrameAPI
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCModelFrameAPI
    globals
        integer pAddCModelFrameModel    = 0
        integer pGetCModelFrameHeight   = 0
    endglobals

    function AddCModelFrameModel takes integer pFrame, string model, integer modeltype returns integer
        local integer fid = GetFrameType( pFrame )

        if pAddCModelFrameModel > 0 then
            if fid == 15 then
                return this_call_3( pAddCModelFrameModel, pFrame, GetStringAddress( model ), modeltype )
            endif
        endif

        return 0
    endfunction

    function GetCModelFrameHeight takes integer pFrame returns real
        local integer fid = GetFrameType( pFrame )

        if pGetCModelFrameHeight > 0 then
            if fid == 15 then
                return GetRealFromMemory( this_call_1( pGetCModelFrameHeight, pFrame ) )
            endif
        endif

        return 0.
    endfunction

    function Init_MemHackCModelFrameAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pAddCModelFrameModel    = pGameDLL + 0x621D70
                set pGetCModelFrameHeight   = pGameDLL + 0x622100
        elseif PatchVersion == "1.26a" then
                set pAddCModelFrameModel    = pGameDLL + 0x6215D0
                set pGetCModelFrameHeight   = pGameDLL + 0x621960
        elseif PatchVersion == "1.27a" then
                set pAddCModelFrameModel    = pGameDLL + 0x0A3FA0
                set pGetCModelFrameHeight   = pGameDLL + 0x0A4180
        elseif PatchVersion == "1.27b" then
                set pAddCModelFrameModel    = pGameDLL + 0x0F7D00
                set pGetCModelFrameHeight   = pGameDLL + 0x0F7EE0
        elseif PatchVersion == "1.28f" then
                set pAddCModelFrameModel    = pGameDLL + 0x126370
                set pGetCModelFrameHeight   = pGameDLL + 0x126550
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackCModelFrameAPI takes nothing returns nothing
    //set gg_trg_MemHackCModelFrameAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCSimpleButtonAPI
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCSimpleButtonAPI
    globals
        integer pCreateCSimpleButton            = 0
        integer pSetCSimpleButtonState          = 0
        integer pSetCSimpleButtonStateTexture   = 0
    endglobals

    function CreateCSimpleButton takes integer pParent returns integer
        local integer baseobj = 0

        if pCreateCSimpleButton > 0 then
            set baseobj = StormAllocateMemory( 0x168, "", 0, 0 )

            if baseobj > 0 then
                return this_call_2( pCreateCSimpleButton, baseobj, pParent )
            endif
        endif

        return 0
    endfunction

    function DestroyCSimpleButton takes integer pButton returns boolean
        if pButton > 0 then
            return this_call_2( ReadRealMemory( pButton + 0x8 ), pButton, 1 ) > 0
        endif

        return false
    endfunction
    
    function SetCSimpleButtonStateTexture takes integer pButton, integer state, string texturepath returns boolean
        if pSetCSimpleButtonStateTexture > 0 then
            if pButton > 0 then
                return this_call_3( pSetCSimpleButtonStateTexture, pButton, state, GetStringAddress( texturepath ) ) > 0
            endif
        endif

        return false
    endfunction

    function SetCSimpleButtonState takes integer pButton, integer state returns boolean
        if pSetCSimpleButtonState > 0 then
            if pButton > 0 then
                return this_call_2( pSetCSimpleButtonState, pButton, state ) > 0
            endif
        endif

        return false
    endfunction

    function Init_MemHackCSimpleButtonAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pCreateCSimpleButton            = pGameDLL + 0x603880
                set pSetCSimpleButtonState          = pGameDLL + 0x603780
                set pSetCSimpleButtonStateTexture   = pGameDLL + 0x6039C0
        elseif PatchVersion == "1.26a" then
                set pCreateCSimpleButton            = pGameDLL + 0x6030E0
                set pSetCSimpleButtonState          = pGameDLL + 0x602FE0
                set pSetCSimpleButtonStateTexture   = pGameDLL + 0x603220
        elseif PatchVersion == "1.27a" then
                set pCreateCSimpleButton            = pGameDLL + 0x0BB2A0
                set pSetCSimpleButtonState          = pGameDLL + 0x0BB4E0
                set pSetCSimpleButtonStateTexture   = pGameDLL + 0x0BBA40
        elseif PatchVersion == "1.27b" then
                set pCreateCSimpleButton            = pGameDLL + 0x3A1620
                set pSetCSimpleButtonState          = pGameDLL + 0x10F240
                set pSetCSimpleButtonStateTexture   = pGameDLL + 0x10F7A0
        elseif PatchVersion == "1.28f" then
                set pCreateCSimpleButton            = pGameDLL + 0x3D5730
                set pSetCSimpleButtonState          = pGameDLL + 0x13D770
                set pSetCSimpleButtonStateTexture   = pGameDLL + 0x13DCD0
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackCSimpleButtonAPI takes nothing returns nothing
    //set gg_trg_MemHackCSimpleButtonAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCSimpleFontAPI
//===========================================================================
//TESH.scrollpos=6
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCSimpleFontAPI
    globals
        integer pCreateCSimpleFont          = 0
        integer pGetCSimpleFontByName       = 0
        integer pSetCSimpleFontText         = 0
        integer pSetCSimpleFontStringScale  = 0
        integer pSetCSimpleFontStringFont   = 0
        integer pGetCSimpleFontStringHeight = 0
    endglobals

    function CreateCSimpleFont takes integer pParent returns integer
        local integer baseobj = 0

        if pCreateCSimpleFont > 0 then
            set baseobj = StormAllocateMemory( 0xC4, "", 0, 0 )

            if baseobj > 0 then
                return this_call_4( pCreateCSimpleFont, baseobj, pParent, 2, 1 )
            endif
        endif

        return 0
    endfunction

    function GetCSimpleFontByName takes string name, integer id returns integer
        if pGetCSimpleFontByName > 0 then
            if name != "" then
                return fast_call_2( pGetCSimpleFontByName, GetStringAddress( name ), id )
            endif
        endif

        return 0
    endfunction

    function GetCSimpleFontTextByName takes string name, integer id returns string
        local integer pFrame = GetCSimpleFontByName( name, id )

        // GetFrameTextMaxLength = 0x94
        // GetFrameTextLength = 0x98
        if pFrame > 0 then
            return ToJString( ReadRealMemory( pFrame + 0x9C ) )
        endif

        return ""
    endfunction

    function SetCSimpleFontStringScale takes integer pFrame, real scale returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCSimpleFontStringScale > 0 then
            if fid == 19 then
                return this_call_2( pSetCSimpleFontStringScale, pFrame, SetRealIntoMemory( scale ) )
            endif
        endif

        return 0
    endfunction

    function SetCSimpleFontStringFont takes integer pFrame, string filename, real height, integer flag returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCSimpleFontStringFont > 0 then
            if fid == 19 then
                return this_call_4( pSetCSimpleFontStringFont, pFrame, GetStringAddress( filename ), SetRealIntoMemory( height ), flag )
            endif
        endif

        return 0
    endfunction

    function GetCSimpleFontStringHeight takes integer pFrame returns real
        local integer fid = GetFrameType( pFrame )

        if pGetCSimpleFontStringHeight > 0 then
            if fid == 19 then
                return GetRealFromMemory( this_call_1( pGetCSimpleFontStringHeight, pFrame ) )
            endif
        endif

        return 0.
    endfunction

    function SetCSimpleFontText takes integer pFrame, string text returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCSimpleFontText > 0 then
            if fid == 19 then
                return B2I( this_call_2( pSetCSimpleFontText, pFrame, GetStringAddress( text ) ) > 0 )
            endif
        endif

        return 0
    endfunction

    function Init_MemHackCSimpleFontAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pCreateCSimpleFont          = pGameDLL + 0x60DD20
                set pGetCSimpleFontByName       = pGameDLL + 0x61CF50
                set pSetCSimpleFontText         = pGameDLL + 0x60D1B0
                set pSetCSimpleFontStringFont   = pGameDLL + 0x60E1C0
                set pGetCSimpleFontStringHeight = pGameDLL + 0x60D710
                set pSetCSimpleFontStringScale  = pGameDLL + 0x60E470
        elseif PatchVersion == "1.26a" then
                set pCreateCSimpleFont          = pGameDLL + 0x60D580
                set pGetCSimpleFontByName       = pGameDLL + 0x61C7B0
                set pSetCSimpleFontText         = pGameDLL + 0x60CA10
                set pSetCSimpleFontStringFont   = pGameDLL + 0x60DA20
                set pGetCSimpleFontStringHeight = pGameDLL + 0x60CF70
                set pSetCSimpleFontStringScale  = pGameDLL + 0x60DCD0
        elseif PatchVersion == "1.27a" then
                set pCreateCSimpleFont          = pGameDLL + 0x0BFB10
                set pGetCSimpleFontByName       = pGameDLL + 0x0C8EF0
                set pSetCSimpleFontText         = pGameDLL + 0x0C1020
                set pSetCSimpleFontStringFont   = pGameDLL + 0x0C0B40
                set pGetCSimpleFontStringHeight = pGameDLL + 0x0C0490
                set pSetCSimpleFontStringScale  = pGameDLL + 0x0C0D90
        elseif PatchVersion == "1.27b" then
                set pCreateCSimpleFont          = pGameDLL + 0x113870
                set pGetCSimpleFontByName       = pGameDLL + 0x11CC50
                set pSetCSimpleFontText         = pGameDLL + 0x114D80
                set pSetCSimpleFontStringFont   = pGameDLL + 0x1148A0
                set pGetCSimpleFontStringHeight = pGameDLL + 0x1141F0
                set pSetCSimpleFontStringScale  = pGameDLL + 0x114AF0
        elseif PatchVersion == "1.28f" then
                set pCreateCSimpleFont          = pGameDLL + 0x141F20
                set pGetCSimpleFontByName       = pGameDLL + 0x14B300
                set pSetCSimpleFontText         = pGameDLL + 0x143430
                set pSetCSimpleFontStringFont   = pGameDLL + 0x142F50
                set pGetCSimpleFontStringHeight = pGameDLL + 0x1428A0
                set pSetCSimpleFontStringScale  = pGameDLL + 0x1431A0
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackCSimpleFontAPI takes nothing returns nothing
    //set gg_trg_MemHackCSimpleFontAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCSimpleGlueAPI
//===========================================================================
//TESH.scrollpos=12
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCSimpleGlueAPI
    globals
        integer pSetCSimpleGlueFrameScale = 0
    endglobals

    function SetCSimpleGlueFrameScale takes integer pFrame, real scale returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCSimpleGlueFrameScale > 0 then
            if fid == 21 then
                return this_call_2( pSetCSimpleGlueFrameScale, pFrame, SetRealIntoMemory( scale ) )
            endif
        endif

        return 0
    endfunction

    function Init_MemHackCSimpleGlueAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pSetCSimpleGlueFrameScale = pGameDLL + 0x617270
        elseif PatchVersion == "1.26a" then
                set pSetCSimpleGlueFrameScale = pGameDLL + 0x616AD0
        elseif PatchVersion == "1.27a" then
                set pSetCSimpleGlueFrameScale = pGameDLL + 0x0C19C0 // (*(int (__stdcall **)(float))(*(_DWORD *)(v2[73]
        elseif PatchVersion == "1.27b" then
                set pSetCSimpleGlueFrameScale = pGameDLL + 0x115720
        elseif PatchVersion == "1.28f" then
                set pSetCSimpleGlueFrameScale = pGameDLL + 0x143DD0
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackCSimpleGlueAPI takes nothing returns nothing
    //set gg_trg_MemHackCSimpleGlueAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCSimpleFrameAPI
//===========================================================================
//TESH.scrollpos=9
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCSimpleFrameAPI
    globals
        integer pGetCSimpleFrameByName      = 0
        integer pCreateCSimpleFrame         = 0
        integer pCreateCSimpleConsole       = 0
        integer pSetCSimpleFrameScale       = 0
        integer pSetCSimpleFramePriority    = 0
        integer pSetCSimpleFrameParent      = 0
    endglobals

    function CreateCSimpleFrame takes integer pParent returns integer
        local integer baseobj = 0

        if pCreateCSimpleFrame > 0 then
            set baseobj = StormAllocateMemory( 0x124, "", 0, 0 )

            if baseobj > 0 then
                return this_call_2( pCreateCSimpleFrame, baseobj, pParent )
            endif
        endif

        return 0
    endfunction
    
    function CreateCSimpleConsole takes string baseCSimpleConsole, integer parent, integer id returns integer
        if pCreateCSimpleConsole > 0 then
            if baseCSimpleConsole != "" then
                return fast_call_3( pCreateCSimpleConsole, GetStringAddress( baseCSimpleConsole ), parent, id )
            endif
        endif

        return 0
    endfunction

    function GetCSimpleFrameByName takes string name, integer id returns integer
        if pGetCSimpleFrameByName > 0 then
            if name != "" then
                return fast_call_2( pGetCSimpleFrameByName, GetStringAddress( name ), id )
            endif
        endif

        return 0
    endfunction

    function SetCSimpleFrameScale takes integer pCSimpleFrame, real scale returns integer
        local integer fid = GetFrameType( pCSimpleFrame )

        if pSetCSimpleFrameScale > 0 then
            if fid == 22 or fid == 23 or fid == 39 then
                return this_call_2( pSetCSimpleFrameScale, pCSimpleFrame, SetRealIntoMemory( scale ) )
            endif
        endif

        return 0
    endfunction

    function SetCSimpleFramePriority takes integer pCSimpleFrame, integer priority returns integer
        local integer fid = GetFrameType( pCSimpleFrame )

        if pSetCSimpleFramePriority > 0 then
            if fid > 0 then
                if IsFrameLayout( pCSimpleFrame ) then
                    return this_call_2( pSetCSimpleFramePriority, pCSimpleFrame, priority )
                else
                    call WriteRealMemory( pCSimpleFrame + 0xA8, priority ) // if 1.29+ then 0xB0
                    return 1
                endif
            endif
        endif

        return 0
    endfunction

    function SetCSimpleFrameParent takes integer pCSimpleFrame, integer pParentCSimpleFrame returns integer
        if pSetCSimpleFrameParent > 0 then
            if IsFrameLayout( pCSimpleFrame ) and IsFrameLayout( pParentCSimpleFrame ) then
                return this_call_2( pSetCSimpleFrameParent, pCSimpleFrame, pParentCSimpleFrame  )
            endif
        endif

        return 0
    endfunction

    function Init_MemHackCSimpleFrameAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pCreateCSimpleConsole       = pGameDLL + 0x5C9DB0
                set pCreateCSimpleFrame         = pGameDLL + 0x60A410
                set pGetCSimpleFrameByName      = pGameDLL + 0x61CF10
                set pSetCSimpleFrameScale       = pGameDLL + 0x60A1C0
                set pSetCSimpleFramePriority    = pGameDLL + 0x2F64F0
                set pSetCSimpleFrameParent      = pGameDLL + 0x60A120
        elseif PatchVersion == "1.26a" then
                set pCreateCSimpleConsole       = pGameDLL + 0x5C9610
                set pCreateCSimpleFrame         = pGameDLL + 0x609C70
                set pGetCSimpleFrameByName      = pGameDLL + 0x61C770
                set pSetCSimpleFrameScale       = pGameDLL + 0x609A20
                set pSetCSimpleFramePriority    = pGameDLL + 0x2F59B0
                set pSetCSimpleFrameParent      = pGameDLL + 0x609980
        elseif PatchVersion == "1.27a" then
                set pCreateCSimpleConsole       = pGameDLL + 0x090A60
                set pCreateCSimpleFrame         = pGameDLL + 0x0B8C00
                set pGetCSimpleFrameByName      = pGameDLL + 0x0C8FD0
                set pSetCSimpleFrameScale       = pGameDLL + 0x0B9FA0
                set pSetCSimpleFramePriority    = pGameDLL + 0x356430
                set pSetCSimpleFrameParent      = pGameDLL + 0x0BA040
        elseif PatchVersion == "1.27b" then
                set pCreateCSimpleConsole       = pGameDLL + 0x0E47E0
                set pCreateCSimpleFrame         = pGameDLL + 0x10C960
                set pGetCSimpleFrameByName      = pGameDLL + 0x11CD30
                set pSetCSimpleFrameScale       = pGameDLL + 0x10DD00
                set pSetCSimpleFramePriority    = pGameDLL + 0x373BD0
                set pSetCSimpleFrameParent      = pGameDLL + 0x10DDA0
        elseif PatchVersion == "1.28f" then
                set pCreateCSimpleConsole       = pGameDLL + 0x112E30
                set pCreateCSimpleFrame         = pGameDLL + 0x13AE90
                set pGetCSimpleFrameByName      = pGameDLL + 0x14B3E0
                set pSetCSimpleFrameScale       = pGameDLL + 0x13C230
                set pSetCSimpleFramePriority    = pGameDLL + 0x3A7CA0
                set pSetCSimpleFrameParent      = pGameDLL + 0x13C2D0
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackCSimpleFrameAPI takes nothing returns nothing
    //set gg_trg_MemHackCSimpleFrameAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCSimpleMessageFrameAPI
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCSimpleMessageFrameAPI
    globals
        integer pSetCSimpleMessageFrameFont = 0
    endglobals

    function SetCSimpleMessageFrameFont takes integer pFrame, string filename, real height, integer flag returns integer
        local integer fid = GetFrameType( pFrame )
        
        if pSetCSimpleMessageFrameFont > 0 then
            if fid == 23 then
                return this_call_4( pSetCSimpleMessageFrameFont, pFrame, GetStringAddress( filename ), SetRealIntoMemory( height ), flag )
            endif
        endif

        return 0
    endfunction

    function Init_MemHackCSimpleMessageFrameAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pSetCSimpleMessageFrameFont = pGameDLL + 0x6042B0
        elseif PatchVersion == "1.26a" then
                set pSetCSimpleMessageFrameFont = pGameDLL + 0x603B10
        elseif PatchVersion == "1.27a" then
                set pSetCSimpleMessageFrameFont = pGameDLL + 0x0C2E80 // "CSimpleMessageFrame.cpp", 54, 0);
        elseif PatchVersion == "1.27b" then
                set pSetCSimpleMessageFrameFont = pGameDLL + 0x116BE0
        elseif PatchVersion == "1.28f" then
                set pSetCSimpleMessageFrameFont = pGameDLL + 0x145290
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackCSimpleMessageFrameAPI takes nothing returns nothing
    //set gg_trg_MemHackCSimpleMessageFrameAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCSliderAPI
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCSliderAPI
    globals
        integer pSetCSliderCurrentValue = 0
    endglobals

    function SetCSliderCurrentValue takes integer pFrame, real value returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCSliderCurrentValue > 0 then 
            if fid == 24 then
                return this_call_3( pSetCSliderCurrentValue, pFrame, SetRealIntoMemory( value ), 1 )
            endif
        endif

        return 0
    endfunction

    function Init_MemHackCSliderAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pSetCSliderCurrentValue = pGameDLL + 0x61F610
        elseif PatchVersion == "1.26a" then
                set pSetCSliderCurrentValue = pGameDLL + 0x61EE70
        elseif PatchVersion == "1.27a" then
                set pSetCSliderCurrentValue = pGameDLL + 0x0AB3B0
        elseif PatchVersion == "1.27b" then
                set pSetCSliderCurrentValue = pGameDLL + 0x0FF110
        elseif PatchVersion == "1.28f" then
                set pSetCSliderCurrentValue = pGameDLL + 0x12D780
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackCSliderAPI takes nothing returns nothing
    //set gg_trg_MemHackCSliderAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCSpriteFrameAPI
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCSpriteFrameAPI
    globals
        integer pSetCSpriteFrameArt      = 0
        integer pGetCSpriteFrameHeight   = 0
        integer pSetCSpriteFrameScale    = 0
    endglobals

    function SetCSpriteFrameArt takes integer pFrame, string model, integer modeltype, boolean flag returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCSpriteFrameArt > 0 then
            if fid == 25 then
                return this_call_4( pSetCSpriteFrameArt, pFrame, GetStringAddress( model ), modeltype, B2I( flag ) )
            endif
        endif

        return 0
    endfunction

    function GetCSpriteFrameHeight takes integer pFrame returns real
        local integer fid = GetFrameType( pFrame )

        if pGetCSpriteFrameHeight > 0 then
            if fid == 25 then
                return GetRealFromMemory( this_call_1( pGetCSpriteFrameHeight, pFrame ) )
            endif
        endif

        return 0.
    endfunction

    function SetCSpriteFrameScale takes integer pFrame, real scale returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCSpriteFrameScale > 0 then
            if fid == 25 then
                return this_call_2( pSetCSpriteFrameScale, pFrame, SetRealIntoMemory( scale ) )
            endif
        endif

        return 0
    endfunction

    function Init_MemHackCSpriteFrameAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pSetCSpriteFrameArt       = pGameDLL + 0x60FB00
                set pGetCSpriteFrameHeight    = pGameDLL + 0x60F2A0
                set pSetCSpriteFrameScale     = pGameDLL + 0x60F600
        elseif PatchVersion == "1.26a" then
                set pSetCSpriteFrameArt       = pGameDLL + 0x60F360
                set pGetCSpriteFrameHeight    = pGameDLL + 0x60EB00
                set pSetCSpriteFrameScale     = pGameDLL + 0x60EE60
        elseif PatchVersion == "1.27a" then
                set pSetCSpriteFrameArt       = pGameDLL + 0x0A38C0
                set pGetCSpriteFrameHeight    = pGameDLL + 0x0A3260
                set pSetCSpriteFrameScale     = pGameDLL + 0x0A39A0
        elseif PatchVersion == "1.27b" then
                set pSetCSpriteFrameArt        = pGameDLL + 0x0F7620
                set pGetCSpriteFrameHeight    = pGameDLL + 0x0F6FC0
                set pSetCSpriteFrameScale     = pGameDLL + 0x0F7700
        elseif PatchVersion == "1.28f" then
                set pSetCSpriteFrameArt       = pGameDLL + 0x125C90
                set pGetCSpriteFrameHeight    = pGameDLL + 0x125630
                set pSetCSpriteFrameScale     = pGameDLL + 0x125D70
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackCSpriteFrameAPI takes nothing returns nothing
    //set gg_trg_MemHackCSpriteFrameAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCTextAreaAPI
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCTextAreaAPI
    globals
        integer pSetCTextAreaText   = 0
    endglobals

    function SetCTextAreaText takes integer pFrame, string text returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCTextAreaText > 0 then
            if fid == 27 then
                return B2I( this_call_2( pSetCTextAreaText, pFrame, GetStringAddress( text ) ) > 0 )
            endif
        endif

        return 0
    endfunction

    function Init_MemHackCTextAreaAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pSetCTextAreaText   = pGameDLL + 0x61E830
        elseif PatchVersion == "1.26a" then
                set pSetCTextAreaText   = pGameDLL + 0x61E090
        elseif PatchVersion == "1.27a" then
                set pSetCTextAreaText   = pGameDLL + 0x0B6500 // "QUESTNOTDISCOVERED", &v14,
        elseif PatchVersion == "1.27b" then
                set pSetCTextAreaText   = pGameDLL + 0x10A260
        elseif PatchVersion == "1.28f" then
                set pSetCTextAreaText   = pGameDLL + 0x138790
            endif
        endif
    endfunction
endlibrary
//! endnocjass

//===========================================================================
function InitTrig_MemHackCTextAreaAPI takes nothing returns nothing
    //set gg_trg_MemHackCTextAreaAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCTextFrameAPI
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCTextFrameAPI
    globals
        integer pGetCTextFrameHeight        = 0
        integer pSetCTextFrameText          = 0
        integer pSetCTextFrameTextColour    = 0
    endglobals

    function SetCTextFrameTextColour takes integer pFrame, integer colour returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCTextFrameTextColour > 0 then
            if fid == 6 or fid == 29 then
                return this_call_2( pSetCTextFrameTextColour, pFrame, colour ) // ARGB colour
            endif
        endif

        return 0
    endfunction

    function SetCTextFrameTextColourEx takes integer pFrame, integer alpha, integer red, integer blue, integer green returns integer
        return SetCTextFrameTextColour( pFrame, CreateInteger1( alpha, red, green, blue ) )
    endfunction

    function GetCTextFrameHeight takes integer pFrame returns real
        local integer fid = GetFrameType( pFrame )

        if pGetCTextFrameHeight > 0 then
            if fid == 29 then
                return GetRealFromMemory( this_call_1( pGetCTextFrameHeight, pFrame ) )
            endif
        endif

        return 0.
    endfunction

    function SetCTextFrameText takes integer pFrame, string text returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCTextFrameText > 0 then
            if fid == 28 or fid == 33 or fid == 29 or fid == 38 then
                if fid == 28 or fid == 33 then
                    // if 1.29.2+ then 0x1F4
                    set pFrame = ReadRealMemory( pFrame + 0x1E4 )
                endif

                return B2I( this_call_2( pSetCTextFrameText, pFrame, GetStringAddress( text ) ) > 0 )
            endif
        endif

        return 0
    endfunction

    function Init_MemHackCTextFrameAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pGetCTextFrameHeight        = pGameDLL + 0x612040
                set pSetCTextFrameText          = pGameDLL + 0x6124E0
                set pSetCTextFrameTextColour    = pGameDLL + 0x611D30
        elseif PatchVersion == "1.26a" then
                set pGetCTextFrameHeight        = pGameDLL + 0x6118A0
                set pSetCTextFrameText          = pGameDLL + 0x611D40
                set pSetCTextFrameTextColour    = pGameDLL + 0x611590
        elseif PatchVersion == "1.27a" then
                set pGetCTextFrameHeight        = pGameDLL + 0x0A9770
                set pSetCTextFrameText          = pGameDLL + 0x0AA130
                set pSetCTextFrameTextColour    = pGameDLL + 0x0AA210
        elseif PatchVersion == "1.27b" then
                set pGetCTextFrameHeight        = pGameDLL + 0x0FD4D0
                set pSetCTextFrameText          = pGameDLL + 0x0FDE90
                set pSetCTextFrameTextColour    = pGameDLL + 0x0FDF70
        elseif PatchVersion == "1.28f" then
                set pGetCTextFrameHeight        = pGameDLL + 0x12BB40
                set pSetCTextFrameText          = pGameDLL + 0x12C500
                set pSetCTextFrameTextColour    = pGameDLL + 0x12C5E0
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackCTextFrameAPI takes nothing returns nothing
    //set gg_trg_MemHackCTextFrameAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCSimpleStatusBarAPI
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCSimpleStatusBarAPI
    globals
        integer pSetCSimpleStatusBarTexture     = 0
        integer pSetCSimpleStatusBarValue       = 0
        integer pSetCSimpleStatusBarMinMaxValue = 0
    endglobals

    function SetCSimpleStatusBarTexture takes integer pFrame, string texturepath, boolean flag returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCSimpleStatusBarTexture > 0 then
            if fid == 39 then
                return this_call_3( pSetCSimpleStatusBarTexture, pFrame, GetStringAddress( texturepath ), B2I( flag ) )
            endif
        endif

        return 0
    endfunction

    function SetCSimpleStatusBarValue takes integer pFrame, real value returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCSimpleStatusBarValue > 0 then
            if fid == 39 then
                return this_call_2( pSetCSimpleStatusBarValue, pFrame, SetRealIntoMemory( value ) )
            endif
        endif

        return 0
    endfunction

    function SetCSimpleStatusBarMinMaxValue takes integer pFrame, real minval, real maxval returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCSimpleStatusBarMinMaxValue > 0 then
            if fid == 39 then
                return this_call_3( pSetCSimpleStatusBarMinMaxValue, pFrame, SetRealIntoMemory( minval ), SetRealIntoMemory( maxval ) )
            endif
        endif

        return 0
    endfunction

    function Init_MemHackCSimpleStatusBarAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pSetCSimpleStatusBarTexture     = pGameDLL + 0x60EDB0
                set pSetCSimpleStatusBarValue       = pGameDLL + 0x60EBD0
                set pSetCSimpleStatusBarMinMaxValue = pGameDLL + 0x60EB50
        elseif PatchVersion == "1.26a" then
                set pSetCSimpleStatusBarTexture     = pGameDLL + 0x60E610
                set pSetCSimpleStatusBarValue       = pGameDLL + 0x60E430
                set pSetCSimpleStatusBarMinMaxValue = pGameDLL + 0x60E3B0
        elseif PatchVersion == "1.27a" then
                set pSetCSimpleStatusBarTexture     = pGameDLL + 0x0BC130
                set pSetCSimpleStatusBarValue       = pGameDLL + 0x0BC2E0
                set pSetCSimpleStatusBarMinMaxValue = pGameDLL + 0x0BC270
        elseif PatchVersion == "1.27b" then
                set pSetCSimpleStatusBarTexture     = pGameDLL + 0x10FE90
                set pSetCSimpleStatusBarValue       = pGameDLL + 0x110040
                set pSetCSimpleStatusBarMinMaxValue = pGameDLL + 0x10FFD0
        elseif PatchVersion == "1.28f" then
                set pSetCSimpleStatusBarTexture     = pGameDLL + 0x13E3C0
                set pSetCSimpleStatusBarValue       = pGameDLL + 0x13E570
                set pSetCSimpleStatusBarMinMaxValue = pGameDLL + 0x13E500
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackCSimpleStatusBarAPI takes nothing returns nothing
    //set gg_trg_MemHackCSimpleStatusBarAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCStatusBarAPI
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCStatusBarAPI
    globals
        integer pSetCStatusBarArt           = 0
        integer pSetCStatusBarMinMaxValue   = 0
    endglobals

    function SetCStatusBarArt takes integer pFrame, string model, integer modeltype returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCStatusBarArt > 0 then
            if fid == 40 then
                return this_call_3( pSetCStatusBarArt, pFrame, GetStringAddress( model ), modeltype )
            endif
        endif

        return 0
    endfunction

    function SetCStatusBarValue takes integer pFrame, real value returns integer
        local integer fid  = GetFrameType( pFrame )
        local real minval  = 0.
        local real maxval  = 0.
        local real curval  = 0.
        local real newval  = 0.

        if fid == 40 then // FUNCTION_CStatusBar__SetValue => 1.27a = 0x0AA870
            set minval = GetRealFromMemory( ReadRealMemory( pFrame + 0x1B4 ) )
            set maxval = GetRealFromMemory( ReadRealMemory( pFrame + 0x1B8 ) )
            set curval = GetRealFromMemory( ReadRealMemory( pFrame + 0x1BC ) )

            if value <= minval then
                set value = minval
            endif
            
            call WriteRealMemory( pFrame + 0x1BC, SetRealIntoMemory( value ) )
            return 1
            //return CallThisCallWith2Args( ReadRealMemory( pFrame + 0xEC ), pFrame, 0 ) ?
        endif

        return 0
    endfunction

    function SetCStatusBarMinMaxValue takes integer pFrame, real minval, real maxval returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCStatusBarMinMaxValue > 0 then
            if fid == 40 then
                return this_call_3( pSetCStatusBarMinMaxValue, pFrame, SetRealIntoMemory( minval ), SetRealIntoMemory( maxval ) )
            endif
        endif

        return 0
    endfunction

    function Init_MemHackCStatusBarAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pSetCStatusBarArt           = pGameDLL + 0x628140
                set pSetCStatusBarMinMaxValue   = pGameDLL + 0x627F60
        elseif PatchVersion == "1.26a" then
                set pSetCStatusBarArt           = pGameDLL + 0x6279A0
                set pSetCStatusBarMinMaxValue   = pGameDLL + 0x6277C0
        elseif PatchVersion == "1.27a" then
                set pSetCStatusBarArt           = pGameDLL + 0x0AA760
                set pSetCStatusBarMinMaxValue   = pGameDLL + 0x0AA7F0
        elseif PatchVersion == "1.27b" then
                set pSetCStatusBarArt           = pGameDLL + 0x0FE4C0
                set pSetCStatusBarMinMaxValue   = pGameDLL + 0x0FE550
        elseif PatchVersion == "1.28f" then
                set pSetCStatusBarArt           = pGameDLL + 0x12CB30
                set pSetCStatusBarMinMaxValue   = pGameDLL + 0x12CBC0
            endif
        endif
    endfunction
endlibrary
//! endnocjass

//===========================================================================
function InitTrig_MemHackCStatusBarAPI takes nothing returns nothing
    //set gg_trg_MemHackCStatusBarAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCSimpleTextureAPI
//===========================================================================
//TESH.scrollpos=6
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCSimpleTextureAPI
    globals
        integer pCreateCSimpleTexture       = 0
        integer pFillCSimpleTexture         = 0
        integer pGetCSimpleTextureByName    = 0
        integer pSetCSimpleTextureTexture   = 0
    endglobals

    function CreateCSimpleTexture takes integer pParent returns integer
        local integer baseobj = 0

        if pCreateCSimpleTexture > 0 then
            set baseobj = StormAllocateMemory( 0xE8, "", 0, 0 )

            if baseobj > 0 then
                return this_call_4( pCreateCSimpleTexture, baseobj, pParent, 2, 1 )
            endif
        endif

        return 0
    endfunction

    function FillCSimpleTexture takes integer pFrame, integer colour returns integer
        if pFillCSimpleTexture > 0 then
            call WriteRealMemory( pReservedIntArg1, colour )
            return B2I( this_call_2( pFillCSimpleTexture, pFrame, pReservedIntArg1 ) == 0 )
        endif

        return 0
    endfunction

    function GetCSimpleTextureByName takes string name, integer id returns integer
        if pGetCSimpleTextureByName > 0 then
            if name != "" then
                return fast_call_2( pGetCSimpleTextureByName, GetStringAddress( name ), id )
            endif
        endif

        return 0
    endfunction

    function SetCSimpleTextureTexture takes integer pFrame, string texturepath, boolean flag returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCSimpleTextureTexture > 0 then
            if fid == 64 then
                return this_call_3( pSetCSimpleTextureTexture, pFrame, GetStringAddress( texturepath ), B2I( flag ) )
            endif
        endif

        return 0
    endfunction

    function Init_MemHackCSimpleTextureAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pCreateCSimpleTexture       = pGameDLL + 0x60E0A0
                set pFillCSimpleTexture         = pGameDLL + 0x60DB50
                set pGetCSimpleTextureByName    = pGameDLL + 0x61CF30
                set pSetCSimpleTextureTexture   = pGameDLL + 0x60E830
        elseif PatchVersion == "1.26a" then
                set pCreateCSimpleTexture       = pGameDLL + 0x60D900
                set pFillCSimpleTexture         = pGameDLL + 0x60D3B0
                set pGetCSimpleTextureByName    = pGameDLL + 0x61C790
                set pSetCSimpleTextureTexture   = pGameDLL + 0x60E090
        elseif PatchVersion == "1.27a" then
                set pCreateCSimpleTexture       = pGameDLL + 0x0C90B0
                set pGetCSimpleTextureByName    = pGameDLL + 0x324AD0
                set pFillCSimpleTexture         = pGameDLL + 0x0C1170
                set pSetCSimpleTextureTexture   = pGameDLL + 0x0C11E0
        elseif PatchVersion == "1.27b" then
                set pCreateCSimpleTexture       = pGameDLL + 0x113930
                set pGetCSimpleTextureByName    = pGameDLL + 0x342220
                set pFillCSimpleTexture         = pGameDLL + 0x114ED0
                set pSetCSimpleTextureTexture   = pGameDLL + 0x114F40
        elseif PatchVersion == "1.28f" then
                set pCreateCSimpleTexture       = pGameDLL + 0x141FE0
                set pGetCSimpleTextureByName    = pGameDLL + 0x3761E0
                set pFillCSimpleTexture         = pGameDLL + 0x143580
                set pSetCSimpleTextureTexture   = pGameDLL + 0x1435F0
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackCSimpleTextureAPI takes nothing returns nothing
    //set gg_trg_MemHackCSimpleTextureAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCSimpleRegionAPI
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCSimpleRegionAPI
    globals
        integer pSetCSimpleRegionVertexColour   = 0
    endglobals

    function SetCSimpleRegionVertexColour takes integer pFrame, integer colour returns integer
        local integer fid = GetFrameType( pFrame )

        if pSetCSimpleRegionVertexColour > 0 then
            if fid == 19 or fid == 39 or fid == 64 then
                if fid == 39 then
                    set pFrame = ReadRealMemory( pFrame + 0x134 ) // if 1.29+ then 0x138
                endif

                if pFrame > 0 then
                    call WriteRealMemory( pReservedIntArg1, colour )
                    return this_call_2( pSetCSimpleRegionVertexColour, pFrame, pReservedIntArg1 ) 
                endif
            endif
        endif

        return 0
    endfunction

    function SetCSimpleRegionVertexColourEx takes integer pFrame, integer alpha, integer red, integer blue, integer green returns integer
        return SetCSimpleRegionVertexColour( pFrame, GetARGBColour( alpha, red, blue, green ) )
    endfunction

    function Init_MemHackCSimpleRegionAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pSetCSimpleRegionVertexColour   = pGameDLL + 0x60EEE0
        elseif PatchVersion == "1.26a" then
                set pSetCSimpleRegionVertexColour   = pGameDLL + 0x60E740
        elseif PatchVersion == "1.27a" then
                set pSetCSimpleRegionVertexColour   = pGameDLL + 0x0BFA30
        elseif PatchVersion == "1.27b" then
                set pSetCSimpleRegionVertexColour   = pGameDLL + 0x113790
        elseif PatchVersion == "1.28f" then
                set pSetCSimpleRegionVertexColour   = pGameDLL + 0x141E40
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackCSimpleRegionAPI takes nothing returns nothing
    //set gg_trg_MemHackCSimpleRegionAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackFrameAPI
//===========================================================================
//TESH.scrollpos=109
//TESH.alwaysfold=0
//! nocjass
library MemoryHackFrameAPI
    globals
        integer pTooltipFrame                   = 0
        integer pGetTooltipFrame                = 0
        integer pGetFrameSkinByName             = 0
        integer pDestroyFrame                   = 0
        integer pSetFrameState                  = 0
        integer pClickFrame                     = 0
        integer pUpdateFrame                    = 0

        integer pUnitFramePosition              = 0
        integer pGetUnitFramePosition           = 0
    endglobals

    // Frame API Engine
    function GetFrameByName takes string name, integer id returns integer
        local integer addr = GetCFrameByName( name, id )

        if addr == 0 then
            set addr = GetCSimpleFrameByName( name, id )

            if addr == 0 then
                set addr = GetCSimpleTextureByName( name, id )

                if addr == 0 then
                    set addr = GetCSimpleFontByName( name, id )
                endif
            endif
        endif

        return addr
    endfunction

    function CreateFrameEx takes string baseframe, integer parent, integer point, integer relativepoint, integer id returns integer
        return CreateCFrameEx( baseframe, parent, point, relativepoint, id )
    endfunction

    function CreateFrame takes string baseframe, integer parent, integer id returns integer
        return CreateFrameEx( baseframe, parent, 0, 0, id )
    endfunction

    function CreateSimpleFrame takes integer parent returns integer
        return CreateCSimpleFrame( parent )
    endfunction

    function GetUnitFramePosition takes integer pUnit returns boolean
        if pGetUnitFramePosition > 0 then
            return I2B( fast_call_3( pGetUnitFramePosition, pUnit, pUnitFramePosition, 0 ) )
        endif

        return false
    endfunction
    
    function HideFrame takes integer pFrame returns integer
        return HideCLayer( pFrame )
    endfunction

    function ShowFrame takes integer pFrame returns integer
        return ShowCLayer( pFrame )
    endfunction

    function SetFrameAlpha takes integer pFrame, integer alpha returns integer
        return SetCLayerAlpha( pFrame, alpha )
    endfunction

    function SetLayerFont takes integer pFrame, string filename, real height, integer flag returns integer
        return SetCLayerFont( pFrame, filename, height, flag )
    endfunction

    function SetFrameTooltip takes integer pFrame, integer pTooltip returns integer
        return SetCLayerTooltip( pFrame, pTooltip )
    endfunction

    function SetFrameFocus takes integer pFrame, boolean flag returns integer
        return SetCEditBoxFocus( pFrame, flag )
    endfunction

    function SetFrameCageMouse takes integer pFrame, boolean flag returns integer
        return SetCLayoutFrameCageMouse( pFrame, flag )
    endfunction

    function SetFrameAbsolutePoint takes integer pFrame, integer point, real x, real y returns integer
        local integer fid_1 = GetFrameType( pFrame )

        if fid_1 > 0 then
            set pFrame = GetFrameLayoutByType( pFrame, fid_1 )
            return SetCLayoutFrameAbsolutePoint( pFrame, point, x, y )
        endif

        return 0
    endfunction

    function SetFramePoint takes integer pFrame, integer point, integer pParentFrame, integer relativePoint, real x, real y returns integer
        local integer fid_1 = GetFrameType( pFrame )
        local integer fid_2 = GetFrameType( pParentFrame )

        if fid_1 > 0 and fid_2 > 0 then
            set pFrame = GetFrameLayoutByType( pFrame, fid_1 )
            set pParentFrame = GetFrameLayoutByType( pParentFrame, fid_2 )
            return SetCLayoutFramePoint( pFrame, point, pParentFrame, relativePoint, x, y )
        endif

        return 0
    endfunction

    function ClearFrameAllPoints takes integer pFrame returns integer
        return ClearCLayoutFrameAllPoints( pFrame )
    endfunction

    function SetFrameWidth takes integer pFrame, real width returns integer
        return SetCLayoutFrameWidth( pFrame, width )
    endfunction

    function SetFrameHeight takes integer pFrame, real height returns integer
        return SetCLayoutFrameHeight( pFrame, height )
    endfunction

    function SetFrameAllPoints takes integer pFrame, integer relativeframe returns integer
        return SetCLayoutFrameAllPoints( pFrame, relativeframe )
    endfunction

    function SetFrameSize takes integer pFrame, real width, real height returns integer
        return SetCLayoutFrameSize( pFrame, width, height )
    endfunction

    function SetLayoutFrameScale takes integer pFrame, real scale returns integer
        return SetCLayoutFrameScale( pFrame, scale )
    endfunction

    function SetFrameVertexColour takes integer pFrame, integer colour returns integer
        return SetCSimpleRegionVertexColour( pFrame, colour )
    endfunction

    function SetFrameVertexColourEx takes integer pFrame, integer alpha, integer red, integer blue, integer green returns integer
        return SetCSimpleRegionVertexColourEx( pFrame, alpha, red, blue, green )
    endfunction

    function GetFrameSkinByName takes string name, integer id returns integer
        if pGetFrameSkinByName > 0 then
            if name != "" then
                return fast_call_2( pGetFrameSkinByName, GetStringAddress( name ), id )
            endif
        endif

        return 0
    endfunction

    function DestroyFrame takes integer pFrame returns integer
        if pDestroyFrame > 0 then
            if pFrame > 0 then
                return this_call_2( pDestroyFrame, pFrame, 1 )
            endif
        endif

        return 0
    endfunction

    function GetFrameState takes integer pFrame, integer state returns boolean
        if pFrame > 0 then
            return BitwiseAnd( state, ReadRealMemory( pFrame + 0x1D4 ) ) == state
        endif

        return false
    endfunction
    
    function IsFrameEnabled takes integer pFrame returns boolean
        return GetFrameState( pFrame, 1 )
    endfunction

    function SetFrameState takes integer pFrame, boolean flag returns integer
        if pSetFrameState > 0 then
            if pFrame > 0 then
                return this_call_2( pSetFrameState, pFrame, B2I( flag ) )
            endif
        endif

        return 0
    endfunction

    function EnableFrame takes integer pFrame returns integer
        return SetFrameState( pFrame, true )
    endfunction
    
    function DisableFrame takes integer pFrame returns integer
        return SetFrameState( pFrame, false )
    endfunction

    function GetFrameTextByName takes string name, integer id returns string
        return GetCSimpleFontTextByName( name, id )
    endfunction

    function SetFrameTextColour takes integer pFrame, integer colour returns integer
        return SetCTextFrameTextColour( pFrame, colour )
    endfunction

    function SetFrameTextColourEx takes integer pFrame, integer alpha, integer red, integer blue, integer green returns integer
        return SetCTextFrameTextColourEx( pFrame, alpha, red, green, blue )
    endfunction

    function FindLayerUnderCursor takes nothing returns integer
        return FindCLayerUnderCursor( )
    endfunction

    function ClickFrame takes integer pFrame returns integer
        if pClickFrame > 0 then
            if pFrame > 0 then
                return this_call_2( pClickFrame, pFrame, 1 )
            endif
        endif

        return 0
    endfunction

    function SetFrameModel takes integer pFrame, string model, integer modeltype, boolean flag returns integer
        local integer fid = GetFrameType( pFrame )

        if fid == 15 then
            return AddCModelFrameModel( pFrame, model, modeltype )
        endif

        if fid == 25 then
            return SetCSpriteFrameArt( pFrame, model, modeltype, flag )
        endif

        if fid == 40 then
            return SetCStatusBarArt( pFrame, model, modeltype )
        endif

        return 0
    endfunction

    function GetFrameAlpha takes integer pFrame returns integer
        local integer fid = GetFrameType( pFrame )

        if fid > 0 then
            return ReadRealMemory( pFrame + 0xAC )
        endif

        return 0
    endfunction

    function UpdateFrame takes integer pFrame returns integer
        if pUpdateFrame > 0 then
            if pFrame > 0 then
                return this_call_2( pUpdateFrame, pFrame, 0 )
            endif
        endif

        return 0
    endfunction

    function SetFrameStepValue takes integer pFrame, real step returns nothing
        local integer fid = GetFrameType( pFrame )
        
        if fid == 24 then
            call WriteRealMemory( pFrame + 0x1F8, SetRealIntoMemory( step ) )
        endif
    endfunction

    function GetFrameParent takes integer pFrame returns integer
        local integer fid  = GetFrameType( pFrame )
        local integer pOff = 0

        if fid > 0 then
            if not IsFrameLayout( pFrame ) then
                set pOff = 0x20
            else
                set pOff = 0x68 // if 1.29+ set pOff = 0x70
            endif

            if pOff > 0 then
                return ReadRealMemory( pFrame + pOff )
            endif
        endif

        return 0
    endfunction

    function SetFrameParent takes integer pFrame, integer pParentFrame returns integer
        if GetFrameType( pFrame ) > 0 and GetFrameType( pParentFrame ) > 0 then
            if IsFrameLayout( pFrame ) then
                if IsFrameLayout( pParentFrame ) then
                    return SetCSimpleFrameParent( pFrame, pParentFrame )
                endif
            else
                if IsFrameLayout( pParentFrame ) then
                    return SetCLayerOwner( pFrame, pParentFrame )
                endif
            endif
        endif

        return 0
    endfunction

    function GetFrameName takes integer pFrame returns string
        local integer fid   = GetFrameType( pFrame )
        local integer pText = 0

        if fid > 0 then
            if IsFrameLayout( pFrame ) then
                set pText = pFrame + 0x7C  // if 1.29+  0x80
            else
                set pText = pFrame + 0x160 // if 1.29+ 0x16C
            endif

            if pText > 0 then
                return ToJString( ReadRealMemory( pText ) )
            endif
        endif

        return ""
    endfunction

    function SetFrameTexture takes integer pFrame, string texturepath, boolean flag returns integer
        local integer fid = GetFrameType( pFrame )

        if fid == 1 or fid == 39 or fid == 64 then
            if fid == 1 then
                return SetCBackDropFrameTexture( pFrame, texturepath, flag )
            endif

            if fid == 39 then
                return SetCSimpleStatusBarTexture( pFrame, texturepath, flag )
            endif

            if fid == 64 then
                return SetCSimpleTextureTexture( pFrame, texturepath, flag )
            endif
        endif

        return 0
    endfunction

    function SetFrameScale takes integer pFrame, real scale returns integer
        local integer fid = GetFrameType( pFrame )

        if fid > 0 then
            if fid == 19 or fid == 21 or fid == 22 or fid == 23 or fid == 39 or fid == 25 then
                if fid == 19 then
                    return SetCSimpleFontStringScale( pFrame, scale )
                endif

                if fid == 21 then
                    return SetCSimpleGlueFrameScale( pFrame, scale )
                endif

                if fid == 22 or fid == 23 or fid == 39 then
                    return SetCSimpleFrameScale( pFrame, scale )
                endif

                if fid == 25 then
                    return SetCSpriteFrameScale( pFrame, scale )
                endif
            else
                return SetLayoutFrameScale( pFrame, scale )
            endif
        endif

        return 0
    endfunction
    
    function GetFrameValue takes integer pFrame returns real
        local integer fid  = GetFrameType( pFrame )
        local integer pOff = 0
        
        if fid == 24 or fid == 39 or fid == 40 then
            if fid == 24 then
                set pOff = 0x500 // if 1.29+ 0x516
            endif

            if fid == 39 then
                set pOff = 0x130 // if 1.29+ 0x12C
            endif

            if fid == 40 then
                set pOff = 0x1BC // if 1.29+ 0x1CC
            endif

            if pOff > 0 then
                return GetRealFromMemory( ReadRealMemory( pFrame + pOff ) )
            endif
        endif

        return 0.
    endfunction

    function SetFrameValue takes integer pFrame, real value returns integer
        local integer fid  = GetFrameType( pFrame )

        if fid == 24 or fid == 39 or fid == 40 then
            if fid == 24 then
                return SetCSliderCurrentValue( pFrame, value )
            endif

            if fid == 39 then
                return SetCSimpleStatusBarValue( pFrame, value )
            endif

            if fid == 40 then
                return SetCStatusBarValue( pFrame, value )
            endif
        endif

        return 0
    endfunction

    function SetFrameMinMaxValue takes integer pFrame, real minval, real maxval returns integer
        local integer fid       = GetFrameType( pFrame )
        local real cur_val      = 0.
        local real new_val      = 0.

        if fid == 24 or fid == 39 or fid == 40 then
            if minval < maxval then
                if fid == 24 then
                    call WriteRealMemory( pFrame + 0x1EC, SetRealIntoMemory( minval ) )
                    call WriteRealMemory( pFrame + 0x1F0, SetRealIntoMemory( maxval ) )
                    set cur_val = GetRealFromMemory( ReadRealMemory( pFrame + 0x1F4 ) )

                    if minval <= cur_val then
                        if cur_val > maxval then
                            set new_val = maxval
                        endif
                    else
                        set new_val = minval
                    endif

                    return SetCSliderCurrentValue( pFrame, new_val )
                endif

                if fid == 39 then
                    return SetCSimpleStatusBarMinMaxValue( pFrame, minval, maxval )
                endif

                if fid == 40 then
                    return SetCStatusBarMinMaxValue( pFrame, minval, maxval )
                endif
            endif
        endif

        return 0
    endfunction
    //===========================================

    // Frame Point API Engine
    function SetFrameFont takes integer pFrame, string filename, real height, integer flag returns integer
        local integer fid = GetFrameType( pFrame )
        
        if fid == 6 or fid == 19 or fid == 23 then
            if fid == 6 then
                return SetCEditBoxFont( pFrame, filename, height, flag )
            endif

            if fid == 19 then
                return SetCSimpleFontStringFont( pFrame, filename, height, flag )
            endif

            if fid == 23 then
                return SetCSimpleMessageFrameFont( pFrame, filename, height, flag )
            endif
        else
            if not IsFrameLayoutByType( pFrame, fid ) then
                return SetLayerFont( pFrame, filename, height, flag )
            endif
        endif

        return 0
    endfunction
    
    function GetFrameWidth takes integer pFrame returns real
        local integer fid = GetFrameType( pFrame )

        if fid > 0 then
            return GetRealFromMemory( ReadRealMemory( pFrame + 0x58 ) )
        endif

        return 0.
    endfunction

    function GetFrameHeight takes integer pFrame returns real
        local integer fid = GetFrameType( pFrame )

        if fid == 15 or fid == 19 or fid == 25 or fid == 29 then
            if fid == 15 then
                return GetCModelFrameHeight( pFrame )
            endif

            if fid == 19 then
                return GetCSimpleFontStringHeight( pFrame )
            endif

            if fid == 25 then
                return GetCSpriteFrameHeight( pFrame )
            endif

            if fid == 29 then
                return GetCTextFrameHeight( pFrame )
            endif
            // return GetRealFromMemory( ReadRealMemory( pFrame + 0x5C ) )
        else
            return GetCLayoutFrameHeight( pFrame )
        endif

        return 0.
    endfunction

    function GetFramePoint takes integer pFrame, integer point returns integer
        local integer fid = GetFrameType( pFrame )

        if fid > 0 then
            return ReadRealMemory( pFrame + 0x4 * point + 0x8 )
        endif

        return 0
    endfunction

    // Frame Absolute Point API
    function GetFrameAbsolutePoint takes integer pFrame, integer point returns integer
        return GetFramePoint( pFrame, point )
    endfunction
    
    function GetFrameAbsolutePointX takes integer pFrame, integer point returns real
        local integer pFramePoint = GetFramePoint( pFrame, point )

        if pFramePoint > 0 then
            return GetRealFromMemory( ReadRealMemory( pFramePoint + 0x4 ) )
        endif

        return 0.
    endfunction

    function GetFrameAbsolutePointY takes integer pFrame, integer point returns real
        local integer pFramePoint = GetFramePoint( pFrame, point )

        if pFramePoint > 0 then
            return GetRealFromMemory( ReadRealMemory( pFramePoint + 0x8 ) )
        endif

        return 0.
    endfunction
    //===========================================

    // Frame Relative Point API
    function GetFrameRelativePoint takes integer pFrame, integer point returns integer
        return GetFramePoint( pFrame, point )
    endfunction

    function GetFrameRelativePointParent takes integer pFrame, integer point returns integer
        local integer pFramePoint = GetFramePoint( pFrame, point )

        if pFramePoint > 0 then
            return ReadRealMemory( pFramePoint + 0x4 )
        endif

        return 0
    endfunction

    function GetFramePointRelativePoint takes integer pFrame, integer point returns integer
        local integer pFramePoint = GetFramePoint( pFrame, point )

        if pFramePoint > 0 then
            return ReadRealMemory( pFramePoint + 0x8 )
        endif

        return 0
    endfunction

    function GetFrameRelativePointX takes integer pFrame, integer point returns real
        local integer pFramePoint = GetFramePoint( pFrame, point )

        if pFramePoint > 0 then
            return GetRealFromMemory( ReadRealMemory( pFramePoint + 0xC ) )
        endif

        return 0.
    endfunction

    function GetFrameRelativePointY takes integer pFrame, integer point returns real
        local integer pFramePoint = GetFramePoint( pFrame, point )

        if pFramePoint > 0 then
            return GetRealFromMemory( ReadRealMemory( pFramePoint + 0x10 ) )
        endif

        return 0.
    endfunction
    //===========================================

    //===========================================

    // Frame Text API Engine
    function GetFrameTextMaxLength takes integer pFrame returns integer
        local integer frameId = GetFrameType( pFrame )

        if frameId == 6 then
            return ReadRealMemory( pFrame + 0x1F0 )
        endif

        return 0
    endfunction

    function SetFrameMaxTextLength takes integer pFrame, integer length returns nothing
        local integer frameId = GetFrameType( pFrame )

        if frameId == 6 then
            call WriteRealMemory( pFrame + 0x1F0, length )
        endif
    endfunction

    function GetFrameTextLength takes integer pFrame returns integer
        local integer fid = GetFrameType( pFrame )

        if fid == 6 then
            return ReadRealMemory( pFrame + 0x1F4 )
        endif

        return 0
    endfunction

    function GetFrameText takes integer pFrame returns string
        local integer fid        = GetFrameType( pFrame )
        local integer pFrameText = 0

        if fid > 0 then
            if fid == 6 then
                set pFrameText = ReadRealMemory( pFrame + 0x1E4 )
            endif

            if fid == 19 then
                set pFrameText = ReadRealMemory( pFrame + 0x01C )
            endif

            if fid == 27 then
                set pFrameText = ReadRealMemory( pFrame + 0x230 )
            endif

            if fid == 29 then
                set pFrameText = ReadRealMemory( pFrame + 0x1E8 )
            endif

            if pFrameText > 0 then
                return ToJString( pFrameText )
            endif
        endif

        return ""
    endfunction

    function SetFrameText takes integer pFrame, string text returns integer
        local integer fid = GetFrameType( pFrame )

        if fid > 0 then
            if fid == 6 or fid == 36 or fid == 37 then
                return SetCEditBoxText( pFrame, text )
            endif

            if fid == 19 then
                return SetCSimpleFontText( pFrame, text )
            endif

            if fid == 27 then
                return SetCTextAreaText( pFrame, text )
            endif

            if fid == 28 or fid == 33 or fid == 29 or fid == 38 then
                return SetCTextFrameText( pFrame, text )
            endif
        endif

        return 0
    endfunction
    //===========================================

    function IsReplay takes nothing returns boolean
        return GetCFrameByName( "ReplayVisionMenu", 0 ) != 0
    endfunction

    function SetAllyCheckbox takes integer mode returns nothing
        local integer i = 0
        local integer pAllyCheckBoxAddr

        loop
            exitwhen i > 11
            set pAllyCheckBoxAddr = GetCFrameByName( "UnitsCheckBox", i )

            if pAllyCheckBoxAddr > 0 then
                set pAllyCheckBoxAddr = pAllyCheckBoxAddr + 0x1D4

                if BitwiseAnd( ReadRealMemory( pAllyCheckBoxAddr ), mode ) == 0 then // BitwiseAnd( ReadRealMemory( pAllyCheckBoxAddr ), 1 ) == 0
                    call WriteRealMemory( pAllyCheckBoxAddr, BitwiseOr( ReadRealMemory( pAllyCheckBoxAddr ), mode ) )
                endif
            endif

            set i = i + 1
        endloop
    endfunction

    function EnableAllyCheckbox takes nothing returns nothing
        call SetAllyCheckbox( 1 )
    endfunction

    function DisableAllyCheckbox takes nothing returns nothing
        call SetAllyCheckbox( 0 )
    endfunction

    function DisableSaveGameMenu takes nothing returns nothing
        // SaveButton frame and menu are not rendered in the first seconds of init.
        // Thus, this function MUST be called with a delay after map init.
        local integer pSaveGameSaveButton = GetCFrameByName( "SaveGameFileEditBox" , 0 )

        if pSaveGameSaveButton > 0 then
            call WriteRealMemory( pSaveGameSaveButton + 0x1D4, 0)
            call WriteRealMemory( pSaveGameSaveButton + 0x108, 0)
            call WriteRealMemory( pSaveGameSaveButton + 0x1E8, 0)
            
            set pSaveGameSaveButton = GetCFrameByName( "FileListFrame", 0 )
            if pSaveGameSaveButton > 0 then
                call WriteRealMemory( pSaveGameSaveButton + 0x10C, 0x3B03123E )
            endif
        endif
    endfunction
    
    function Init_MemHackFrameAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pGetTooltipFrame                = pGameDLL + 0x337D80
                set pGetFrameSkinByName             = pGameDLL + 0x320070
                set pDestroyFrame                   = pGameDLL + 0x6070B0
                set pSetFrameState                  = pGameDLL + 0x602580
                set pClickFrame                     = pGameDLL + 0x6026C0
                set pUpdateFrame                    = pGameDLL + 0x606460
                set pGetUnitFramePosition           = pGameDLL + 0x334CC0
        elseif PatchVersion == "1.26a" then
                set pGetTooltipFrame                = pGameDLL + 0x337240
                set pGetFrameSkinByName             = pGameDLL + 0x31F530
                set pDestroyFrame                   = pGameDLL + 0x606910 // DestroyCFrame
                set pSetFrameState                  = pGameDLL + 0x336C20 // SetCControlState
                set pClickFrame                     = pGameDLL + 0x601F20
                set pUpdateFrame                    = pGameDLL + 0x605CC0 // UpdateCLayout
                set pGetUnitFramePosition           = pGameDLL + 0x334180 // GetCAgentScreenAxis
        elseif PatchVersion == "1.27a" then
                set pGetTooltipFrame                = pGameDLL + 0x399720 // under if ( v2[109] || !*(_DWORD *)(v5 + 464) )
                set pGetFrameSkinByName             = pGameDLL + 0x324AD0
                set pDestroyFrame                   = pGameDLL + 0x0A1870
                set pSetFrameState                  = pGameDLL + 0x0A95F0
                set pClickFrame                     = pGameDLL + 0x0BE3A0
                set pUpdateFrame                    = pGameDLL + 0x0BD630
                set pGetUnitFramePosition           = pGameDLL + 0x358CF0
        elseif PatchVersion == "1.27b" then
                set pGetTooltipFrame                = pGameDLL + 0x3B6ED0
                set pGetFrameSkinByName             = pGameDLL + 0x342220
                set pDestroyFrame                   = pGameDLL + 0x0F55D0
                set pSetFrameState                  = pGameDLL + 0x112030
                set pClickFrame                     = pGameDLL + 0x112100
                set pUpdateFrame                    = pGameDLL + 0x111390
                set pGetUnitFramePosition           = pGameDLL + 0x376490
        elseif PatchVersion == "1.28f" then
                set pGetTooltipFrame                = pGameDLL + 0x3EAFC0
                set pGetFrameSkinByName             = pGameDLL + 0x3761E0
                set pDestroyFrame                   = pGameDLL + 0x123C20
                set pSetFrameState                  = pGameDLL + 0x1406E0
                set pClickFrame                     = pGameDLL + 0x1407B0
                set pUpdateFrame                    = pGameDLL + 0x13F9B0
                set pGetUnitFramePosition           = pGameDLL + 0x3AA5A0
            endif

            if pGetTooltipFrame > 0 then
                set pUnitFramePosition = Malloc( 0x8 )
                set pTooltipFrame = fast_call_1( pGetTooltipFrame, 0 )
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackFrameAPI takes nothing returns nothing
    //set gg_trg_MemHackFrameAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackUIAPI
//===========================================================================
//TESH.scrollpos=269
//TESH.alwaysfold=0
//! nocjass
library MemoryHackUIAPI
    globals
        constant integer ANCHOR_TOPLEFT     = 0
        constant integer ANCHOR_TOP         = 1
        constant integer ANCHOR_TOPRIGHT    = 2
        constant integer ANCHOR_LEFT        = 3
        constant integer ANCHOR_CENTER      = 4
        constant integer ANCHOR_RIGHT       = 5
        constant integer ANCHOR_BOTTOMLEFT  = 6
        constant integer ANCHOR_BOTTOM      = 7
        constant integer ANCHOR_BOTTOMRIGHT = 8
        boolean IsGameUIEnabled             = true
    endglobals

    function SetUIFramePoint takes integer pFrame, integer point, integer pParentFrame, integer relativePoint, real x, real y returns integer
        local integer fid_1 = GetFrameType( pFrame )
        local integer fid_2 = GetFrameType( pParentFrame )

        if fid_1 > 0 and fid_2 > 0 then
            if fid_1 != 9 then
                set pFrame = GetFrameLayoutByType( pFrame, fid_1 )
            endif

            if fid_2 != 9 then
                set pParentFrame = GetFrameLayoutByType( pParentFrame, fid_2 )
            endif

            return SetCLayoutFramePoint( pFrame, point, pParentFrame, relativePoint, x, y )
        endif

        return 0
    endfunction

    function HideUI takes nothing returns nothing
        local integer pRootFrame = GetRootFrame( )

        if pRootFrame > 0 then
            call SetUIFramePoint( GetUIUpperButtonBarFrame( ), ANCHOR_TOPLEFT, pRootFrame, ANCHOR_TOPLEFT, 0.0, 1.0 )
            call SetUIFramePoint( GetUIResourceBarFrame( ), ANCHOR_TOPRIGHT, pRootFrame, ANCHOR_TOPRIGHT, 0.0, 1.0 )

            call SetUIFramePoint( GetUISimpleConsole( ), ANCHOR_TOPLEFT, pRootFrame, ANCHOR_TOPLEFT, 10.0, 0.0 )
            call SetUIFramePoint( GetUISimpleConsole( ), ANCHOR_TOPRIGHT, pRootFrame, ANCHOR_TOPRIGHT, -10.0, 0.0 )

            call SetUIFramePoint( GetUIPortrait( ), ANCHOR_BOTTOMLEFT, pRootFrame, ANCHOR_BOTTOMLEFT, 1.0, 1.0 )
            call SetUIFramePoint( GetUIMinimap( ), ANCHOR_BOTTOMLEFT, pRootFrame, ANCHOR_BOTTOMLEFT, 1.0, 1.0 )

            call SetUIFramePoint( GetUIPeonBar( ), ANCHOR_BOTTOMLEFT, pRootFrame, ANCHOR_BOTTOMLEFT, 1.0, 1.0 )
            call SetUIFramePoint( GetUIHeroBar( ), ANCHOR_TOPLEFT, pRootFrame, ANCHOR_TOPLEFT, 0.0, 1.0 )

            call SetUIFramePoint( GetUITimeOfDayIndicator( ), ANCHOR_BOTTOMLEFT, pRootFrame, ANCHOR_BOTTOMLEFT, 1.0, 1.0 )
            call SetUIFramePoint( ReadRealMemory( GetUITimeOfDayIndicator( ) + 0x1B0 ), ANCHOR_TOP, pRootFrame, ANCHOR_TOP, 1.0, 0.0 ) // TimeOfDayIndicator UBERTIP
            call SetUIFramePoint( ReadRealMemory( GetUIInfoBar( ) + 0x14C ), ANCHOR_BOTTOMRIGHT, pRootFrame, ANCHOR_TOPLEFT, 1.0, 0.0 ) // ConsoleInventoryCoverTexture
            call HideFrame( GetUITimeOfDayIndicator( ) )
        endif
    endfunction

    function ShowUI takes nothing returns nothing
        local integer pRootFrame = GetRootFrame( )

        if pRootFrame > 0 then
            call SetUIFramePoint( GetUIUpperButtonBarFrame( ), ANCHOR_TOPLEFT, pRootFrame, ANCHOR_TOPLEFT, 0.0, 0.0 )
            call SetUIFramePoint( GetUIResourceBarFrame( ), ANCHOR_TOPRIGHT, pRootFrame, ANCHOR_TOPRIGHT, 0.0, 0.0 )

            call SetUIFramePoint( GetUISimpleConsole( ), ANCHOR_TOPLEFT, pRootFrame, ANCHOR_TOPLEFT, 0.0, 0.0 )
            call SetUIFramePoint( GetUISimpleConsole( ), ANCHOR_TOPRIGHT, pRootFrame, ANCHOR_TOPRIGHT, 0.0, 0.0 )

            call SetUIFramePoint( GetUIPortrait( ), ANCHOR_BOTTOMLEFT, pRootFrame, ANCHOR_BOTTOMLEFT, 0.207500, 0.030625 )
            call SetUIFramePoint( GetUIMinimap( ), ANCHOR_BOTTOMLEFT, pRootFrame, ANCHOR_BOTTOMLEFT, 0.009375, 0.006875 )

            call SetUIFramePoint( GetUIPeonBar( ), ANCHOR_BOTTOMLEFT, pRootFrame, ANCHOR_BOTTOMLEFT, 0.003750, 0.170000 )
            call SetUIFramePoint( GetUIHeroBar( ), ANCHOR_TOPLEFT, pRootFrame, ANCHOR_TOPLEFT, 0.003750, -0.026250 )

            call SetUIFramePoint( GetUITimeOfDayIndicator( ), ANCHOR_BOTTOMLEFT, pRootFrame, ANCHOR_BOTTOMLEFT, 0.0, 0.0 )
            call SetUIFramePoint( ReadRealMemory( GetUITimeOfDayIndicator( ) + 0x1B0 ), ANCHOR_TOP, pRootFrame, ANCHOR_TOP, 0.0, 0.0 ) // TimeOfDayIndicator UBERTIP
            call SetUIFramePoint( ReadRealMemory( GetUIInfoBar( ) + 0x14C ), ANCHOR_BOTTOMRIGHT, pRootFrame, ANCHOR_TOPLEFT, -0.200000, 0.0 ) // ConsoleInventoryCoverTexture
            call ShowFrame( GetUITimeOfDayIndicator( ) )
        endif
    endfunction

    function EditBlackBorders takes real topX, real topY, real botX, real botY returns nothing
        local integer pRootFrame        = GetRootFrame( )
        local integer pWorldFrameWar3   = GetUIWorldFrameWar3( )// + 0xB4

        if pRootFrame > 0 then
            call SetUIFramePoint( pWorldFrameWar3, ANCHOR_TOPRIGHT, pRootFrame, ANCHOR_TOPRIGHT, topX, topY )
            call SetUIFramePoint( pWorldFrameWar3, ANCHOR_BOTTOMLEFT, pRootFrame, ANCHOR_BOTTOMLEFT, botX, botY )
        endif
    endfunction

    function HideBlackBorders takes nothing returns nothing
        call EditBlackBorders( 0., 0., 0., 0. )
    endfunction
    
    function ShowBlackBorders takes nothing returns nothing
        call EditBlackBorders( 0., -.02, 0., .13 )
    endfunction

    function EditMiniMap takes integer point, real topX, real topY, real botX, real botY returns nothing
        local integer pRootFrame    = GetRootFrame( )
        local integer pMiniMapFrame = GetUIMinimap( )// + 0xB4

        if pRootFrame > 0 then
            call SetUIFramePoint( pMiniMapFrame, ANCHOR_TOPRIGHT, pRootFrame, point, topX, topY )
            call SetUIFramePoint( pMiniMapFrame, ANCHOR_BOTTOMLEFT, pRootFrame, point, botX, botY )
        endif
    endfunction

    function HideMiniMap takes nothing returns nothing
        local real xMul = .8 / GetWindowWidth( )
        local real yMul = .6 / GetWindowHeight( )

        call EditMiniMap( ANCHOR_TOPRIGHT, -2. * xMul + xMul, 0., -2. * xMul, -yMul )
    endfunction
    
    function ShowMiniMap takes nothing returns nothing
        call EditMiniMap( ANCHOR_BOTTOMLEFT, 0.14875, 0.145, 0.009375, 0.006875 )
    endfunction

    function EditCommandBarButton takes integer row, integer column, integer anchor, real offsetX, real offsetY, real width, real height returns nothing
        local integer pButtonFrame = GetSkillBarButtonXY( row, column )
        local integer pRootFrame = GetRootFrame( )

        if pButtonFrame > 0 then
            if width >= 0. then
                call SetFrameWidth( pButtonFrame, width )
            endif

            if height >= 0. then
                call SetFrameHeight( pButtonFrame, height )
            endif

            call SetUIFramePoint( pButtonFrame, ANCHOR_TOPLEFT, pRootFrame, anchor, offsetX, -offsetY )
        endif
    endfunction

    function EditItemBarButton takes integer buttonId, integer anchor, real offsetX, real offsetY, real width, real height returns nothing
        local integer pButtonFrame = GetItemBarButton( buttonId )
        local integer pRootFrame = GetRootFrame( )

        if pButtonFrame > 0 then
            if width >= 0. then
                call SetFrameWidth( pButtonFrame, width )
            endif

            if height >= 0. then
                call SetFrameHeight( pButtonFrame, height )
            endif

            call SetUIFramePoint( pButtonFrame, ANCHOR_TOPLEFT, pRootFrame, anchor, offsetX, -offsetY )
        endif
    endfunction

    function EditMinimapButton takes integer buttonId, integer anchor, real offsetX, real offsetY, real width, real height returns nothing
        local integer pButtonFrame = GetMinimapButton( buttonId )
        local integer pRootFrame = GetRootFrame( )

        if pButtonFrame > 0 then
            if width >= 0. then
                call SetFrameWidth( pButtonFrame, width )
            endif

            if height >= 0. then
                call SetFrameHeight( pButtonFrame, height )
            endif

            call SetUIFramePoint( pButtonFrame, ANCHOR_TOPLEFT, pRootFrame, anchor, offsetX, -offsetY )
        endif
    endfunction

    function EditUpperButtonBarButton takes integer buttonId, integer anchor, real offsetX, real offsetY, real width, real height returns nothing
        local integer pButtonFrame = GetUpperButtonBarButton( buttonId )
        local integer pRootFrame = GetRootFrame( )

        if pButtonFrame > 0 then
            if width >= 0. then
                call SetFrameWidth( pButtonFrame, width )
            endif

            if height >= 0. then
                call SetFrameHeight( pButtonFrame, height )
            endif
            
            if buttonId == 0 then
                call SetUIFramePoint( pButtonFrame, ANCHOR_TOPLEFT, pRootFrame, anchor, offsetX, -offsetY )
            else
                call SetUIFramePoint( pButtonFrame, ANCHOR_LEFT, pRootFrame, anchor, offsetX, -( offsetY + GetFrameHeight( pButtonFrame ) / 2. ) )
            endif
        endif
    endfunction

    function EditHeroBarButton takes integer buttonId, integer anchor, real offsetX, real offsetY, real width, real height returns nothing
        local integer pButtonFrame = GetHeroBarButton( buttonId )
        local integer pRootFrame = GetRootFrame( )

        if pButtonFrame > 0 then
            if width >= 0. then
                call SetFrameWidth( pButtonFrame, width )
            endif

            if height >= 0. then
                call SetFrameHeight( pButtonFrame, height )
            endif

            call SetUIFramePoint( pButtonFrame, ANCHOR_TOPLEFT, pRootFrame, anchor, offsetX, -offsetY )
        endif
    endfunction

    function EditHeroBarHealthBar takes integer buttonId, integer anchor, real offsetX, real offsetY, real width, real height returns nothing
        local integer pHealthFrame = GetHeroBarHealthBar( buttonId )
        local integer pRootFrame = GetRootFrame( )

        if pHealthFrame > 0 then
            if width >= 0. then
                call SetFrameWidth( pHealthFrame, width )
            endif

            if height >= 0. then
                call SetFrameHeight( pHealthFrame, height )
            endif

            call SetUIFramePoint( pHealthFrame, ANCHOR_TOP, pRootFrame, anchor, offsetX + GetFrameWidth( pHealthFrame ) / 2., -offsetY )
        endif
    endfunction

    function EditHeroBarManaBar takes integer buttonId, integer anchor, real offsetX, real offsetY, real width, real height returns nothing
        local integer pManaFrame = GetHeroBarManaBar( buttonId )
        local integer pRootFrame = GetRootFrame( )

        if pManaFrame > 0 then
            if width >= 0. then
                call SetFrameWidth( pManaFrame, width )
            endif

            if height >= 0. then
                call SetFrameHeight( pManaFrame, height )
            endif

            call SetUIFramePoint( pManaFrame, ANCHOR_TOP, pRootFrame, anchor, offsetX + GetFrameWidth( pManaFrame ) / 2., -offsetY )
        endif
    endfunction

    function EditTooltip takes integer anchor, real offsetX, real offsetY, real width returns nothing
        local integer pRootFrame = GetRootFrame( )

        if pTooltipFrame > 0 then
            if width >= 0. then
                call SetFrameWidth( pTooltipFrame, width ) // Borders
                call SetFrameWidth( ReadRealMemory( pTooltipFrame + 0x180 ), width ) // Text
            endif
            //call SetUIFramePoint( pTooltipFrame, ANCHOR_BOTTOMRIGHT, pRootFrame, anchor, offsetX + GetFrameWidth( pTooltipFrame ), -( offsetY + GetFrameHeight( pTooltipFrame ) ) ) // offsetX = 0, offsetY = 0 - top left corner
            call SetUIFramePoint( pTooltipFrame, ANCHOR_BOTTOMRIGHT, pRootFrame, anchor, offsetX, -offsetY ) // offsetX = 0, offsetY = 0 - bottom right corner
        endif
    endfunction

    function ShowAllUI takes nothing returns nothing
        call ShowBlackBorders( )
        call ShowUI( )
        call ShowMiniMap( )
    endfunction
    
    function HideAllUI takes nothing returns nothing
        call HideBlackBorders( )
        call HideUI( )
        call HideMiniMap( )
    endfunction

    function ToggleUI takes nothing returns nothing
        set IsGameUIEnabled = not IsGameUIEnabled

        if IsGameUIEnabled then
            call ShowAllUI( )
        else
            call HideAllUI( )
        endif
    endfunction
    
    function Init_MemHackUIAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
        elseif PatchVersion == "1.26a" then
        elseif PatchVersion == "1.27a" then
        elseif PatchVersion == "1.27b" then
        elseif PatchVersion == "1.28f" then
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackUIAPI takes nothing returns nothing
    //set gg_trg_MemHackUIAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackPlayerAPI
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library MemoryHackPlayerAPI
    globals
        integer pGlobalPlayerClass = 0
    endglobals

    function GetRealPlayerById takes integer i returns integer
        local integer pladdr = ReadRealMemory( pGlobalPlayerClass )

        if pladdr > 0 then
            return ReadRealMemory( pladdr + ( i * 4 ) + 0x58 )
        endif

        return 0
    endfunction

    function GetLocalPlayerIdReal takes nothing returns integer
        local integer pladdr = ReadRealMemory( pGlobalPlayerClass )

        if pladdr > 0 then
            return ReadRealMemory( pladdr + 0xA )
        endif

        return -1
    endfunction

    function GetLocalPlayerReal takes nothing returns integer
        return GetRealPlayerById( GetLocalPlayerIdReal( ) )
    endfunction

    function GetPlayerSelectedUnitReal takes integer realplayer returns integer
        local integer pladdr = ReadRealMemory( realplayer + 0x34 )

        if pladdr > 0 then
            return ReadRealMemory( pladdr + 0x1E0 )
        endif

        return -1
    endfunction

    function SetPlayerSelectedUnitReal takes integer realplayer, integer pConvertedHandle returns nothing
        local integer pladdr = ReadRealMemory( realplayer + 0x34 )

        if pladdr > 0 then
            call WriteRealMemory( pladdr + 0x1E0, pConvertedHandle )
        endif
    endfunction

    function GetOrderPlayerId takes unit u returns integer 
        local integer pHandle = ConvertHandle( u )
        local integer pAddr1
        local integer pAddr2

        if pHandle > 0 then
            set pAddr1 = ReadRealMemory( pHandle + 0x1A8 )
            set pAddr2 = ReadRealMemory( pHandle + 0x1AC )

            if pAddr1 > 0 and pAddr2 > 0 then
                return ReadRealMemory( GetCAgentFromHash( pAddr1, pAddr2 ) + 0x28 )
            endif
        endif

        return 0xF
    endfunction
    
    function Init_MemHackPlayerAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pGlobalPlayerClass = pGameDLL + 0xACD44C
        elseif PatchVersion == "1.26a" then
                set pGlobalPlayerClass = pGameDLL + 0xAB65F4
        elseif PatchVersion == "1.27a" then
                set pGlobalPlayerClass = pGameDLL + 0xBE4238
        elseif PatchVersion == "1.27b" then
                set pGlobalPlayerClass = pGameDLL + 0xD687A8
        elseif PatchVersion == "1.28f" then
                set pGlobalPlayerClass = pGameDLL + 0xD305E0
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackPlayerAPI takes nothing returns nothing
    //set gg_trg_MemHackPlayerAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackAbilityAddressAPI
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library MemoryHackAbilityAddressAPI
    globals
        integer pStartAbilityCD     = 0
        integer pSilenceAbility     = 0
        integer pUnsilenceAbility   = 0
    endglobals

    // CAbility API
    function GetAbilityBaseDataByAddress takes integer pAbil returns integer
        if pAbil > 0 then
            return ReadRealMemory( pAbil + 0x54 )
        endif

        return 0
    endfunction

    function GetAddressAbilityTypeId takes integer pAbil returns integer
        local integer base = 0

        if pAbil > 0 then
            set base = GetAbilityBaseDataByAddress( pAbil )

            if base > 0 then
                return ReadRealMemory( base + 0x34 )
            endif
        endif

        return 0
    endfunction
    
    function GetAddressAbilityBaseId takes integer pAbil returns integer
        local integer base = 0

        if pAbil > 0 then
            set base = GetAbilityBaseDataByAddress( pAbil )

            if base > 0 and ReadRealMemory( pAbil + 0x6C ) > 0 then
                return ReadRealMemory( base + 0x30 )
            endif
        endif

        return 0
    endfunction

    function GetAddressAbilityOrderId takes integer pAbil returns integer
        local integer pOffset2 = 0
        local integer base     = 0

        if pAbil > 0 then
            set base = GetAbilityBaseDataByAddress( pAbil )

            if base > 0 then
                set base = ReadRealMemory( base + 0x30 )

                if base > 0 then
                    if base == 'ANcl' then
                        return ReadRealMemory( pAbil + 0x124 )
                    else
                        return c_call_1( ReadRealMemory( ReadRealMemory( pAbil ) + 0x308 ), 0 )
                    endif
                endif
            endif
        endif

        return 0
    endfunction

    function IsAddressAbilityOnCooldown takes integer pAbil returns boolean
        if pAbil > 0 then
            return IsFlagBitSet( ReadRealMemory( pAbil + 0x20 ), 512 )
        endif

        return false
    endfunction
    
    function IsAddressAbilitySafe takes integer pAbil returns boolean
        local integer base  = GetAddressAbilityBaseId( pAbil )
        local integer order = 0

        if base > 0 then
            if base == 'ANcl' then
                set order = ReadRealMemory( pAbil + 0x124 )
            else
                set order = GetAddressAbilityOrderId( pAbil )
            endif

            if base == 'AOre' or base == 'Aexh' then
                return true
            endif

            return order > 0 and base != 'ANeg'
        endif

        return false
    endfunction

    function IsAddressAbilityUsable takes integer pAbil returns boolean // Always false for ANcl
        if pAbil > 0 then
            return this_call_1( ReadRealMemory( ReadRealMemory( pAbil ) + 0x1D8 ), pAbil ) == 1 or ( ReadRealMemory( pAbil + 0x6C ) != 0 and GetAddressAbilityBaseId( pAbil ) == 'ANcl' ) 
        endif

        return false
    endfunction

    function GetAddressAbilityCastTime takes integer pAbil returns real
        if pAbil > 0 then
            set pAbil = ReadRealMemory( pAbil + 0x84 )

            if pAbil > 0 then
                return GetRealFromMemory( ReadRealMemory( pAbil ) )
            endif
        endif

        return 0.
    endfunction

    function SetAddressAbilityCastTime takes integer pAbil, real r returns nothing
        if pAbil > 0 then
            set pAbil = ReadRealMemory( pAbil + 0x84 )

            if pAbil > 0 then
                call WriteRealMemory( pAbil, SetRealIntoMemory( r ) )
            endif
        endif
    endfunction
    
    function GetAddressAbilityCastpoint takes integer pAbil returns real
        if pAbil > 0 then
            return GetRealFromMemory( ReadRealMemory( pAbil + 0x8C ) )
        endif

        return 0.
    endfunction

    function SetAddressAbilityCastpoint takes integer pAbil, real dur returns nothing
        if pAbil > 0 then
            call WriteRealMemory( pAbil + 0x8C, SetRealIntoMemory( dur ) )
        endif
    endfunction

    function GetAddressAbilityBackswing takes integer pAbil returns real
        if pAbil > 0 then
            return GetRealFromMemory( ReadRealMemory( pAbil + 0x94 ) )
        endif

        return 0.
    endfunction

    function SetAddressAbilityBackswing takes integer pAbil, real dur returns nothing
        if pAbil > 0 then
            call WriteRealMemory( pAbil + 0x94, SetRealIntoMemory( dur ) )
        endif
    endfunction

    function GetAddressAbilityDefaultCooldown takes integer pAbil returns real
        if pAbil > 0 then
            return GetRealFromMemory( ReadRealMemory( pAbil + 0xB4 ) )
        endif

        return 0.
    endfunction

    function SetAddressAbilityDefaultCooldown takes integer pAbil, real dur returns nothing
        if pAbil > 0 then
            call WriteRealMemory( pAbil + 0xB4, SetRealIntoMemory( dur ) )
        endif
    endfunction
    
    function GetAddressAbilityManaCost takes integer pAbil, integer level returns integer
        if pAbil > 0 then
            set pAbil = GetAbilityBaseDataByAddress( pAbil )

            if pAbil > 0 then
                return ReadRealMemory( pAbil + level * 0x68 )
            endif
        endif

        return 0
    endfunction
    
    function SetAddressAbilityManaCost takes integer pAbil, integer level, integer mc returns nothing
        if pAbil > 0 then
            set pAbil = GetAbilityBaseDataByAddress( pAbil )

            if pAbil > 0 then
                call WriteRealMemory( pAbil + level * 0x68, mc )
            endif
        endif
    endfunction

    function GetAddressAbilityCooldownStamp takes integer pAbil returns real
        if pAbil > 0 then
            set pAbil = ReadRealMemory( pAbil + 0xDC )
            
            if pAbil > 0 then
                return GetRealFromMemory( ReadRealMemory( pAbil + 0x4 ) )
            endif
        endif

        return 0.
    endfunction
    
    function GetAddressAbilityCurrentCooldown takes integer pAbil returns real
        local real cd = 0.

        if pAbil > 0 then
            set pAbil = ReadRealMemory( pAbil + 0xDC )

            if pAbil > 0 then
                set cd    = GetRealFromMemory( ReadRealMemory( pAbil + 0x4 ) )
                set pAbil = ReadRealMemory( pAbil + 0xC )

                if pAbil > 0 then
                    set pAbil = ReadRealMemory( pAbil + 0x40 )
                    
                    if pAbil > 0 then
                        return cd - GetRealFromMemory( pAbil )
                    endif
                endif
            endif
        endif

        return .0
    endfunction
    
    function SetAddressAbilityCooldown takes integer pAbil, real seconds, string mode returns nothing
        local real cd = 0.

        if pAbil > 0 then
            set pAbil = ReadRealMemory( pAbil + 0xDC )

            if pAbil > 0 then
                set cd = GetRealFromMemory( ReadRealMemory( pAbil + 0x4 ) )
                if mode == "+" then
                    set seconds = cd + seconds
            elseif mode == "-" then
                    set seconds = cd - seconds
                endif

                //call WriteRealMemory( ReadRealMemory( ConvertHandle( a ) + 0xB4 ), SetRealIntoMemory( seconds ) )
                call WriteRealMemory( pAbil + 4, SetRealIntoMemory( seconds ) )
            endif
        endif
    endfunction
    
    function StartAddressAbilityCooldown takes integer pAbil, real cd returns boolean
        if IsAddressAbilitySafe( pAbil ) then
            if pAbil > 0 then
                call WriteRealMemory( pReservedIntArg1, SetRealIntoMemory( cd ) )
                call this_call_2( pStartAbilityCD, pAbil, pReservedIntArg1 )
                return IsAddressAbilityOnCooldown( pAbil )
            endif
        endif

        return false
    endfunction

    function SetAddressAbilityDisabled takes integer pAbil, integer count returns nothing
        if pAbil > 0 then
            call WriteRealMemory( pAbil + 0x3C, count )
        endif
    endfunction

    function GetAddressAbilityDisabled takes integer pAbil returns integer
        return ReadRealMemory( pAbil + 0x3C )
    endfunction

    function SetAddressAbilityHidden takes integer pAbil, integer count returns nothing
        if pAbil > 0 then
            call WriteRealMemory( pAbil + 0x40, count )
        endif
    endfunction

    function AddAddressAbilityHidden takes integer pAbil, integer d returns nothing
        call WriteRealMemory( pAbil + 0x40, ReadRealMemory( pAbil + 0x40 ) + d )
    endfunction

    function GetAddressAbilityDisabledEx takes integer pAbil returns integer
        if pAbil > 0 then
            return ReadRealMemory( pAbil + 0x44 ) 
        endif
        
        return 0
    endfunction

    function SetAddressAbilityDisabledEx takes integer pAbil, integer count returns nothing
        if pAbil > 0 then
            call WriteRealMemory( pAbil + 0x44, count )
        endif
    endfunction

    function ShowAddressAbility takes integer pAbil, boolean flag returns nothing
        if pAbil > 0 then
            if ReadRealMemory( pAbil ) > 0 then
                call WriteRealMemory( pAbil + 0x40, B2I( not flag ) )
            endif
        endif
    endfunction

    function SilenceAddressAbility takes integer pAbil returns nothing
        if pAbil > 0 then
            call this_call_3( pSilenceAbility, pAbil, 0, 1 )
        endif
    endfunction

    function UnsilenceAddressAbility takes integer pAbil returns nothing
        if pAbil > 0 then
            call this_call_3( pUnsilenceAbility, pAbil, 0, 1 )
        endif
    endfunction
    //===========================================

    // Buff API
    function GetAddressBuffLevel takes integer pBuff returns integer
        if pBuff > 0 then
            return ReadRealMemory( pBuff + 0xB0 ) + 1
        endif

        return -1 // Ensure we failed
    endfunction
    //===========================================

    function Init_MemHackAbilityAddressAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pStartAbilityCD     = pGameDLL + 0x0518B0
                set pSilenceAbility     = pGameDLL + 0x0538A0
                set pUnsilenceAbility   = pGameDLL + 0x053900
        elseif PatchVersion == "1.26a" then
                set pStartAbilityCD     = pGameDLL + 0x050B70
                set pSilenceAbility     = pGameDLL + 0x052B60
                set pUnsilenceAbility   = pGameDLL + 0x052BC0
        elseif PatchVersion == "1.27a" then
                set pStartAbilityCD     = pGameDLL + 0x418D20
                set pSilenceAbility     = pGameDLL + 0x3E9FA0
                set pUnsilenceAbility   = pGameDLL + 0x3EE3C0
        elseif PatchVersion == "1.27b" then
                set pStartAbilityCD     = pGameDLL + 0x436460
                set pSilenceAbility     = pGameDLL + 0x4076E0
                set pUnsilenceAbility   = pGameDLL + 0x40BB00
        elseif PatchVersion == "1.28f" then
                set pStartAbilityCD     = pGameDLL + 0x46A570
                set pSilenceAbility     = pGameDLL + 0x43B7C0
                set pUnsilenceAbility   = pGameDLL + 0x43FBE0
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackAbilityAddressAPI takes nothing returns nothing
    //set gg_trg_MemHackAbilityAddressAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackAbilityBaseAPI
//===========================================================================
//TESH.scrollpos=837
//TESH.alwaysfold=0
//! nocjass
library MemoryHackAbilityBaseAPI
    globals
        integer pGetAbilityBaseData = 0
        integer pGetAbilityBaseUI   = 0
    endglobals

    // Base Ability Data/UI Data by Id API
    function GetAbilityBaseDataById takes integer aid returns integer
        if aid > 0 then
           return this_call_1( pGetAbilityBaseData, aid )
        endif

        return 0
    endfunction

    function GetAbilityBaseDataByIdCaching takes integer aid returns integer
        // DEF_ADR_ABILITY_DATA = 0
        local integer pAbil = 0

        if HaveSavedInteger( htObjectDataPointers, 0, aid ) then 
            return LoadInteger( htObjectDataPointers, 0, aid )
        endif

        set pAbil = GetAbilityBaseDataById( aid )
        if pAbil > 0 then
            call SaveInteger( htObjectDataPointers, 0, aid, pAbil )
        endif

        return pAbil
    endfunction

    function GetAbilityBaseUIById takes integer aid returns integer
        if aid > 0 then
            return this_call_1( pGetAbilityBaseUI, aid )
        endif

        return 0
    endfunction

    function GetAbilityBaseUIByIdCaching takes integer aid returns integer
        // DEF_ADR_ABILITY_UI = 1
        local integer pAbil = 0

        if HaveSavedInteger( htObjectDataPointers, 1, aid ) then
            return LoadInteger( htObjectDataPointers, 1, aid )
        endif

        set pAbil = GetAbilityBaseUIById( aid )
        if pAbil > 0 then
            call SaveInteger( htObjectDataPointers, 1, aid, pAbil )
        endif

        return pAbil
    endfunction

    function GetAbilityBaseMaxLevelById takes integer aid returns integer
        local integer pAbil

        if aid > 0 then
            set pAbil = GetAbilityBaseDataByIdCaching( aid )

            if pAbil > 0 then
                return ReadRealMemory( pAbil + 0x50 )
            endif
        endif

        return 0
    endfunction
    //===========================================

    // Base Ability Parameters API
    function SetAbilityBaseHotkeyParam takes integer aid, integer off, integer newVal returns nothing
        local integer pAbil = GetAbilityBaseUIByIdCaching( aid )

        if pAbil > 0 then
            call WriteRealMemory( ReadRealMemory( pAbil + off ), newVal )
        endif
    endfunction

    function GetAbilityBaseHotkeyParam takes integer aid, integer off returns integer
        local integer pData = GetAbilityBaseUIByIdCaching( aid )

        if pData > 0 then
            set pData = ReadRealMemory( pData + off )

            if pData > 0 then
                return ReadRealMemory( pData )
            endif
        endif

        return 0
    endfunction

    function SetAbilityBaseIntegerParam takes integer aid, integer off, integer newVal returns nothing
        local integer pData = GetAbilityBaseUIByIdCaching( aid )

        if pData > 0 then
            call WriteRealMemory( pData + off, newVal )
        endif
    endfunction

    function GetAbilityBaseIntegerParam takes integer aid, integer off returns integer
        local integer pData = GetAbilityBaseUIByIdCaching( aid )

        if pData > 0 then
            return ReadRealMemory( pData + off )
        endif

        return 0
    endfunction

    function SetAbilityBaseRealParam takes integer aid, integer off, real newVal returns nothing
        local integer pData = GetAbilityBaseUIByIdCaching( aid )

        if pData > 0 then
            call WriteRealMemory( pData + off, SetRealIntoMemory( newVal ) )
        endif
    endfunction

    function GetAbilityBaseRealParam takes integer aid, integer off returns real
        local integer pData = GetAbilityBaseUIByIdCaching( aid )

        if pData > 0 then
            return GetRealFromMemory( ReadRealMemory( pData + off ) )
        endif

        return 0.
    endfunction

    function SetAbilityBaseBoolParam takes integer aid, integer off, boolean flag returns nothing
        local integer pData = GetAbilityBaseUIByIdCaching( aid )

        if pData > 0 then
            call WriteRealMemory( pData + off, B2I( flag ) )
        endif
    endfunction

    function GetAbilityBaseBoolParam takes integer aid, integer off returns boolean
        local integer pData = GetAbilityBaseUIByIdCaching( aid )

        if pData > 0 then
            return ReadRealMemory( pData + off ) > 0
        endif

        return false
    endfunction

    function GetAbilityBasePStringParam takes integer aid, integer off returns string
        local integer pData = GetAbilityBaseUIByIdCaching( aid )

        if pData > 0 then
            set pData = ReadRealMemory( pData + off )

            if pData > 0 then
                return ToJString( ReadRealMemory( pData ) )
            endif
        endif

        return null
    endfunction

    function SetAbilityBasePStringParam takes integer aid, integer off, string newVal returns nothing
        local integer pData = GetAbilityBaseUIByIdCaching( aid )

        if pData > 0 then
            set pData = ReadRealMemory( pData + off )

            if pData > 0 then
                call WriteRealMemory( pData, GetStringAddress( newVal ) )
            endif
        endif
    endfunction
    
    function GetAbilityBaseStringParam takes integer aid, integer off returns string
        local integer pData = GetAbilityBaseUIByIdCaching( aid )
        
        if pData > 0 then
            set pData = ReadRealMemory( pData + off )

            if pData > 0 then
                return ToJString( pData )
            endif
        endif

        return null
    endfunction

    function SetAbilityBaseStringParam takes integer aid, integer off, string newVal returns nothing
        local integer pData = GetAbilityBaseUIByIdCaching( aid )

        if pData > 0 then
            call WriteRealMemory( pData + off, GetStringAddress( newVal ) )
        endif
    endfunction

    function GetAbilityBaseStringParam2 takes integer aid, integer off, integer level returns string
        local integer pData = GetAbilityBaseUIByIdCaching( aid )

        if pData > 0 then
            set pData = ReadRealMemory( pData + off )
            set level = level - 1

            if level >= 0 and level < GetAbilityBaseMaxLevelById( aid ) then
                if pData > 0 then
                    set pData = ReadRealMemory( pData + level * 0x4 )
                    if pData > 0 then
                        return ToJString( pData )
                    endif
                endif
            endif
        endif

        return null
    endfunction

    function SetAbilityBaseStringParam2 takes integer aid, integer off, string newVal, integer level returns nothing
        local integer pData = GetAbilityBaseUIByIdCaching( aid )

        if pData > 0 then
            set pData = pData + off
            set level = level - 1

            if level >= 0 and level < GetAbilityBaseMaxLevelById( aid ) then
                if ReadRealMemory( pData ) > 0 then
                    set pData = ReadRealMemory( pData + level * 0x4 )
                    if pData > 0 then
                        call WriteRealMemory( pData, GetStringAddress( newVal ) )
                    endif
                endif
            endif
        endif
    endfunction
    //===========================================
    
    // Ability Base Data API by Id
    function GetAbilityBaseManaCostById takes integer aid, integer level returns integer
        local integer pAbil = GetAbilityBaseDataByIdCaching( aid )

        if pAbil > 0 then
            set level = level - 1
            
            if level >= 0 and level < GetAbilityBaseMaxLevelById( aid ) then
                set pAbil = ReadRealMemory( pAbil + 0x54 )

                if pAbil > 0 then
                    return ReadRealMemory( pAbil - 0x58 + level * 0x68 )
                endif
            endif
        endif

        return 0
    endfunction

    function SetAbilityBaseManaCostById takes integer aid, integer level, integer cost returns nothing
        local integer pAbil = GetAbilityBaseDataByIdCaching( aid )

        if pAbil > 0 then
            set level = level - 1
            
            if level >= 0 and level <= GetAbilityBaseMaxLevelById( aid ) then
                set pAbil = ReadRealMemory( pAbil + 0x54 )

                if pAbil > 0 then
                    call WriteRealMemory( pAbil - 0x58 + level * 0x68, cost )
                endif
            endif
        endif
    endfunction

    function GetAbilityBaseCooldownById takes integer aid, integer level returns real
        local integer pAbil = GetAbilityBaseDataByIdCaching( aid ) // GetObjectDataCaching( pAbilityData, aid )

        if pAbil > 0 then
            set level = level - 1
            
            if level >= 0 and level < GetAbilityBaseMaxLevelById( aid ) then
                set pAbil = ReadRealMemory( pAbil + 0x54 )

                if pAbil > 0 then
                    return GetRealFromMemory( ReadRealMemory( pAbil - 0x54 + level * 0x68 ) )
                endif
            endif
        endif

        return 0.
    endfunction

    function SetAbilityBaseCooldownById takes integer aid, integer level, real cool returns nothing
        local integer pAbil = GetAbilityBaseDataByIdCaching( aid )

        if pAbil > 0 then
            set level = level - 1
            
            if level >= 0 and level < GetAbilityBaseMaxLevelById( aid ) then
                set pAbil = ReadRealMemory( pAbil + 0x54 )

                if pAbil > 0 then
                    call WriteRealMemory( pAbil - 0x54 + level * 0x68, SetRealIntoMemory( cool ) )
                endif
            endif
        endif
    endfunction

    function GetAbilityBaseEffectSoundById takes integer aid returns string
        return GetAbilityBaseStringParam( aid, 0x30 )
    endfunction
    
    function SetAbilityBaseEffectSoundById takes integer aid, string s returns nothing
        call SetAbilityBaseStringParam( aid, 0x30, s )
    endfunction

    function GetAbilityBaseEffectSoundLoopedById takes integer aid returns string
        return GetAbilityBaseStringParam( aid, 0x34 )
    endfunction
    
    function SetAbilityBaseEffectSoundLoopedById takes integer aid, string s returns nothing
        call SetAbilityBaseStringParam( aid, 0x34, s )
    endfunction

    function GetAbilityBaseMissingIconById takes integer aid returns string
        return GetAbilityBaseStringParam( aid, 0x38 )
    endfunction
    
    function SetAbilityBaseMissingIconById takes integer aid, string s returns nothing
        call SetAbilityBaseStringParam( aid, 0x38, s )
    endfunction

    function GetAbilityBaseCurrentIconById takes integer aid returns string
        return GetAbilityBaseStringParam( aid, 0x3C )
    endfunction
    
    function SetAbilityBaseCurrentIconById takes integer aid, string s returns nothing
        call SetAbilityBaseStringParam( aid, 0x3C, s )
    endfunction

    function GetAbilityBaseCursorTextureById takes integer aid returns string
        return GetAbilityBaseStringParam( aid, 0x44 )
    endfunction
    
    function SetAbilityBaseCursorTextureById takes integer aid, string s returns nothing
        call SetAbilityBaseStringParam( aid, 0x44, s )
    endfunction

    function GetAbilityBaseGlobalMessageById takes integer aid returns string
        return GetAbilityBaseStringParam( aid, 0x48 )
    endfunction

    function SetAbilityBaseGlobalMessageById takes integer aid, string s returns nothing
        call SetAbilityBaseStringParam( aid, 0x48, s )
    endfunction
    
    function GetAbilityBaseGlobalSoundById takes integer aid returns string
        return GetAbilityBaseStringParam( aid, 0x4C )
    endfunction
    
    function SetAbilityBaseGlobalSoundById takes integer aid, string s returns nothing
        call SetAbilityBaseStringParam( aid, 0x4C, s )
    endfunction
    
    function GetAbilityBaseButtonXById takes integer aid returns integer
        return GetAbilityBaseIntegerParam( aid, 0x50 )
    endfunction
    
    function SetAbilityBaseButtonXById takes integer aid, integer newX returns nothing
        call SetAbilityBaseIntegerParam( aid, 0x50, newX )
    endfunction
    
    function GetAbilityBaseButtonYById takes integer aid returns integer
        return GetAbilityBaseIntegerParam( aid, 0x54 )
    endfunction
    
    function SetAbilityBaseButtonYById takes integer aid, integer newY returns nothing
        call SetAbilityBaseIntegerParam( aid, 0x54, newY )
    endfunction
    
    function GetAbilityBaseUnButtonXById takes integer aid returns integer
        return GetAbilityBaseIntegerParam( aid, 0x58 )
    endfunction
    
    function SetAbilityBaseUnButtonXById takes integer aid, integer newX returns nothing
        call SetAbilityBaseIntegerParam( aid, 0x58, newX )
    endfunction
    
    function GetAbilityBaseUnButtonYById takes integer aid returns integer
        return GetAbilityBaseIntegerParam( aid, 0x5C )
    endfunction
    
    function SetAbilityBaseUnButtonYById takes integer aid, integer newY returns nothing
        call SetAbilityBaseIntegerParam( aid, 0x5C, newY )
    endfunction
    
    function GetAbilityBaseResearchButtonXById takes integer aid returns integer
        return GetAbilityBaseIntegerParam( aid, 0x60 )
    endfunction
    
    function SetAbilityBaseResearchButtonXById takes integer aid, integer newX returns nothing
        call SetAbilityBaseIntegerParam( aid, 0x60, newX )
    endfunction
    
    function GetAbilityBaseResearchButtonYById takes integer aid returns integer
        return GetAbilityBaseIntegerParam( aid, 0x64 )
    endfunction
    
    function SetAbilityBaseResearchButtonYById takes integer aid, integer newY returns nothing
        call SetAbilityBaseIntegerParam( aid, 0x64, newY )
    endfunction
    
    function GetAbilityBaseMissileSpeedById takes integer aid returns real
        return GetAbilityBaseRealParam( aid, 0x68 )
    endfunction
    
    function SetAbilityBaseMissileSpeedById takes integer aid, real speed returns nothing
        call SetAbilityBaseRealParam( aid, 0x68, speed )
    endfunction
    
    function GetAbilityBaseMissileArcById takes integer aid returns real
        return GetAbilityBaseRealParam( aid, 0x6C )
    endfunction
    
    function SetAbilityBaseMissileArcById takes integer aid, real arc returns nothing
        call SetAbilityBaseRealParam( aid, 0x6C, arc )
    endfunction
    
    function IsAbilityMissileHomingById takes integer aid returns boolean
        return GetAbilityBaseBoolParam( aid, 0x70 )
    endfunction
    
    function SetAbilityBaseMissileHomingById takes integer aid, boolean homing returns nothing
        call SetAbilityBaseBoolParam( aid, 0x70, homing )
    endfunction
    
    function GetAbilityBaseSpellDetailsById takes integer aid returns integer
        return GetAbilityBaseIntegerParam( aid, 0x74 )
    endfunction
    
    function SetAbilityBaseSpellDetailsById takes integer aid, integer det returns nothing
        call SetAbilityBaseIntegerParam( aid, 0x74, det )
    endfunction
    
    function GetAbilityBaseHotkeyIdById takes integer aid returns integer
        return GetAbilityBaseHotkeyParam( aid, 0x84 )
    endfunction
    
    function SetAbilityBaseHotkeyIdById takes integer aid, integer newVal returns nothing
        call SetAbilityBaseHotkeyParam( aid, 0x84, newVal )
    endfunction
    
    function GetAbilityBaseUnHotkeyIdById takes integer aid returns integer
        return GetAbilityBaseHotkeyParam( aid, 0x90 )
    endfunction
    
    function SetAbilityBaseUnHotkeyIdById takes integer aid, integer newVal returns nothing
        call SetAbilityBaseHotkeyParam( aid, 0x90, newVal )
    endfunction
    
    function GetAbilityBaseResearchHotkeyIdById takes integer aid returns integer
        return GetAbilityBaseHotkeyParam( aid, 0x9C )
    endfunction
    
    function SetAbilityBaseResearchHotkeyIdById takes integer aid, integer newVal returns nothing
        call SetAbilityBaseHotkeyParam( aid, 0x9C, newVal )
    endfunction

    // New
    function GetAbilityBaseNameById takes integer aid returns string
        return GetAbilityBasePStringParam( aid, 0xA8 )
    endfunction
    
    function SetAbilityBaseNameById takes integer aid, string s returns nothing
        call SetAbilityBasePStringParam( aid, 0xA8, s )
    endfunction

    function GetAbilityBaseIconById takes integer aid returns string
        return GetAbilityBasePStringParam( aid, 0xB4 )
    endfunction
    
    function SetAbilityBaseIconById takes integer aid, string s returns nothing
        call SetAbilityBasePStringParam( aid, 0xB4, s )
    endfunction

    function GetAbilityBaseMissleArtById takes integer aid returns string
        return GetAbilityBasePStringParam( aid, 0xF0 )
    endfunction
    
    function SetAbilityBaseMissleArtById takes integer aid, string s returns nothing
        call SetAbilityBasePStringParam( aid, 0xF0, s )
    endfunction

    function GetAbilityBaseResearchTipById takes integer aid, integer lvl returns string
        return GetAbilityBaseStringParam2( aid, 0x12C, lvl )
    endfunction
    
    function SetAbilityBaseResearchTipById takes integer aid, string s, integer lvl returns nothing
        call SetAbilityBaseStringParam2( aid, 0x12C, s, lvl )
    endfunction
    //

    function GetAbilityBaseTipById takes integer aid, integer lvl returns string
        return GetAbilityBaseStringParam2( aid, 0x138, lvl )
    endfunction
    
    function SetAbilityBaseTipById takes integer aid, integer lvl, string s returns nothing
        call SetAbilityBaseStringParam2( aid, 0x138, s, lvl )
    endfunction
    
    function GetAbilityBaseUnTipById takes integer aid, integer lvl returns string
        return GetAbilityBaseStringParam2( aid, 0x144, lvl )
    endfunction
    
    function SetAbilityBaseUnTipById takes integer aid, string s, integer lvl returns nothing
        call SetAbilityBaseStringParam2( aid, 0x144, s, lvl )
    endfunction
    
    function GetAbilityBaseResearchUberTipById takes integer aid, integer lvl returns string
        return GetAbilityBaseStringParam2( aid, 0x150, lvl )
    endfunction
    
    function SetAbilityBaseResearchUberTipById takes integer aid, string s, integer lvl returns nothing
        call SetAbilityBaseStringParam2( aid, 0x150, s, lvl )
    endfunction
    
    function GetAbilityBaseUbertipById takes integer aid, integer lvl returns string
        return GetAbilityBaseStringParam2( aid, 0x15C, lvl )
    endfunction
    
    function SetAbilityBaseUbertipById takes integer aid, integer lvl, string s returns nothing
        call SetAbilityBaseStringParam2( aid, 0x15C, s, lvl )
    endfunction

    function GetAbilityBaseResearchUnUberTipById takes integer aid, integer lvl returns string
        return GetAbilityBaseStringParam2( aid, 0x168, lvl )
    endfunction

    function SetAbilityBaseResearchUnUberTipById takes integer aid, string s, integer lvl returns nothing
        call SetAbilityBaseStringParam2( aid, 0x168, s, lvl )
    endfunction

    function SetAbilityBaseHotkeyCommonById takes integer aid, integer newVal returns nothing
        call SetAbilityBaseHotkeyIdById( aid, newVal )
        call SetAbilityBaseUnHotkeyIdById( aid, newVal )
        call SetAbilityBaseResearchHotkeyIdById( aid, newVal )
    endfunction
    //===========================================
    
    // Base Ability Data/UI Data API
    function GetAbilityTypeId takes ability abil returns integer
        local integer pAbil = ConvertHandle( abil )

        if pAbil > 0 then
            return GetAddressAbilityTypeId( pAbil )
        endif

        return 0
    endfunction

    function GetAbilityBaseId takes ability a returns integer
        return GetAddressAbilityBaseId( ConvertHandle( a ) )
    endfunction
    
    function GetAbilityBaseData takes ability abil returns integer
        return GetAbilityBaseDataById( GetAbilityTypeId( abil ) )
    endfunction

    function GetAbilityBaseDataCaching takes ability abil returns integer
        return GetAbilityBaseDataByIdCaching( GetAbilityBaseDataById( GetAbilityTypeId( abil ) ) )
    endfunction

    function GetAbilityBaseUI takes ability abil returns integer
        return GetAbilityBaseUIById( GetAbilityTypeId( abil ) )
    endfunction

    function GetAbilityBaseUICaching takes ability abil returns integer
        return GetAbilityBaseUIByIdCaching( GetAbilityTypeId( abil ) )
    endfunction
    //===========================================
    
    // Base Ability Data/UI Data API
    function GetAbilityBaseMaxLevel takes ability abil returns integer
        return GetAbilityBaseMaxLevelById( GetAbilityTypeId( abil ) )
    endfunction

    function GetAbilityBaseManaCost takes ability abil, integer level returns integer
        return GetAbilityBaseManaCostById( GetAbilityTypeId( abil ), level )
    endfunction

    function SetAbilityBaseManaCost takes ability abil, integer level, integer cost returns nothing
        call SetAbilityBaseManaCostById( GetAbilityTypeId( abil ), level, cost )
    endfunction

    function GetAbilityBaseCooldown takes ability abil, integer level returns real
        return GetAbilityBaseCooldownById( GetAbilityTypeId( abil ), level )
    endfunction

    function SetAbilityBaseCooldown takes ability abil, integer level, real cool returns nothing
        call SetAbilityBaseCooldownById( GetAbilityTypeId( abil ), level, cool )
    endfunction

    function GetAbilityBaseEffectSound takes ability abil returns string
        return GetAbilityBaseEffectSoundById( GetAbilityTypeId( abil ) )
    endfunction
    
    function SetAbilityBaseEffectSound takes ability abil, string s returns nothing
        call SetAbilityBaseEffectSoundById( GetAbilityTypeId( abil ), s )
    endfunction

    function GetAbilityBaseEffectSoundLooped takes ability abil returns string
        return GetAbilityBaseEffectSoundLoopedById( GetAbilityTypeId( abil ) )
    endfunction
    
    function SetAbilityBaseEffectSoundLooped takes ability abil, string s returns nothing
        call SetAbilityBaseEffectSoundLoopedById( GetAbilityTypeId( abil ), s )
    endfunction

    function GetAbilityBaseMissingIcon takes ability abil returns string
        return GetAbilityBaseMissingIconById( GetAbilityTypeId( abil ) )
    endfunction
    
    function SetAbilityBaseMissingIcon takes ability abil, string s returns nothing
        call SetAbilityBaseMissingIconById( GetAbilityTypeId( abil ), s )
    endfunction

    function GetAbilityBaseCurrentIcon takes ability abil returns string
        return GetAbilityBaseCurrentIconById( GetAbilityTypeId( abil ) )
    endfunction
    
    function SetAbilityBaseCurrentIcon takes ability abil, string s returns nothing
        call SetAbilityBaseCurrentIconById( GetAbilityTypeId( abil ), s )
    endfunction

    function GetAbilityBaseCursorTexture takes ability abil returns string
        return GetAbilityBaseCursorTextureById( GetAbilityTypeId( abil ) )
    endfunction
    
    function SetAbilityBaseCursorTexture takes ability abil, string s returns nothing
        call SetAbilityBaseCursorTextureById( GetAbilityTypeId( abil ), s )
    endfunction

    function GetAbilityBaseGlobalMessage takes ability abil returns string
        return GetAbilityBaseGlobalMessageById( GetAbilityTypeId( abil ) )
    endfunction

    function SetAbilityBaseGlobalMessage takes ability abil, string s returns nothing
        call SetAbilityBaseGlobalMessageById( GetAbilityTypeId( abil ), s )
    endfunction
    
    function GetAbilityBaseGlobalSound takes ability abil returns string
        return GetAbilityBaseGlobalSoundById( GetAbilityTypeId( abil ) )
    endfunction
    
    function SetAbilityBaseGlobalSound takes ability abil, string s returns nothing
        call SetAbilityBaseGlobalSoundById( GetAbilityTypeId( abil ), s )
    endfunction
    
    function GetAbilityBaseButtonX takes ability abil returns integer
        return GetAbilityBaseButtonXById( GetAbilityTypeId( abil ) )
    endfunction
    
    function SetAbilityBaseButtonX takes ability abil, integer newX returns nothing
        call SetAbilityBaseButtonXById( GetAbilityTypeId( abil ), newX )
    endfunction
    
    function GetAbilityBaseButtonY takes ability abil returns integer
        return GetAbilityBaseButtonYById( GetAbilityTypeId( abil ) )
    endfunction
    
    function SetAbilityBaseButtonY takes ability abil, integer newY returns nothing
        call SetAbilityBaseButtonYById( GetAbilityTypeId( abil ), newY )
    endfunction
    
    function GetAbilityBaseUnButtonX takes ability abil returns integer
        return GetAbilityBaseUnButtonXById( GetAbilityTypeId( abil ) )
    endfunction
    
    function SetAbilityBaseUnButtonX takes ability abil, integer newX returns nothing
        call SetAbilityBaseUnButtonXById( GetAbilityTypeId( abil ), newX )
    endfunction
    
    function GetAbilityBaseUnButtonY takes ability abil returns integer
        return GetAbilityBaseUnButtonYById( GetAbilityTypeId( abil ) )
    endfunction
    
    function SetAbilityBaseUnButtonY takes ability abil, integer newY returns nothing
        call SetAbilityBaseUnButtonYById( GetAbilityTypeId( abil ), newY )
    endfunction
    
    function GetAbilityBaseResearchButtonX takes ability abil returns integer
        return GetAbilityBaseResearchButtonXById( GetAbilityTypeId( abil ) )
    endfunction
    
    function SetAbilityBaseResearchButtonX takes ability abil, integer newX returns nothing
        call SetAbilityBaseResearchButtonXById( GetAbilityTypeId( abil ), newX )
    endfunction
    
    function GetAbilityBaseResearchButtonY takes ability abil returns integer
        return GetAbilityBaseResearchButtonYById( GetAbilityTypeId( abil ) )
    endfunction
    
    function SetAbilityBaseResearchButtonY takes ability abil, integer newY returns nothing
        call SetAbilityBaseResearchButtonYById( GetAbilityTypeId( abil ), newY )
    endfunction
    
    function GetAbilityBaseMissileSpeed takes ability abil returns real
        return GetAbilityBaseMissileSpeedById( GetAbilityTypeId( abil ) )
    endfunction
    
    function SetAbilityBaseMissileSpeed takes ability abil, real speed returns nothing
        call SetAbilityBaseMissileSpeedById( GetAbilityTypeId( abil ), speed )
    endfunction
    
    function GetAbilityBaseMissileArc takes ability abil returns real
        return GetAbilityBaseMissileArcById( GetAbilityTypeId( abil ) )
    endfunction
    
    function SetAbilityBaseMissileArc takes ability abil, real arc returns nothing
        call SetAbilityBaseMissileArcById( GetAbilityTypeId( abil ), arc )
    endfunction
    
    function IsAbilityMissileHoming takes ability abil returns boolean
        return IsAbilityMissileHomingById( GetAbilityTypeId( abil ) )
    endfunction
    
    function SetAbilityBaseMissileHoming takes ability abil, boolean homing returns nothing
        call SetAbilityBaseMissileHomingById( GetAbilityTypeId( abil ), homing )
    endfunction
    
    function GetAbilityBaseSpellDetails takes ability abil returns integer
        return GetAbilityBaseSpellDetailsById( GetAbilityTypeId( abil ) )
    endfunction
    
    function SetAbilityBaseSpellDetails takes ability abil, integer det returns nothing
        call SetAbilityBaseSpellDetailsById( GetAbilityTypeId( abil ), det )
    endfunction
    
    function GetAbilityBaseHotkeyId takes ability abil returns integer
        return GetAbilityBaseHotkeyIdById( GetAbilityTypeId( abil ) )
    endfunction
    
    function SetAbilityBaseHotkeyId takes ability abil, integer newVal returns nothing
        call SetAbilityBaseHotkeyIdById( GetAbilityTypeId( abil ), newVal )
    endfunction
    
    function GetAbilityBaseUnHotkeyId takes ability abil returns integer
        return GetAbilityBaseUnHotkeyIdById( GetAbilityTypeId( abil ) )
    endfunction
    
    function SetAbilityBaseUnHotkeyId takes ability abil, integer newVal returns nothing
        call SetAbilityBaseUnHotkeyIdById( GetAbilityTypeId( abil ), newVal )
    endfunction
    
    function GetAbilityBaseResearchHotkeyId takes ability abil returns integer
        return GetAbilityBaseResearchHotkeyIdById( GetAbilityTypeId( abil ) )
    endfunction
    
    function SetAbilityBaseResearchHotkeyId takes ability abil, integer newVal returns nothing
        call SetAbilityBaseResearchHotkeyIdById( GetAbilityTypeId( abil ), newVal )
    endfunction

    function GetAbilityBaseName takes ability abil returns string
        return GetAbilityBaseNameById( GetAbilityTypeId( abil ) )
    endfunction
    
    function SetAbilityBaseName takes ability abil, string s returns nothing
        call SetAbilityBaseNameById( GetAbilityTypeId( abil ), s )
    endfunction

    function GetAbilityBaseIcon takes ability abil returns string
        return GetAbilityBaseIconById( GetAbilityTypeId( abil ) )
    endfunction
    
    function SetAbilityBaseIcon takes ability abil, string s returns nothing
        call SetAbilityBaseIconById( GetAbilityTypeId( abil ), s )
    endfunction

    function GetAbilityBaseMissleArt takes ability abil returns string
        return GetAbilityBaseMissleArtById( GetAbilityTypeId( abil ) )
    endfunction
    
    function SetAbilityBaseMissleArt takes ability abil, string s returns nothing
        call SetAbilityBaseMissleArtById( GetAbilityTypeId( abil ), s )
    endfunction

    function GetAbilityBaseResearchTip takes ability abil, integer lvl returns string
        return GetAbilityBaseResearchTipById( GetAbilityTypeId( abil ), lvl )
    endfunction
    
    function SetAbilityBaseResearchTip takes ability abil, string s, integer lvl returns nothing
        call SetAbilityBaseResearchTipById( GetAbilityTypeId( abil ), s, lvl )
    endfunction

    function GetAbilityBaseTip takes ability abil, integer lvl returns string
        return GetAbilityBaseTipById( GetAbilityTypeId( abil ), lvl )
    endfunction
    
    function SetAbilityBaseTip takes ability abil, integer lvl, string s returns nothing
        call SetAbilityBaseTipById( GetAbilityTypeId( abil ), lvl, s )
    endfunction
    
    function GetAbilityBaseUnTip takes ability abil, integer lvl returns string
        return GetAbilityBaseUnTipById( GetAbilityTypeId( abil ), lvl )
    endfunction
    
    function SetAbilityBaseUnTip takes ability abil, string s, integer lvl returns nothing
        call SetAbilityBaseUnTipById( GetAbilityTypeId( abil ), s, lvl )
    endfunction
    
    function GetAbilityBaseResearchUberTip takes ability abil, integer lvl returns string
        return GetAbilityBaseResearchUberTipById( GetAbilityTypeId( abil ), lvl )
    endfunction
    
    function SetAbilityBaseResearchUberTip takes ability abil, string s, integer lvl returns nothing
        call SetAbilityBaseResearchUberTipById( GetAbilityTypeId( abil ), s, lvl )
    endfunction
    
    function GetAbilityBaseUbertip takes ability abil, integer lvl returns string
        return GetAbilityBaseUbertipById( GetAbilityTypeId( abil ), lvl )
    endfunction
    
    function SetAbilityBaseUbertip takes ability abil, integer lvl, string s returns nothing
        call SetAbilityBaseUbertipById( GetAbilityTypeId( abil ), lvl, s )
    endfunction

    function GetAbilityBaseResearchUnUberTip takes ability abil, integer lvl returns string
        return GetAbilityBaseResearchUnUberTipById( GetAbilityTypeId( abil ), lvl )
    endfunction

    function SetAbilityBaseResearchUnUberTip takes ability abil, string s, integer lvl returns nothing
        call SetAbilityBaseResearchUnUberTipById( GetAbilityTypeId( abil ), s, lvl )
    endfunction

    function SetAbilityBaseHotkeyCommon takes ability abil, integer newVal returns nothing
        call SetAbilityBaseHotkeyCommonById( GetAbilityTypeId( abil ), newVal )
    endfunction
    //===========================================
    
    function Init_MemHackAbilityBaseAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pGetAbilityBaseData = pGameDLL + 0x2669E0
                set pGetAbilityBaseUI   = pGameDLL + 0x32D420
        elseif PatchVersion == "1.26a" then
                set pGetAbilityBaseData = pGameDLL + 0x265ED0
                set pGetAbilityBaseUI   = pGameDLL + 0x32C8E0
        elseif PatchVersion == "1.27a" then
                set pGetAbilityBaseData = pGameDLL + 0x68EDF0 // sub_6F... above v5 = *(_DWORD *)(v4[21] + 104 * a3 + 24); | HeroAbilityLevelSkip first func
                set pGetAbilityBaseUI   = pGameDLL + 0x322C30 // result = *(_DWORD *)(result + 64); | 852147, (int)v2, a2, 134217732 in !v3
        elseif PatchVersion == "1.27b" then
                set pGetAbilityBaseData = pGameDLL + 0x6AC530
                set pGetAbilityBaseUI   = pGameDLL + 0x416BE0
        elseif PatchVersion == "1.28f" then
                set pGetAbilityBaseData = pGameDLL + 0x6E06E0
                set pGetAbilityBaseUI   = pGameDLL + 0x44ACC0
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackAbilityBaseAPI takes nothing returns nothing
    //set gg_trg_MemHackAbilityBaseAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackAbilityNormalAPI
//===========================================================================
//TESH.scrollpos=84
//TESH.alwaysfold=0
//! nocjass
library MemoryHackAbilityNormalAPI
    globals

    endglobals

    // jAbility API
    function GetAbilityOrderId takes ability a returns integer
        return GetAddressAbilityOrderId( ConvertHandle( a ) )
    endfunction

    function IsAbilityOnCooldown takes ability a returns boolean
        return IsAddressAbilityOnCooldown( ConvertHandle( a ) )
    endfunction

    function IsAbilitySafe takes ability a returns boolean
        return IsAddressAbilitySafe( ConvertHandle( a ) )
    endfunction

    function IsAbilityUsable takes ability a returns boolean
        return IsAddressAbilityUsable( ConvertHandle( a ) )
    endfunction

    function GetAbilityCastpoint takes ability a returns real
        return GetAddressAbilityCastpoint( ConvertHandle( a ) )
    endfunction

    function SetAbilityCastpoint takes ability a, real dur returns nothing
        call SetAddressAbilityCastpoint( ConvertHandle( a ), dur )
    endfunction

    function GetAbilityBackswing takes ability a returns real
        return GetAddressAbilityBackswing( ConvertHandle( a ) )
    endfunction

    function SetAbilityBackswing takes ability a, real dur returns nothing
        call SetAddressAbilityBackswing( ConvertHandle( a ), dur )
    endfunction

    function GetAbilityManaCost takes ability a, integer level returns integer
        return GetAddressAbilityManaCost( ConvertHandle( a ), level )
    endfunction

    function SetAbilityManaCost takes ability a, integer level, integer mc returns nothing
        call SetAddressAbilityManaCost( ConvertHandle( a ), level, mc )
    endfunction

    function GetAbilityCooldownStamp takes ability a returns real
        //This actually returns the timestamp, not the cooldown. To get the real cooldown you need to subtract this from the current game time.
        return GetAddressAbilityCooldownStamp( ConvertHandle( a ) )
    endfunction

    function GetAbilityCurrentCooldown takes ability a returns real
        //This value holds the base cooldown of the ability at the last time it was casted. It’s used to calculate the % of elapsed cooldown.
        //This is completely irrelevant for the gameplay, it’s used only to determine which frame of the cooldown model will be displayed.
        return GetAddressAbilityCurrentCooldown( ConvertHandle( a ) )
    endfunction

    function SetAbilityCooldown takes ability a, real seconds, string mode returns nothing
        call SetAddressAbilityCooldown( ConvertHandle( a ), seconds, mode )
    endfunction

    function AddAbilityCooldown takes ability a, real seconds returns nothing
        call SetAbilityCooldown( a, seconds, "+" )
    endfunction

    function ReduceAbilityCooldown takes ability a, real seconds returns nothing
        call SetAbilityCooldown( a, seconds, "-" )
    endfunction

    function ResetAbilityCooldown takes ability a returns nothing
        call SetAbilityCooldown( a, -1., "" )
    endfunction

    function StartAbilityCooldown takes ability a, real cd returns nothing
        call StartAddressAbilityCooldown( ConvertHandle( a ), cd )
    endfunction

    function GetAbilityCastTime takes ability a returns real
        return GetAddressAbilityCastTime( ConvertHandle( a ) )
    endfunction

    function SetAbilityCastTime takes ability a, real r returns nothing
        call SetAddressAbilityCastTime( ConvertHandle( a ), r )
    endfunction

    function SetAbilityDisabled takes ability a, integer count returns nothing
        // not safe unless used with PauseUnit. Button will be blacked, but current casts of that ability won’t be interrupted.
        call SetAddressAbilityDisabled( ConvertHandle( a ), count )
    endfunction

    function GetAbilityDisabled takes ability a returns integer
        return GetAddressAbilityDisabled( ConvertHandle( a ) )
    endfunction

    function SetAbilityHidden takes ability a, integer count returns nothing
        // This one is 100% safe. This hides the ability button, and order can’t be issued.
        call SetAddressAbilityHidden( ConvertHandle( a ), count ) // -1 = unhide | 1 = hide
    endfunction

    function AddAbilityHidden takes ability a, integer count returns nothing
        call AddAddressAbilityHidden( ConvertHandle( a ), count )
    endfunction

    function GetAbilityDisabledEx takes ability a returns integer
        // This one is used by Orb of Slow. Button is blacked, but cooldown is stil displayed.
        return GetAddressAbilityDisabledEx( ConvertHandle( a ) )
    endfunction

    function SetAbilityDisabledEx takes ability a, integer count returns nothing
        // This one is used by Orb of Slow. Button is blacked, but cooldown is stil displayed.
        call SetAddressAbilityDisabledEx( ConvertHandle( a ), count ) // -1 = unhide | 1 = hide
    endfunction

    function SilenceAbility takes ability a returns nothing
        call SilenceAddressAbility( ConvertHandle( a ) )
    endfunction

    function UnsilenceAbility takes ability a returns nothing
        call UnsilenceAddressAbility( ConvertHandle( a ) )
    endfunction

    function ShowAbility takes ability a, boolean flag returns nothing
        call ShowAddressAbility( ConvertHandle( a ), flag )
    endfunction
    //===========================================

    // Buff API
    function GetBuffLevel takes buff b returns integer
        return GetAddressBuffLevel( ConvertHandle( b ) )
    endfunction
    //===========================================

    function Init_MemHackAbilityNormalAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
        elseif PatchVersion == "1.26a" then
        elseif PatchVersion == "1.27a" then
        elseif PatchVersion == "1.27b" then
        elseif PatchVersion == "1.28f" then
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackAbilityNormalAPI takes nothing returns nothing
    //set gg_trg_MemHackAbilityNormalAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackAbilityUnitAPI
//===========================================================================
//TESH.scrollpos=30
//TESH.alwaysfold=0
//! nocjass
library MemoryHackAbilityUnitAPI
    globals
        integer pGetUnitAbility             = 0
        integer pAddUnitAbility             = 0
        integer pRemoveUnitAbility          = 0
    endglobals

    // CUnit Ability API
    function GetUnitAbilityReal takes integer pUnit, integer aid, integer unk1, integer unk2, integer unk3, integer unk4 returns integer 
        if pUnit > 0 and aid > 0 then
            return this_call_6( pGetUnitAbility, pUnit, aid, unk1, unk2, unk3, unk4 )
        endif

        return 0
    endfunction

    function CUnitAddAbility takes integer pUnit, integer aid returns boolean
        if pUnit != 0 and aid != 0 then
            return fast_call_5( pAddUnitAbility, pUnit, aid, 0, 0, 0 ) > 0
        endif

        return false
    endfunction

    function CUnitRemoveAbility takes integer pUnit, integer pAbil returns boolean
        if pUnit != 0 and pAbil != 0 then
            call this_call_2( pRemoveUnitAbility, pUnit, pAbil )
            return true
        endif

        return false
    endfunction

    function CUnitRemoveAbilityById takes integer pUnit, integer aid returns boolean
        local integer pAbil = 0

        if pUnit != 0 and aid != 0 then
            set pAbil = GetUnitAbilityReal( pUnit, aid, 0, 1, 1, 1 )

            if pAbil != 0 then
                return CUnitRemoveAbility( pUnit, pAbil )
            endif
        endif

        return false
    endfunction
    //===========================================
    
    // jUnit Ability API
    function GetUnitAbilityData takes unit u, integer aid, integer flag returns integer
        local integer pUnit

        if u != null and aid > 0 then
            set pUnit = ConvertHandle( u )

            if pUnit > 0 then
                return GetUnitAbilityReal( pUnit, aid, 0, flag, 1, 1 )
            endif
        endif

        return 0
    endfunction

    function GetUnitAbility takes unit u, integer aid returns integer
        if GetUnitAbilityLevel( u, aid ) > 0 then
            return GetUnitAbilityData( u, aid, 1 )
        endif

        return 0
    endfunction
    
    function GetUnitJAbility takes unit u, integer aid returns ability
        return ObjectToAbility( GetUnitAbility( u, aid ) )
    endfunction

    function AddUnitAbility takes unit u, integer aid returns boolean
        return CUnitAddAbility( ConvertHandle( u ), aid )
    endfunction

    function RemoveUnitAbility takes unit u, integer aid, boolean removeduplicates returns nothing
        call CUnitRemoveAbility( ConvertHandle( u ), aid )
    endfunction

    function GetUnitAbilityBase takes unit u, integer aid returns integer
        return GetUnitAbilityData( u, aid, 0 )
    endfunction

    function GetUnitAbilityOrderId takes unit u, integer aid returns integer
        return GetAddressAbilityOrderId( GetUnitAbility( u, aid ) )
    endfunction

    function IsUnitAbilityOnCooldown takes unit u, integer aid returns boolean
        return IsAddressAbilityOnCooldown( GetUnitAbility( u, aid ) )
    endfunction

    function IsUnitAbilitySafe takes unit u, integer aid returns boolean
        return IsAddressAbilitySafe( GetUnitAbility( u, aid ) )
    endfunction

    function IsUnitAbilityUsable takes unit u, integer aid returns boolean
        return IsAddressAbilityUsable( GetUnitAbility( u, aid ) )
    endfunction

    function GetUnitAbilityCastpoint takes unit u, integer aid returns real
        return GetAddressAbilityCastpoint( GetUnitAbility( u, aid ) )
    endfunction

    function SetUnitAbilityCastpoint takes unit u, integer aid, real dur returns nothing
        call SetAddressAbilityCastpoint( GetUnitAbility( u, aid ), dur )
    endfunction

    function GetUnitAbilityBackswing takes unit u, integer aid returns real
        return GetAddressAbilityBackswing( GetUnitAbility( u, aid ) )
    endfunction

    function SetUnitAbilityBackswing takes unit u, integer aid, real dur returns nothing
        call SetAddressAbilityBackswing( GetUnitAbility( u, aid ), dur )
    endfunction

    function GetUnitAbilityManaCost takes unit u, integer aid, integer level returns integer
        return GetAddressAbilityManaCost( GetUnitAbility( u, aid ), level )
    endfunction

    function SetUnitAbilityManaCost takes unit u, integer aid, integer level, integer mc returns nothing
        call SetAddressAbilityManaCost( GetUnitAbility( u, aid ), level, mc )
    endfunction

    function GetUnitAbilityCooldownStamp takes unit u, integer aid returns real
        //This actually returns the timestamp, not the cooldown. To get the real cooldown you need to subtract this from the current game time.
        return GetAddressAbilityCooldownStamp( GetUnitAbility( u, aid ) )
    endfunction

    function GetUnitAbilityCurrentCooldown takes unit u, integer aid returns real
        //This value holds the base cooldown of the ability at the last time it was casted. It’s used to calculate the % of elapsed cooldown.
        //This is completely irrelevant for the gameplay, it’s used only to determine which frame of the cooldown model will be displayed.
        return GetAddressAbilityCurrentCooldown( GetUnitAbility( u, aid ) )
    endfunction

    function SetUnitAbilityCooldown takes unit u, integer aid, real seconds, string mode returns nothing
        call SetAddressAbilityCooldown( GetUnitAbility( u, aid ), seconds, mode )
    endfunction

    function AddUnitAbilityCooldown takes unit u, integer aid, real seconds returns nothing
        call SetUnitAbilityCooldown( u, aid, seconds, "+" )
    endfunction

    function ReduceUnitAbilityCooldown takes unit u, integer aid, real seconds returns nothing
        call SetUnitAbilityCooldown( u, aid, seconds, "-" )
    endfunction

    function ResetUnitAbilityCooldown takes unit u, integer aid returns nothing
        call SetUnitAbilityCooldown( u, aid, -1., "" )
    endfunction

    function StartUnitAbilityCooldown takes unit u, integer aid, real cd returns nothing
        call StartAddressAbilityCooldown( GetUnitAbility( u, aid ), cd )
    endfunction

    function GetUnitAbilityCastTime takes unit u, integer aid returns real
        return GetAddressAbilityCastTime( GetUnitAbility( u, aid ) )
    endfunction

    function SetUnitAbilityCastTime takes unit u, integer aid, real r returns nothing
        call SetAddressAbilityCastTime( GetUnitAbility( u, aid ), r )
    endfunction

    function SetUnitAbilityDisabled takes unit u, integer aid, integer count returns nothing
        // not safe unless used with PauseUnit. Button will be blacked, but current casts of that ability won’t be interrupted.
        call SetAddressAbilityDisabled( GetUnitAbility( u, aid ), count )
    endfunction

    function GetUnitAbilityDisabled takes unit u, integer aid returns integer
        return GetAddressAbilityDisabled( GetUnitAbility( u, aid ) )
    endfunction

    function SetUnitAbilityHidden takes unit u, integer aid, integer count returns nothing
        // This one is 100% safe. This hides the ability button, and order can’t be issued.
        call SetAddressAbilityHidden( GetUnitAbility( u, aid ), count ) // -1 = unhide | 1 = hide
    endfunction

    function AddUnitAbilityHidden takes unit u, integer aid, integer count returns nothing
        call AddAddressAbilityHidden( GetUnitAbility( u, aid ), count )
    endfunction

    function GetUnitAbilityDisabledEx takes unit u, integer aid returns integer
        // This one is used by Orb of Slow. Button is blacked, but cooldown is stil displayed.
        return GetAddressAbilityDisabledEx( GetUnitAbility( u, aid ) )
    endfunction

    function SetUnitAbilityDisabledEx takes unit u, integer aid, integer count returns nothing
        // This one is used by Orb of Slow. Button is blacked, but cooldown is stil displayed.
        call SetAddressAbilityDisabledEx( GetUnitAbility( u, aid ), count ) // -1 = unhide | 1 = hide
    endfunction

    function SilenceUnitAbility takes unit u, integer aid returns nothing
        call SilenceAddressAbility( GetUnitAbility( u, aid ) )
    endfunction

    function UnsilenceUnitAbility takes unit u, integer aid returns nothing
        call UnsilenceAddressAbility( GetUnitAbility( u, aid ) )
    endfunction

    function ShowUnitAbility takes unit u, integer aid, boolean flag returns nothing
        call ShowAddressAbility( GetUnitAbility( u, aid ), flag )
    endfunction
    //===========================================

    // Buff API
    function GetUnitBuffLevel takes unit u, integer bid returns integer
        return GetAddressBuffLevel( GetUnitAbility( u, bid ) )
    endfunction
    //===========================================
    
    function Init_MemHackAbilityUnitAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pGetUnitAbility     = pGameDLL + 0x079400
                set pAddUnitAbility     = pGameDLL + 0x24D900
                set pRemoveUnitAbility  = pGameDLL + 0x07A8F0
        elseif PatchVersion == "1.26a" then
                set pGetUnitAbility     = pGameDLL + 0x0787D0
                set pAddUnitAbility     = pGameDLL + 0x24CDF0
                set pRemoveUnitAbility  = pGameDLL + 0x079CC0
        elseif PatchVersion == "1.27a" then
                set pGetUnitAbility     = pGameDLL + 0x46F440
                set pAddUnitAbility     = pGameDLL + 0x454EB0
                set pRemoveUnitAbility  = pGameDLL + 0x471160
        elseif PatchVersion == "1.27b" then
                set pGetUnitAbility     = pGameDLL + 0x48CB80
                set pAddUnitAbility     = pGameDLL + 0x4725F0
                set pRemoveUnitAbility  = pGameDLL + 0x48E8A0
        elseif PatchVersion == "1.28f" then
                set pGetUnitAbility     = pGameDLL + 0x4C0C90
                set pAddUnitAbility     = pGameDLL + 0x4A6700
                set pRemoveUnitAbility  = pGameDLL + 0x4C29B0
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackAbilityUnitAPI takes nothing returns nothing
    //set gg_trg_MemHackAbilityUnitAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCastAbility
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCastAbility
    globals
        integer pCastAbility = 0
    endglobals

    function CastAbilityPosition takes integer aid, unit source, real targX, real targY returns nothing
        // Fits for non-target spells, i.e. Was Stomp and such...
        local integer pData = ConvertHandle( source )

        if pData > 0 then
            set pData = GetUnitAbility( source, aid )

            if pData > 0 then
                call WriteRealMemory( pData + 0xF8, SetRealIntoMemory( targX ) )
                call WriteRealMemory( pData + 0x100, SetRealIntoMemory( targY ) )
                call WriteRealMemory( pData + 0x20, 0x9800 )
                set pData = this_call_1( pCastAbility, pData )
            endif
        endif
    endfunction

    function CastAbilityTarget takes integer aid, unit source, widget target returns nothing
        // Due to memory issues requires std/this calls to use different memory allocation
        // else spells which deals damage immediately on cast will interference with damage-related functions
        // hence why we use separate memory addresses for each unique stdcall and such.
        local integer pData  = 0
        local integer unitHashA = 0
        local integer unitHashB = 0
        local integer flags  = 0

        if GetUnitAbilityLevel( source, aid ) > 0 and target != null then
            set pData = ConvertHandle( target )

            if pData > 0 then
                set unitHashA = ReadRealMemory( pData + 0x0C )
                set unitHashB = ReadRealMemory( pData + 0x10 )

                if unitHashA > 0 and unitHashB > 0 then
                    set pData = ConvertHandle( source )

                    if pData > 0 then
                        set pData = GetUnitAbility( source, aid )

                        if pData > 0 then
                            // Widget is saved via HashGroup, hence we grab our units HashA and HashB and save them to TargetHashGroup
                            call WriteRealMemory( pData + 0xE4, unitHashA )
                            call WriteRealMemory( pData + 0xE8, unitHashB )
                            set flags = ReadRealMemory( pData + 0x20 )

                            if not IsFlagBitSet( flags, 0x10000 ) then
                                // 0x19804 stands for "target", 0x1F020 stands for "target item", 0x9800 stands for point target
                                call WriteRealMemory( pData + 0x20, flags + 0x10000 )
                                set flags = flags + 0x10000
                                if not IsFlagBitSet( flags, 0x1 ) then
                                    call WriteRealMemory( pData + 0x20, flags + 0x1 )
                                endif
                            endif

                            set pData = this_call_1( pCastAbility, pData ) // If value > 0 then cast has been successful.
                        endif
                    endif
                endif
            endif
        endif
    endfunction

    function CastAbilityTargetGround takes integer aid, unit source, integer lvl, real targX, real targY, boolean remove returns nothing
        call UnitAddAbility( source, aid )

        if lvl > 1 then
            call SetUnitAbilityLevel( source, aid, lvl )
        endif

        call CastAbilityPosition( aid, source, targX, targY )
        if remove then
            // Note: channeled abilities stop as soon as ability is removed!
            // This Applies to Chain Lightning and such.
            call UnitRemoveAbility( source, aid )
        endif
    endfunction

    function CastAbilityTargetWidget takes integer aid, unit source, widget target, integer lvl, boolean remove returns nothing
        call UnitAddAbility( source, aid )

        if lvl > 1 then
            call SetUnitAbilityLevel( source, aid, lvl )
        endif

        call CastAbilityTarget( aid, source, target )
        if remove then
            // Note: channeled abilities stop as soon as ability is removed!
            // This Applies to Chain Lightning and such.
            call UnitRemoveAbility( source, aid )
        endif
    endfunction

    function CastAbilityTargetSelf takes integer aid, unit source, integer lvl returns nothing
        call CastAbilityTargetWidget( aid, source, source, lvl, true )
    endfunction
    
    function Init_MemHackCastAbility takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pCastAbility = pGameDLL + 0x05CFD0
        elseif PatchVersion == "1.26a" then
                set pCastAbility = pGameDLL + 0x05C3A0
        elseif PatchVersion == "1.27a" then
                set pCastAbility = pGameDLL + 0x3ECB70
        elseif PatchVersion == "1.27b" then
                set pCastAbility = pGameDLL + 0x40A2B0
        elseif PatchVersion == "1.28f" then
                set pCastAbility = pGameDLL + 0x43E390
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackCastAbility takes nothing returns nothing
    //set gg_trg_MemHackCastAbility = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackWidgetBaseAPI
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCWidgetBaseAPI
    globals

    endglobals

    // Widget API Engine
    function GetWidgetTypeId takes widget w returns integer
        local integer pWidget = 0
        
        if w != null then
            set pWidget = ConvertHandle( w )
            
            if pWidget != 0 then
                return ReadRealMemory( pWidget + 0x30 )
            endif
        endif

        return 0
    endfunction

    function GetWidgetBaseDataById takes integer pDataNode, integer wid returns integer
        return GetAgileDataNodeById( pDataNode, wid )
    endfunction
    
    function GetWidgetBaseUIDataById takes integer id returns integer
        return GetWidgetUIDefById( id )
    endfunction

    function GetWidgetBaseData takes integer pDataNode, widget w returns integer
        return GetAgileDataNodeById( pDataNode, GetWidgetTypeId( w ) )
    endfunction

    function GetWidgetBaseDataByIdCachingEx takes integer pDataNode, integer index, integer id, integer mode returns integer
        local integer pData = 0

        if id > 0 then
            if HaveSavedInteger( htObjectDataPointers, index, id ) then 
                return LoadInteger( htObjectDataPointers, index, id )
            endif

            if mode == 0 then
                set pData = GetWidgetBaseDataById( pDataNode, id )
            elseif mode == 1 then
                set pData = GetWidgetBaseUIDataById( id )
            endif

            if pData > 0 then
                call SaveInteger( htObjectDataPointers, index, id, pData )
            endif

            return pData
        endif

        return 0
    endfunction
    
    function GetWidgetBaseDataByIdCaching takes integer pDataNode, integer id returns integer
        return GetWidgetBaseDataByIdCachingEx( pDataNode, 2, id, 0 ) // DEF_ADR_UNIT_DATA = 2 | BaseData = 0
    endfunction

    function GetWidgetBaseDataCaching takes integer pDataNode, widget w returns integer
        return GetWidgetBaseDataByIdCaching( pDataNode, GetWidgetTypeId( w ) )
    endfunction

    function GetWidgetBaseUIData takes widget w returns integer
        return GetWidgetBaseUIDataById( GetWidgetTypeId( w ) )
    endfunction

    function GetWidgetBaseUIDataByIdCaching takes integer id returns integer
        return GetWidgetBaseDataByIdCachingEx( 0, 3, id, 1 ) // DEF_ADR_UNIT_UI = 3 | UI = 1
    endfunction

    function GetWidgetBaseUIDataCaching takes widget w returns integer
        return GetWidgetBaseUIDataByIdCaching( GetWidgetTypeId( w ) )
    endfunction
    //===========================================
    
    // Widget Base UI Data Engine
    function GetWidgetBaseUIIntegerParamById takes integer id, integer pointerlevel, integer offset returns integer
        local integer pData = 0

        if id > 0 then
            set pData = GetWidgetBaseUIDataByIdCaching( id )

            if pData > 0 then
                set pData = ReadRealMemory( pData + offset )

                if pData > 0 then
                    if pointerlevel == 0 then
                        return pData
                elseif pointerlevel == 1 then
                        return ReadRealMemory( pData )
                    endif
                endif
            endif
        endif
        
        return 0
    endfunction

    function SetWidgetBaseUIIntegerParamById takes integer id, integer pointerlevel, integer offset, integer val returns nothing
        local integer pData = 0

        if id > 0 then
            set pData = GetWidgetBaseUIDataByIdCaching( id )

            if pData > 0 then
                set pData = pData + offset

                if offset == 0x274 then
                    call WriteRealMemory( pData, pData - 0x4 )
                else
                    if pointerlevel == 0 then
                        call WriteRealMemory( pData, val )
                elseif pointerlevel == 1 then
                        if ReadRealMemory( pData ) == 0 then
                            call WriteRealMemory( pData, GetStringAddress( I2S( val ) ) )
                        endif
                        call WriteRealMemory( ReadRealMemory( pData ), val )
                    endif
                endif
            endif
        endif
    endfunction

    function GetWidgetBaseUIStringParamById takes integer id, integer pointerlevel, integer offset returns string
        local integer pData = 0

        if id > 0 then
            set pData = GetWidgetBaseUIDataByIdCaching( id )

            if pData > 0 then
                set pData = ReadRealMemory( pData + offset )

                if pData > 0 then
                    if pointerlevel == 1 then
                        set pData = ReadRealMemory( pData )
                    endif

                    if pData > 0 then
                        return ToJString( pData )
                    endif
                endif
            endif
        endif

        return null
    endfunction

    function SetWidgetBaseUIStringParamById takes integer id, integer pointerlevel, integer offset, string val returns nothing
        local integer pData = 0

        if id > 0 then
            set pData = GetWidgetBaseUIDataByIdCaching( id )

            if pData > 0 then
                set pData = pData + offset

                if pointerlevel == 0 then
                    call WriteRealMemory( pData, GetStringAddress( val ) )
            elseif pointerlevel == 1 then
                    if ReadRealMemory( pData ) == 0 then
                        call WriteRealMemory( pData, GetStringAddress( val ) )
                    endif
                    call WriteRealMemory( ReadRealMemory( pData ), GetStringAddress( val ) )
                endif
            endif
        endif
    endfunction
    
    function Init_MemHackCWidgetBaseAPI takes nothing returns nothing
        if PatchVersion != "" then

        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackWidgetBaseAPI takes nothing returns nothing
    //set gg_trg_MemHackWidgetBaseAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackWidgetNormalAPI
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCWidgetAPI
    globals
        integer pGetAxisZ               = 0
        integer pGetAgentInternal       = 0
        integer pGetPressenseTagged     = 0
        integer pAgentUpdate            = 0
        integer pSetWidgetPosition      = 0
        integer pSetWidgetCoordinates   = 0
    endglobals

    function GetTerrainZ takes real axisX, real axisY returns real // Use at your own risk...
        if pGetAxisZ > 0 then
            return GetRealFromMemory( fast_call_5( pGetAxisZ, -1, 0, SetRealIntoMemory( axisX ), SetRealIntoMemory( axisY ), 1 ) ) // Function returns double, probably can't handle it in Jass :\
        endif

        return 0.
    endfunction

    function GetWidgetTerrainZ takes widget Widget returns real
        if Widget != null then
            return GetTerrainZ( GetWidgetX( Widget ), GetWidgetY( Widget ) )
        endif

        return 0.
    endfunction

    function SetWidgetCoordinates takes widget Widget, real x, real y returns integer
        // This does NOT work for destructables/doodads
        local integer pWidget = ConvertHandle( Widget )

        if pWidget > 0 and pSetWidgetCoordinates > 0 then
            call WriteRealMemory( pReservedIntArg1, SetRealIntoMemory( x ) )
            call WriteRealMemory( pReservedIntArg2, SetRealIntoMemory( y ) )
            return this_call_12( pSetWidgetCoordinates, pWidget, pReservedIntArg1, pReservedIntArg2, 1, 1, -1, 0, 0, 0, 0, -1, 0 )
        endif

        return 0
    endfunction

    function SetWidgetPosition takes widget Widget, real x, real y returns integer
        // Works for destructables/doodads/items/units
        local integer pWidget = ConvertHandle( Widget )
        local integer pVal1 = 0
        local integer pVal2 = 0

        if pWidget > 0 then
            if BitwiseAnd( ReadRealMemory( pWidget + 0x8C ), ReadRealMemory( pWidget + 0x90 ) ) != -1 and pGetAgentInternal > 0 then
                set pVal1 = this_call_1( pGetAgentInternal, pWidget + 0x8C )

                if pVal1 > 0 and pGetPressenseTagged > 0 then
                    set pVal2 = fast_call_2( pGetPressenseTagged, ReadRealMemory( pVal1 + 0xC ), ReadRealMemory( pVal1 + 0x10 ) )

                    if pVal2 > 0 and pAgentUpdate > 0 then
                        if ReadRealMemory( pVal2 + 0x0C ) == 727803756 and ReadRealMemory( pVal2 + 0x20 ) == 0 then
                            call this_call_2( pAgentUpdate, pVal1, pWidget )
                        endif
                    endif
                endif
            endif

            if pSetWidgetPosition > 0 then
                call WriteRealMemory( pReservedIntArg1, SetRealIntoMemory( x ) )
                call WriteRealMemory( pReservedIntArg2, SetRealIntoMemory( y ) )
                return this_call_4( pSetWidgetPosition, pWidget, pReservedIntArg1, pReservedIntArg2, -1 )
            endif
        endif

        return 0
    endfunction

    function SetDestructablePosition takes destructable dest, real x, real y returns integer
        return SetWidgetPosition( dest, x, y )
    endfunction
    
    function SetWidgetFacing takes widget Widget, real facing returns nothing
        local integer pWidget = ConvertHandle( Widget )

        if pWidget != 0 then
            call SetObjectFacing( pWidget, facing )
        endif
    endfunction
    
    function Init_MemHackCWidgetNormalAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pGetAxisZ               = pGameDLL + 0x24FEF0
                set pGetAgentInternal       = pGameDLL + 0x4791C0
                set pGetPressenseTagged     = pGameDLL + 0x040770
                set pAgentUpdate            = pGameDLL + 0x283960
                set pSetWidgetPosition      = pGameDLL + 0x2B7600
                set pSetWidgetCoordinates   = pGameDLL + 0x2E6EC0
        elseif PatchVersion == "1.26a" then
                set pGetAxisZ               = pGameDLL + 0x24F3E0
                set pGetAgentInternal       = pGameDLL + 0x4786B0
                set pGetPressenseTagged     = pGameDLL + 0x03FA30
                set pAgentUpdate            = pGameDLL + 0x282E40
                set pSetWidgetPosition      = pGameDLL + 0x2B6AE0
                set pSetWidgetCoordinates   = pGameDLL + 0x2AC220
        elseif PatchVersion == "1.27a" then
                set pGetAxisZ               = pGameDLL + 0x6320B0
                set pGetAgentInternal       = pGameDLL + 0x044150
                set pGetPressenseTagged     = pGameDLL + 0x037350
                set pAgentUpdate            = pGameDLL + 0x6775B0
                set pSetWidgetPosition      = pGameDLL + 0x63CC10
                set pSetWidgetCoordinates   = pGameDLL + 0x635DE0
        elseif PatchVersion == "1.27b" then
                set pGetAxisZ               = pGameDLL + 0x64F7E0
                set pGetAgentInternal       = pGameDLL + 0x061320
                set pGetPressenseTagged     = pGameDLL + 0x054530
                set pAgentUpdate            = pGameDLL + 0x694CE0
                set pSetWidgetPosition      = pGameDLL + 0x65A340
                set pSetWidgetCoordinates   = pGameDLL + 0x9D7AC0
        elseif PatchVersion == "1.28f" then
                set pGetAxisZ               = pGameDLL + 0x683900
                set pGetAgentInternal       = pGameDLL + 0x08AE90
                set pGetPressenseTagged     = pGameDLL + 0x07E090
                set pAgentUpdate            = pGameDLL + 0x6C8EA0
                set pSetWidgetPosition      = pGameDLL + 0x2B6AE0
                set pSetWidgetCoordinates   = pGameDLL + 0x98CA60
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackWidgetNormalAPI takes nothing returns nothing
    //set gg_trg_MemHackWidgetNormalAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackEffectAPI
//===========================================================================
//TESH.scrollpos=143
//TESH.alwaysfold=0
//! nocjass
library MemoryHackEffectAPI
    globals
    
    endglobals

    function IsEffectHidden takes effect e returns boolean
        return IsObjectHidden( ConvertHandle( e ) )
    endfunction

    function ShowEffect takes effect e, boolean flag returns nothing
        call ShowObject( ConvertHandle( e ), flag )
    endfunction

    function SetEffectAlpha takes effect e, integer alpha returns nothing
        call SetObjectAlpha( ConvertHandle( e ), alpha )
    endfunction

    function GetEffectColour takes effect e returns integer
        return GetObjectColour( ConvertHandle( e ) )
    endfunction

    function SetEffectColour takes effect e, integer colour returns nothing
        call SetObjectColour( ConvertHandle( e ), colour )
    endfunction

    function SetEffectColourEx takes effect e, integer red, integer green, integer blue, integer alpha returns nothing
        call SetObjectColourEx( ConvertHandle( e ), red, green, blue, alpha )
    endfunction

    function SetEffectVertexColour takes effect e, integer red, integer green, integer blue, integer alpha returns nothing
        local integer pObject = ConvertHandle( e )

        if pObject > 0 then
            call SetObjectColourEx( pObject, red, green, blue, alpha )
            call SetObjectAlpha( pObject, alpha )
        endif
    endfunction

    function GetEffectColourA takes effect e returns integer
        return GetObjectColourA( ConvertHandle( e ) )
    endfunction

    function SetEffectColourA takes effect e, integer alpha returns nothing
        call SetObjectColourA( ConvertHandle( e ), alpha )
    endfunction

    function GetEffectColourR takes effect e returns integer
        return GetObjectColourR( ConvertHandle( e ) )
    endfunction

    function SetEffectColourR takes effect e, integer red returns nothing
        call SetObjectColourR( ConvertHandle( e ), red )
    endfunction

    function GetEffectColourG takes effect e returns integer
        return GetObjectColourG( ConvertHandle( e ) )
    endfunction

    function SetEffectColourG takes effect e, integer green returns nothing
        call SetObjectColourG( ConvertHandle( e ), green )
    endfunction

    function GetEffectColourB takes effect e returns integer
        return GetObjectColourB( ConvertHandle( e ) )
    endfunction

    function SetEffectColourB takes effect e, integer blue returns nothing
        call SetObjectColourB( ConvertHandle( e ), blue )
    endfunction

    function SetEffectAnimationByIndex takes effect e, integer index returns nothing
        call SetObjectAnimationByIndex( ConvertHandle( e ), index )
    endfunction

    function SetEffectModel takes effect e, string model returns nothing
        call SetObjectModel( ConvertHandle( e ), model )
    endfunction

    function GetEffectX takes effect e returns real
        return GetObjectX( ConvertHandle( e ) )
    endfunction

    function SetEffectX takes effect e, real x returns nothing
        call SetObjectX( ConvertHandle( e ), x )
    endfunction

    function GetEffectY takes effect e returns real
        return GetObjectY( ConvertHandle( e ) )
    endfunction

    function SetEffectY takes effect e, real y returns nothing
        call SetObjectY( ConvertHandle( e ), y )
    endfunction

    function GetEffectZ takes effect e returns real
        return GetObjectZ( ConvertHandle( e ) )
    endfunction

    function SetEffectZ takes effect e, real z returns nothing
        call SetObjectZ( ConvertHandle( e ), z )
    endfunction

    function SetEffectPosition takes effect e, real x, real y, real z returns nothing
        call SetObjectPosition( ConvertHandle( e ), x, y, z )
    endfunction

    function GetEffectTimeScale takes effect e returns real
        return GetObjectTimeScale( ConvertHandle( e ) )
    endfunction

    function SetEffectTimeScale takes effect e, real speed returns nothing
        call SetObjectTimeScale( ConvertHandle( e ), speed )
    endfunction

    function GetEffectScale takes effect e returns real
        return GetObjectScale( ConvertHandle( e ) )
    endfunction

    function SetEffectScale takes effect e, real scale returns nothing
        call SetObjectScale( ConvertHandle( e ), scale )
    endfunction

    function SetEffectScaleEx takes effect e, real x, real y, real z returns nothing
        call SetObjectScaleEx( ConvertHandle( e ), x, y, z )
    endfunction

    function GetEffectRoll takes effect e returns real // X | returns Degrees!
        return GetObjectRoll( ConvertHandle( e ) )
    endfunction

    function SetEffectRoll takes effect e, real angle returns nothing
        call SetObjectRoll( ConvertHandle( e ), angle )
    endfunction

    function GetEffectPitch takes effect e returns real // Y | returns Degrees!
        return GetObjectPitch( ConvertHandle( e ) )
    endfunction

    function SetEffectPitch takes effect e, real angle returns nothing // Y | In Degrees!
        call SetObjectPitch( ConvertHandle( e ), angle )
    endfunction

    function GetEffectYaw takes effect e returns real // Z | Yaw | returns Degrees!
        return GetObjectYaw( ConvertHandle( e ) )
    endfunction
    
    function GetEffectFacing takes effect e returns real // Z | Yaw | returns Degrees!
        return GetObjectFacing( ConvertHandle( e ) )
    endfunction

    function SetEffectYaw takes effect e, real angle returns nothing // Z | Yaw | In Degrees!
        call SetObjectYaw( ConvertHandle( e ), angle )
    endfunction

    function SetEffectFacing takes effect e, real angle returns nothing // Z | Yaw | In Degrees!
        call SetObjectFacing( ConvertHandle( e ), angle )
    endfunction

    function SetEffectSpaceRotation takes effect e, real yaw, real pitch, real roll returns nothing
        call SetObjectSpaceRotation( ConvertHandle( e ), yaw, pitch, roll )
    endfunction

    function SetEffectOrientation takes effect e, real yaw, real pitch, real roll returns nothing
        call SetObjectOrientation( ConvertHandle( e ), yaw, pitch, roll )
    endfunction

    function ResetEffectMatrix takes effect e returns nothing
        call ResetObjectMatrix( ConvertHandle( e ) )
    endfunction

    function Init_MemHackEffectAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
        elseif PatchVersion == "1.26a" then
        elseif PatchVersion == "1.27a" then
        elseif PatchVersion == "1.27b" then
        elseif PatchVersion == "1.28f" then
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackEffectAPI takes nothing returns nothing
    //set gg_trg_MemHackEffectAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackTrackableAPI
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library MemoryHackTrackableAPI
    globals
    
    endglobals

    function IsTrackableHidden takes trackable track returns boolean
        return IsObjectHidden( ConvertHandle( track ) )
    endfunction
    
    function ShowTrackable takes trackable track, boolean flag returns nothing
        call ShowObject( ConvertHandle( track ), flag )
    endfunction
    
    function SetTrackableAlpha takes trackable track, integer alpha returns nothing
        call SetObjectAlpha( ConvertHandle( track ), alpha )
    endfunction
    
    function GetTrackableColour takes trackable track returns integer
        return GetObjectColour( ConvertHandle( track ) )
    endfunction
    
    function SetTrackableColour takes trackable track, integer colour returns nothing
        call SetObjectColour( ConvertHandle( track ), colour )
    endfunction
    
    function SetTrackableColourEx takes trackable track, integer red, integer green, integer blue, integer alpha returns nothing
        call SetObjectColourEx( ConvertHandle( track ), red, green, blue, alpha )
    endfunction

    function SetTrackableVertexColour takes trackable track, integer red, integer green, integer blue, integer alpha returns nothing
        local integer pObject = ConvertHandle( track )

        if pObject > 0 then
            call SetObjectColourEx( pObject, red, green, blue, alpha )
            call SetObjectAlpha( pObject, alpha )
        endif
    endfunction

    function GetTrackableColourA takes trackable track returns integer
        return GetObjectColourA( ConvertHandle( track ) )
    endfunction

    function SetTrackableColourA takes trackable track, integer alpha returns nothing
        call SetObjectColourA( ConvertHandle( track ), alpha )
    endfunction

    function GetTrackableColourR takes trackable track returns integer
        return GetObjectColourR( ConvertHandle( track ) )
    endfunction

    function SetTrackableColourR takes trackable track, integer red returns nothing
        call SetObjectColourR( ConvertHandle( track ), red )
    endfunction
    
    function GetTrackableColourG takes trackable track returns integer
        return GetObjectColourG( ConvertHandle( track ) )
    endfunction

    function SetTrackableColourG takes trackable track, integer green returns nothing
        call SetObjectColourG( ConvertHandle( track ), green )
    endfunction

    function GetTrackableColourB takes trackable track returns integer
        return GetObjectColourB( ConvertHandle( track ) )
    endfunction

    function SetTrackableColourB takes trackable track, integer blue returns nothing
        call SetObjectColourB( ConvertHandle( track ), blue )
    endfunction

    function SetTrackableAnimationByIndex takes trackable track, integer index returns nothing
        call SetObjectAnimationByIndex( ConvertHandle( track ), index )
    endfunction
    
    function SetTrackableModel takes trackable track, string model returns nothing
        call SetObjectModel( ConvertHandle( track ), model )
    endfunction

    function GetTrackableX takes trackable track returns real
        return GetObjectX( ConvertHandle( track ) )
    endfunction

    function SetTrackableX takes trackable track, real x returns nothing
        call SetObjectX( ConvertHandle( track ), x )
    endfunction

    function GetTrackableY takes trackable track returns real
        return GetObjectY( ConvertHandle( track ) )
    endfunction

    function SetTrackableY takes trackable track, real y returns nothing
        call SetObjectY( ConvertHandle( track ), y )
    endfunction

    function GetTrackableZ takes trackable track returns real
        return GetObjectZ( ConvertHandle( track ) )
    endfunction

    function SetTrackableZ takes trackable track, real z returns nothing
        call SetObjectZ( ConvertHandle( track ), z )
    endfunction

    function SetTrackablePosition takes trackable track, real x, real y, real z returns nothing
        call SetObjectPosition( ConvertHandle( track ), x, y, z )
    endfunction

    function GetTrackableTimeScale takes trackable track returns real
        return GetObjectTimeScale( ConvertHandle( track ) )
    endfunction

    function SetTrackableTimeScale takes trackable track, real speed returns nothing
        call SetObjectTimeScale( ConvertHandle( track ), speed )
    endfunction

    function GetTrackableScale takes trackable track returns real
        return GetObjectScale( ConvertHandle( track ) )
    endfunction

    function SetTrackableScale takes trackable track, real scale returns nothing
        call SetObjectScale( ConvertHandle( track ), scale )
    endfunction

    function SetTrackableScaleEx takes trackable track, real x, real y, real z returns nothing
        call SetObjectScaleEx( ConvertHandle( track ), x, y, z )
    endfunction

    function GetTrackableRoll takes trackable track returns real // X | returns Degrees!
        return GetObjectRoll( ConvertHandle( track ) )
    endfunction

    function SetTrackableRoll takes trackable track, real angle returns nothing
        call SetObjectRoll( ConvertHandle( track ), angle )
    endfunction

    function GetTrackablePitch takes trackable track returns real // Y | returns Degrees!
        return GetObjectPitch( ConvertHandle( track ) )
    endfunction

    function SetTrackablePitch takes trackable track, real angle returns nothing // Y | In Degrees!
        call SetObjectPitch( ConvertHandle( track ), angle )
    endfunction

    function GetTrackableYaw takes trackable track returns real // Z | Yaw | returns Degrees!
        return GetObjectYaw( ConvertHandle( track ) )
    endfunction
    
    function GetTrackableFacing takes trackable track returns real // Z | Yaw | returns Degrees!
        return GetObjectFacing( ConvertHandle( track ) )
    endfunction

    function SetTrackableYaw takes trackable track, real angle returns nothing // Z | Yaw | In Degrees!
        call SetObjectYaw( ConvertHandle( track ), angle )
    endfunction

    function SetTrackableFacing takes trackable track, real angle returns nothing // Z | Yaw | In Degrees!
        call SetObjectFacing( ConvertHandle( track ), angle )
    endfunction

    function SetTrackableSpaceRotation takes trackable track, real yaw, real pitch, real roll returns nothing
        call SetObjectSpaceRotation( ConvertHandle( track ), yaw, pitch, roll )
    endfunction

    function SetTrackableOrientation takes trackable track, real yaw, real pitch, real roll returns nothing
        call SetObjectOrientation( ConvertHandle( track ), yaw, pitch, roll )
    endfunction

    function ResetTrackableMatrix takes trackable track returns nothing
        call ResetObjectMatrix( ConvertHandle( track ) )
    endfunction

    function Init_MemHackTrackableAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
        elseif PatchVersion == "1.26a" then
        elseif PatchVersion == "1.27a" then
        elseif PatchVersion == "1.27b" then
        elseif PatchVersion == "1.28f" then
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackTrackableAPI takes nothing returns nothing
    //set gg_trg_MemHackTrackableAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackItemBaseAPI
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library MemoryHackItemBaseAPI
    globals
        integer pItemDataNode = 0
    endglobals

    // Item API Engine
    function GetItemBaseDataById takes integer iid returns integer
        return GetAgileDataNodeById( pItemDataNode, iid )
    endfunction

    function GetItemBaseData takes item it returns integer
        return GetItemBaseDataById( GetItemTypeId( it ) )
    endfunction

    function GetItemBaseDataByIdCaching takes integer iid returns integer
        return GetWidgetBaseDataByIdCachingEx( pItemDataNode, 2, iid, 0 ) // Base Item Data
    endfunction

    function GetItemBaseDataCaching takes item it returns integer
        return GetItemBaseDataByIdCaching( GetItemTypeId( it ) )
    endfunction

    function GetItemBaseUIDataById takes integer iid returns integer
        return GetWidgetBaseUIDataById( iid )
    endfunction

    function GetItemBaseUIData takes item it returns integer
        return GetItemBaseUIDataById( GetItemTypeId( it ) )
    endfunction

    function GetItemBaseUIDataByIdCaching takes integer iid returns integer
        return GetWidgetBaseDataByIdCachingEx( 0, 3, iid, 1 ) // Base Item UI Data | pUnitUIDataNode - no longer necessary
    endfunction

    function GetItemBaseUIDataCaching takes item it returns integer
        return GetItemBaseUIDataByIdCaching( GetItemTypeId( it ) )
    endfunction
    //===========================================

    // Item Base UI Data API by Id
    function GetItemBaseUIStringParamById takes integer iid, integer pointerlevel, integer offset returns string
        return GetWidgetBaseUIStringParamById( iid, pointerlevel, offset )
    endfunction
    
    function SetItemBaseUIStringParamById takes integer iid, integer pointerlevel, integer offset, string text returns nothing
        call SetWidgetBaseUIStringParamById( iid, pointerlevel, offset, text )
    endfunction

    function GetItemBaseNameById takes integer iid returns string
        return GetItemBaseUIStringParamById( iid, 1, 0x2C )
    endfunction

    function SetItemBaseNameById takes integer iid, string text returns nothing
        call SetItemBaseUIStringParamById( iid, 1, 0x2C, text )
    endfunction

    function GetItemBaseIconPathById takes integer iid returns string
        return GetItemBaseUIStringParamById( iid, 1, 0x24C )
    endfunction

    function SetItemBaseIconPathById takes integer iid, string text returns nothing
        call SetItemBaseUIStringParamById( iid, 1, 0x24C, text )
    endfunction
    
    function GetItemBaseTipById takes integer iid returns string
        return GetItemBaseUIStringParamById( iid, 1, 0x260 )
    endfunction

    function SetItemBaseTipById takes integer iid, string text returns nothing
        call SetItemBaseUIStringParamById( iid, 1, 0x260, text )
    endfunction

    function GetItemBaseUbertipById takes integer iid returns string
        return GetItemBaseUIStringParamById( iid, 1, 0x26C )
    endfunction

    function SetItemBaseUbertipById takes integer iid, string text returns nothing
        call SetItemBaseUIStringParamById( iid, 1, 0x26C, text )
    endfunction

    function GetItemBaseHotkeyById takes integer iid returns integer
        if iid > 0 then
            if GetWidgetBaseUIIntegerParamById( iid, 0, 0x270 ) > 0 or GetWidgetBaseUIIntegerParamById( iid, 0, 0x274 ) > 0 then
                return GetWidgetBaseUIIntegerParamById( iid, 1, 0x278 )
            endif
        endif
    
        return 0
    endfunction

    function SetItemBaseHotkeyById takes integer iid, integer key returns nothing
        if iid > 0 then
            call SetWidgetBaseUIIntegerParamById( iid, 0, 0x270,   1 )
            call SetWidgetBaseUIIntegerParamById( iid, 0, 0x274, key )
            call SetWidgetBaseUIIntegerParamById( iid, 1, 0x278, key )
        endif
    endfunction
    //===========================================
    
    // Item Base UI Data API
    function GetItemBaseUIStringParam takes item it, integer pointerlevel, integer offset returns string
        return GetItemBaseUIStringParamById( GetItemTypeId( it ), pointerlevel, offset )
    endfunction
    
    function SetItemBaseUIStringParam takes item it, integer pointerlevel, integer offset, string text returns nothing
        call SetItemBaseUIStringParamById( GetItemTypeId( it ), pointerlevel, offset, text )
    endfunction

    function GetItemBaseName takes item it returns string
        return GetItemBaseNameById( GetItemTypeId( it ) )
    endfunction

    function SetItemBaseName takes item it, string text returns nothing
        call SetItemBaseNameById( GetItemTypeId( it ), text )
    endfunction

    function GetItemBaseIconPath takes item it returns string
        return GetItemBaseIconPathById( GetItemTypeId( it ) )
    endfunction

    function SetItemBaseIconPath takes item it, string text returns nothing
        call SetItemBaseIconPathById( GetItemTypeId( it ), text )
    endfunction

    function GetItemBaseTip takes item it returns string
        return GetItemBaseTipById( GetItemTypeId( it ) )
    endfunction

    function SetItemBaseTip takes item it, string text returns nothing
        call SetItemBaseTipById( GetItemTypeId( it ), text )
    endfunction

    function GetItemBaseUbertip takes item it returns string
        return GetItemBaseUbertipById( GetItemTypeId( it ) )
    endfunction

    function SetItemBaseUbertip takes item it, string text returns nothing
        call SetItemBaseUbertipById( GetItemTypeId( it ), text )
    endfunction

    function GetItemBaseHotkey takes item it returns integer
        return GetItemBaseHotkeyById( GetItemTypeId( it ) )
    endfunction

    function SetItemBaseHotkey takes item it, integer key returns nothing
        call SetItemBaseHotkeyById( GetItemTypeId( it ), key )
    endfunction
    //===========================================
    
    // Item Base Data API by Id
    function GetItemBaseTypeIdById takes integer iid returns integer
        local integer pData = GetItemBaseDataById( iid )

        if pData > 0 then
            return ReadRealMemory( pData + 0x14 )
        endif

        return 0
    endfunction

    function GetItemBaseGoldCostById takes integer iid returns integer
        local integer pData = GetItemBaseDataById( iid )

        if pData > 0 then
            return ReadRealMemory( pData + 0x20 )
        endif

        return 0
    endfunction

    function SetItemBaseGoldCostById takes integer iid, integer cost returns nothing
        local integer pData = GetItemBaseDataById( iid )

        if pData > 0 then
            call WriteRealMemory( pData + 0x20, cost )
        endif
    endfunction

    function GetItemBaseLumberCostById takes integer iid returns integer
        local integer pData = GetItemBaseDataById( iid )

        if pData > 0 then
            return ReadRealMemory( pData + 0x24 )
        endif

        return 0
    endfunction

    function SetItemBaseLumberCostById takes integer iid, integer cost returns nothing
        local integer pData = GetItemBaseDataById( iid )

        if pData > 0 then
            call WriteRealMemory( pData + 0x24, cost )
        endif
    endfunction

    function GetItemBaseLevelById takes integer iid returns integer
        local integer pData = GetItemBaseDataById( iid )

        if pData > 0 then
            return ReadRealMemory( pData + 0x38 )
        endif

        return 0
    endfunction

    function SetItemBaseLevelById takes integer iid, integer level returns nothing
        local integer pData = GetItemBaseDataById( iid )

        if pData > 0 then
            call WriteRealMemory( pData + 0x38, level )
        endif
    endfunction

    function IsItemBaseSellableById takes integer iid returns boolean
        local integer pData = GetItemBaseDataById( iid )

        if pData > 0 then
            return ReadRealMemory( pData + 0x50 ) > 1
        endif

        return false
    endfunction

    function IsItemBasePawnableById takes integer iid returns boolean
        local integer pData = GetItemBaseDataById( iid )

        if pData > 0 then
            return ReadRealMemory( pData + 0x54 ) > 1
        endif

        return false
    endfunction

    function IsItemBaseDroppableById takes integer iid returns boolean
        local integer pData = GetItemBaseDataById( iid )

        if pData > 0 then
            return ReadRealMemory( pData + 0x60 ) > 1
        endif

        return false
    endfunction

    function IsItemBaseDroppedOnDeathById takes integer iid returns boolean
        local integer pData = GetItemBaseDataById( iid )

        if pData > 0 then
            return ReadRealMemory( pData + 0x64 ) > 1
        endif

        return false
    endfunction
    //===========================================

    // Item Base UI Data API
    function GetItemBaseTypeId takes item it returns integer
        return GetItemBaseTypeIdById( GetItemTypeId( it ) )
    endfunction

    function GetItemBaseGoldCost takes item it returns integer
        return GetItemBaseGoldCostById( GetItemTypeId( it ) )
    endfunction

    function SetItemBaseGoldCost takes item it, integer cost returns nothing
        call SetItemBaseGoldCostById( GetItemTypeId( it ), cost )
    endfunction

    function GetItemBaseLumberCost takes item it returns integer
        return GetItemBaseLumberCostById( GetItemTypeId( it ) )
    endfunction

    function SetItemBaseLumberCost takes item it, integer cost returns nothing
        call SetItemBaseLumberCostById( GetItemTypeId( it ), cost )
    endfunction

    function GetItemBaseLevel takes item it returns integer
        return GetItemBaseLevelById( GetItemTypeId( it ) )
    endfunction

    function SetItemBaseLevel takes item it, integer lvl returns nothing
        call SetItemBaseLevelById( GetItemTypeId( it ), lvl )
    endfunction

    function IsItemBaseSellable takes item it returns boolean
        return IsItemBaseSellableById( GetItemTypeId( it ) )
    endfunction

    function IsItemBasePawnable takes item it returns boolean
        return IsItemBasePawnableById( GetItemTypeId( it ) )
    endfunction

    function IsItemBaseDroppable takes item it returns boolean
        return IsItemBaseDroppableById( GetItemTypeId( it ) )
    endfunction

    function IsItemBaseDroppedOnDeath takes item it returns boolean
        return IsItemBaseDroppedOnDeathById( GetItemTypeId( it ) )
    endfunction
    //===========================================

    function Init_MemHackItemBaseAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pItemDataNode = pGameDLL + 0xACBA24
        elseif PatchVersion == "1.26a" then
                set pItemDataNode = pGameDLL + 0xAB4BCC
        elseif PatchVersion == "1.27a" then
                set pItemDataNode = pGameDLL + 0xBEC238
        elseif PatchVersion == "1.27b" then
                set pItemDataNode = pGameDLL + 0xD707A0
        elseif PatchVersion == "1.28f" then
                set pItemDataNode = pGameDLL + 0xD385D8
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackItemBaseAPI takes nothing returns nothing
    //set gg_trg_MemHackItemNormalAPI = CreateTrigger(  )
endfunction
//! endnocjass//===========================================================================
// Trigger: MemHackItemNormalAPI
//===========================================================================
//TESH.scrollpos=9
//TESH.alwaysfold=0
//! nocjass
library MemoryHackItemNormalAPI
    globals
        integer pStartItemCD = 0
    endglobals

    function CItemStartCooldown takes integer pUnit, integer pItem, real cd returns nothing
        local integer pInv  = 0

        if pUnit > 0 and pItem > 0 then
            set pInv = ReadRealMemory( pUnit + 0x1F8 )

            if pInv > 0 then
                call WriteRealMemory( pReservedWritableMemory, SetRealIntoMemory( cd ) )
                call this_call_4( pStartItemCD, pInv, pItem, pReservedWritableMemory, pReservedWritableMemory )
            endif
        endif
    endfunction

    function CItemSetTypeId takes integer pItem, integer id returns nothing
        local integer oldId   = 0

        if pItem > 0 then
            set oldId = ReadRealMemory( pItem + 0x30 )

            if oldId > 0 then
                call WriteRealMemory( pItem + 0x30, id )
            endif
        endif
    endfunction
    
    function CItemSetModel takes integer pItem, string model returns nothing
        call SetObjectModel( pItem, model )
    endfunction
    
    function CItemGetLife takes integer pItem returns real
        if pItem > 0 then
            return GetRealFromMemory( ReadRealMemory( pItem + 0x58 ) )
        endif
        
        return 0.
    endfunction

    function CItemSetLife takes integer pItem, real life returns nothing
        if pItem > 0 then
            call WriteRealMemory( pItem + 0x58, SetRealIntoMemory( life ) )
        endif
    endfunction

    function CItemGetMaxLife takes integer pItem returns real
        if pItem > 0 then
            return GetRealFromMemory( ReadRealMemory( pItem + 0x60 ) )
        endif
        
        return 0.
    endfunction

    function CItemSetMaxLife takes integer pItem, real life returns nothing
        if pItem > 0 then
            call WriteRealMemory( pItem + 0x60, SetRealIntoMemory( life ) )
        endif
    endfunction

    function StartItemCooldown takes unit u, item it, real cd returns nothing
        call CItemStartCooldown( ConvertHandle( u ), ConvertHandle( it ), cd )
    endfunction

    function SetItemIdType takes item it, integer id returns nothing
        call CItemSetTypeId( ConvertHandle( it ), id )
    endfunction
    
    function SetItemModel takes item it, string model returns nothing
        call CItemSetModel( ConvertHandle( it ), model )
    endfunction
    
    function GetItemLife takes item it returns real
        return CItemGetLife( ConvertHandle( it ) )
    endfunction

    function SetItemLife takes item it, real life returns nothing
        call CItemSetLife( ConvertHandle( it ), life )
    endfunction

    function GetItemMaxLife takes item it returns real
        return CItemGetMaxLife( ConvertHandle( it ) )
    endfunction

    function SetItemMaxLife takes item it, real life returns nothing
        call CItemSetMaxLife( ConvertHandle( it ), life )
    endfunction

    function Init_MemHackItemNormalAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pStartItemCD    = pGameDLL + 0x0E4B50
        elseif PatchVersion == "1.26a" then
                set pStartItemCD    = pGameDLL + 0x0E3F30
        elseif PatchVersion == "1.27a" then
                set pStartItemCD    = pGameDLL + 0x54C2E0
        elseif PatchVersion == "1.27b" then
                set pStartItemCD    = pGameDLL + 0x569A40
        elseif PatchVersion == "1.28f" then
                set pStartItemCD    = pGameDLL + 0x59DB70
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackItemNormalAPI takes nothing returns nothing
    //set gg_trg_MemHackItemNormalAPI = CreateTrigger(  )
endfunction
//! endnocjass//===========================================================================
// Trigger: MemHackUnitBaseAPI
//===========================================================================
//TESH.scrollpos=24
//TESH.alwaysfold=0
//! nocjass
library MemoryHackUnitBaseAPI
    globals
        integer pUnitDataNode       = 0
        integer pUnitUIDataNode     = 0
        integer pGetUnitUIData      = 0
    endglobals

    // Unit API Engine
    function GetUnitBaseDataById takes integer uid returns integer
        if uid > 0 then
            return GetAgileDataNodeById( pUnitDataNode, uid )
        endif

        return 0
    endfunction

    function GetUnitBaseData takes unit u returns integer
        return GetUnitBaseDataById( GetUnitTypeId( u ) )
    endfunction

    function GetUnitBaseDataByIdCaching takes integer uid returns integer
        // DEF_ADR_UNIT_DATA = 2
        local integer pUnit = 0

        if uid > 0 then
            if HaveSavedInteger( htObjectDataPointers, 2, uid ) then 
                return LoadInteger( htObjectDataPointers, 2, uid )
            endif

            set pUnit = GetUnitBaseDataById( uid )

            if pUnit > 0 then
                call SaveInteger( htObjectDataPointers, 2, uid, pUnit )
            endif

            return pUnit
        endif

        return 0
    endfunction

    function GetUnitBaseDataCaching takes unit u returns integer
        return GetUnitBaseDataByIdCaching( GetUnitTypeId( u ) )
    endfunction

    function GetUnitBaseUIDataById takes integer uid returns integer
        if uid > 0 then
           return this_call_1( pGetUnitUIData, uid )
        endif

        return 0
    endfunction

    function GetUnitBaseUIData takes unit u returns integer
        return GetUnitBaseUIDataById( GetUnitTypeId( u ) )
    endfunction

    function GetUnitBaseUIDataByIdCaching takes integer uid returns integer
        // DEF_ADR_UNIT_UI = 3
        local integer pUnit = 0

        if uid > 0 then
            if HaveSavedInteger( htObjectDataPointers, 3, uid ) then 
                return LoadInteger( htObjectDataPointers, 3, uid )
            endif

            set pUnit = GetUnitBaseUIDataById( uid )
            if pUnit > 0 then
                call SaveInteger( htObjectDataPointers, 3, uid, pUnit )
            endif

            return pUnit
        endif

        return 0
    endfunction

    function GetUnitBaseUIDataCaching takes unit u returns integer
        return GetUnitBaseUIDataByIdCaching( GetUnitTypeId( u ) )
    endfunction
    //===========================================

    // Unit Base UI Data Engine
    function GetUnitBaseUIIntegerParam takes integer uid, integer pointerlevel, integer offset returns integer
        return GetWidgetBaseUIIntegerParamById( uid, pointerlevel, offset )
    endfunction

    function SetUnitBaseUIIntegerParam takes integer uid, integer pointerlevel, integer offset, integer val returns nothing
        call SetWidgetBaseUIIntegerParamById( uid, pointerlevel, offset, val )
    endfunction

    function GetUnitBaseUIStringParam takes integer uid, integer pointerlevel, integer offset returns string
        return GetWidgetBaseUIStringParamById( uid, pointerlevel, offset )
    endfunction

    function SetUnitBaseUIStringParam takes integer uid, integer pointerlevel, integer offset, string val returns nothing
        call SetWidgetBaseUIStringParamById( uid, pointerlevel, offset, val )
    endfunction
    //===========================================
    
    // Unit Base UI Data API by Id
    function GetUnitBasePortraitById takes integer uid returns string
        local integer pData = 0

        if uid > 0 then
            set pData = GetUnitBaseUIDataByIdCaching( uid )

            if pData > 0 then
                set pData = ReadRealMemory( pData + 0x38 )

                if pData > 0 then
                    return ToJString( pData )
                endif
            endif
        endif

        return null
    endfunction

    function SetUnitBasePortraitById takes integer uid, string model returns nothing
        local integer pData = 0

        if uid > 0 then
            set pData = GetUnitBaseUIDataByIdCaching( uid )

            if pData > 0 then
                call WriteNullTerminatedString( model, pData + 0x38 )
            endif
        endif
    endfunction

    function GetUnitBaseMissileArtById takes integer uid, integer index returns string
        local integer pData = 0

        if uid > 0 then
            if index == 0 or index == 1 then
                set pData = GetUnitBaseUIDataByIdCaching( uid )
        
                if pData > 0 then
                    set pData = ReadRealMemory( pData + 0x44 )

                    if pData > 0 then
                        return ToJString( ReadRealMemory( pData + index * 4 ) )
                    endif
                endif
            endif
        endif

        return null
    endfunction

    function SetUnitBaseMissileArtById takes integer uid, string model, integer index returns nothing
        local integer pData = 0
    
        if uid > 0 then
            if index == 0 or index == 1 then
                set pData = GetUnitBaseUIDataByIdCaching( uid )

                if pData > 0 then
                    set pData = ReadRealMemory( pData + 0x44 )
        
                    if pData > 0 then
                        call WriteRealMemory( pData + index * 4, GetStringAddress( model ) )
                    endif
                endif
            endif
        endif
    endfunction

    function GetUnitBaseMissileSpeedById takes integer uid, integer index returns real
        local integer pData = 0

        if uid > 0 then
            if index == 0 or index == 1 then
                set pData = GetUnitBaseUIDataByIdCaching( uid )
    
                if pData > 0 then
                    set pData = ReadRealMemory( pData + 0x64 )
    
                    if pData > 0 then
                        return ReadRealFloat( pData + index * 4 )
                    endif
                endif
            endif
        endif

        return -1.
    endfunction

    function SetUnitBaseMissileSpeedById takes integer uid, integer index, real speed returns nothing
        local integer pData = 0

        if uid > 0 then
            if index == 0 or index == 1 then
                set pData = GetUnitBaseUIDataByIdCaching( uid )
    
                if pData > 0 then
                    set pData = ReadRealMemory( pData + 0x64 )
    
                    if pData > 0 then
                        call WriteRealMemory( pData + index * 4, SetRealIntoMemory( speed ) )
                    endif
                endif
            endif
        endif
    endfunction

    function GetUnitBaseMissileArcById takes integer uid, integer index returns real
        local integer pData = 0

        if uid > 0 then
            if index == 0 or index == 1 then
                set pData = GetUnitBaseUIDataByIdCaching( uid )
    
                if pData > 0 then
                    set pData = ReadRealMemory( pData + 0x70 )
    
                    if pData > 0 then
                        return ReadRealFloat( pData + index * 4 )
                    endif
                endif
            endif
        endif

        return -1.
    endfunction

    function SetUnitBaseMissileArcById takes integer uid, integer index, real arc returns nothing
        local integer pData = 0

        if uid > 0 then
            if index == 0 or index == 1 then
                set pData = GetUnitBaseUIDataByIdCaching( uid )
    
                if pData > 0 then
                    set pData = ReadRealMemory( pData + 0x70 )
    
                    if pData > 0 then
                        call WriteRealMemory( pData + index * 4, SetRealIntoMemory( arc ) )
                    endif
                endif
            endif
        endif
    endfunction
    
    function GetUnitBaseColorById takes integer uid returns integer
        local integer pData = 0
    
        if uid > 0 then
            set pData = GetUnitBaseUIDataByIdCaching( uid )
    
            if pData > 0 then
                return ReadRealMemory( pData + 0xAC )
            endif
        endif
    
        return 0
    endfunction

    function GetUnitBaseModelById takes integer uid returns string
        local integer pData = 0

        if uid > 0 then
            set pData = GetUnitBaseUIDataByIdCaching( uid )

            if pData > 0 then
                set pData = ReadRealMemory( pData + 0x34 )
    
                if pData > 0 then
                    return ToJString( pData )
                endif
            endif
        endif

        return null
    endfunction

    function SetUnitBaseModelById takes integer uid, string model returns nothing
        local integer pData = 0
    
        if uid > 0 then
            set pData = GetUnitBaseUIDataByIdCaching( uid )
    
            if pData > 0 then
                call WriteNullTerminatedString( model, pData + 0x34 )
            endif
        endif
    endfunction
    
    function GetUnitBaseIconPathById takes integer uid returns string
        return GetUnitBaseUIStringParam( uid, 1, 0x24C )
    endfunction

    function SetUnitBaseIconPathById takes integer uid, string iconpath returns nothing
        call SetUnitBaseUIStringParam( uid, 1, 0x24C, iconpath )
    endfunction
    
    function GetUnitBaseTipById takes integer uid returns string
        return GetUnitBaseUIStringParam( uid, 1, 0x260 )
    endfunction

    function SetUnitBaseTipById takes integer uid, string text returns nothing
        call SetUnitBaseUIStringParam( uid, 1, 0x260, text )
    endfunction

    function GetUnitBaseUbertipById takes integer uid returns string
        return GetUnitBaseUIStringParam( uid, 1, 0x26C )
    endfunction

    function SetUnitBaseUbertipById takes integer uid, string text returns nothing
        call SetUnitBaseUIStringParam( uid, 1, 0x26C, text )
    endfunction

    function GetUnitBaseHotkeyById takes integer uid returns integer
        if uid > 0 then
            if GetUnitBaseUIIntegerParam( uid, 0, 0x270 ) > 0 or GetUnitBaseUIIntegerParam( uid, 0, 0x274 ) > 0 then
                return GetUnitBaseUIIntegerParam( uid, 1, 0x278 )
            endif
        endif
    
        return 0
    endfunction

    function SetUnitBaseHotkeyById takes integer uid, integer key returns nothing
        if uid > 0 then
            call SetUnitBaseUIIntegerParam( uid, 0, 0x270,   1 )
            call SetUnitBaseUIIntegerParam( uid, 0, 0x274, key )
            call SetUnitBaseUIIntegerParam( uid, 1, 0x278, key )
        endif
    endfunction
    //===========================================

    // Unit Base UI Data API by Unit
    function GetUnitBaseModel takes unit u returns string
        return GetUnitBaseModelById( GetUnitTypeId( u ) )
    endfunction

    function SetUnitBaseModel takes unit u, string model returns nothing
        call SetUnitBaseModelById( GetUnitTypeId( u ), model )
    endfunction

    function GetUnitBasePortrait takes unit u returns string
        return GetUnitBasePortraitById( GetUnitTypeId( u ) )
    endfunction

    function SetUnitBasePortrait takes unit u, string model returns nothing
        call SetUnitBasePortraitById( GetUnitTypeId( u ), model )
    endfunction

    function GetUnitBaseMissileArt takes unit u, integer index returns string
        return GetUnitBaseMissileArtById( GetUnitTypeId( u ), index )
    endfunction

    function SetUnitBaseMissileArt takes unit u, string model, integer index returns nothing
        call SetUnitBaseMissileArtById( GetUnitTypeId( u ), model, index )
    endfunction

    function GetUnitBaseMissileSpeed takes unit u, integer index returns real
        return GetUnitBaseMissileSpeedById( GetUnitTypeId( u ), index )
    endfunction

    function SetUnitBaseMissileSpeed takes unit u, integer index, real speed returns nothing
        call SetUnitBaseMissileSpeedById( GetUnitTypeId( u ), index, speed )
    endfunction

    function GetUnitBaseColor takes unit u returns integer
        return GetUnitBaseColorById( GetUnitTypeId( u ) )
    endfunction

    function GetUnitBaseIconPath takes unit u returns string
        return GetUnitBaseIconPathById( GetUnitTypeId( u ) )
    endfunction
    
    function SetUnitBaseIconPath takes unit u, string iconpath returns nothing
        call SetUnitBaseIconPathById( GetUnitTypeId( u ), iconpath )
    endfunction
    
    function GetUnitBaseTip takes unit u returns string
        return GetUnitBaseTipById( GetUnitTypeId( u ) )
    endfunction

    function SetUnitBaseTip takes unit u, string text returns nothing
        call SetUnitBaseTipById( GetUnitTypeId( u ), text )
    endfunction

    function GetUnitBaseUbertip takes unit u returns string
        return GetUnitBaseUbertipById( GetUnitTypeId( u ) )
    endfunction

    function SetUnitBaseUbertip takes unit u, string text returns nothing
        call SetUnitBaseUbertipById( GetUnitTypeId( u ), text )
    endfunction

    function GetUnitBaseHotkey takes unit u returns integer
        return GetUnitBaseHotkeyById( GetUnitTypeId( u ) )
    endfunction

    function SetUnitBaseHotkey takes unit u, integer key returns nothing
        call SetUnitBaseHotkeyById( GetUnitTypeId( u ), key )
    endfunction
    //===========================================

    // Unit Base Data API by Id
    function GetUnitGoldCostById takes integer uid returns integer
        local integer pData = GetUnitBaseDataById( uid )

        if pData > 0 then
            return ReadRealMemory( pData + 0x20 )
        endif

        return -1
    endfunction
    
    function SetUnitGoldCostById takes integer uid, integer value returns nothing
        local integer pData = GetUnitBaseDataById( uid )

        if pData > 0 and value >= 0 then
            call WriteRealMemory( pData + 0x20, value )
        endif
    endfunction

    function GetUnitLumberCostById takes integer uid returns integer
        local integer pData = GetUnitBaseDataById( uid )

        if pData > 0 then
            return ReadRealMemory( pData + 0x24 )
        endif

        return -1
    endfunction
    
    function SetUnitLumberCostById takes integer uid, integer value returns nothing
        local integer pData = GetUnitBaseDataById( uid )

        if pData > 0 and value >= 0 then
            call WriteRealMemory( pData + 0x24, value )
        endif
    endfunction
    
    function GetUnitFoodCostById takes integer uid returns integer
        local integer pData = GetUnitBaseDataById( uid )

        if pData > 0 then
            return ReadRealMemory( pData + 0x5C )
        endif

        return -1
    endfunction
    
    function SetUnitFoodCostById takes integer uid, integer value returns nothing
        local integer pData = GetUnitBaseDataById( uid )

        if pData > 0 and value >= 0 then
            call WriteRealMemory( pData + 0x5C, value )
        endif
    endfunction
    
    function GetHeroBasePrimaryAttributeById takes integer uid returns integer
        local integer pData = GetUnitBaseDataById( uid )

        if pData > 0 then
            return ReadRealMemory( pData + 0x17C )
        endif

        return -1
    endfunction

    function SetHeroBasePrimaryAttributeById takes integer uid, integer index returns nothing
        local integer pData = GetUnitBaseDataById( uid )

        if pData > 0 then
            if index >= 0 and index <= 2 then
                call WriteRealMemory( pData + 0x17C, index )
            endif
        endif
    endfunction

    function GetUnitCollisionSizeById takes integer uid returns real
        local integer pData = GetUnitBaseDataById( uid )

        if pData > 0 then
            return GetRealFromMemory( ReadRealMemory( pData + 0x19C ) )
        endif

        return -1.234 // to ensure we failed
    endfunction
    //===========================================

    // Unit Base Data API by unit
    function GetUnitGoldCostEx takes unit u returns integer
        return GetUnitGoldCostById( GetUnitTypeId( u ) )
    endfunction
    
    function SetUnitGoldCostEx takes unit u, integer value returns nothing
        call SetUnitGoldCostById( GetUnitTypeId( u ), value )
    endfunction
    
    function GetUnitLumberCost takes unit u returns integer
        return GetUnitLumberCostById( GetUnitTypeId( u ) )
    endfunction
    
    function SetUnitLumberCost takes unit u, integer value returns nothing
        call SetUnitLumberCostById( GetUnitTypeId( u ), value )
    endfunction
    
    function GetUnitFoodCost takes unit u returns integer
        return GetUnitFoodCostById( GetUnitTypeId( u ) )
    endfunction
    
    function SetUnitFoodCost takes unit u, integer value returns nothing
        call SetUnitFoodCostById( GetUnitTypeId( u ), value )
    endfunction
    
    function GetHeroBasePrimaryAttribute takes unit u returns integer
        return GetHeroBasePrimaryAttributeById( GetUnitTypeId( u ) )
    endfunction

    function SetHeroBasePrimaryAttribute takes unit u, integer index returns nothing
        call SetHeroBasePrimaryAttributeById( GetUnitTypeId( u ), index )
    endfunction
    
    function GetUnitCollisionSize takes unit u returns real
        return GetUnitCollisionSizeById( GetUnitTypeId( u ) )
    endfunction
    //===========================================

    function Init_MemHackUnitBaseAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pUnitDataNode       = pGameDLL + 0xACB2B4
                set pUnitUIDataNode     = pGameDLL + 0xACC72C
                set pGetUnitUIData      = pGameDLL + 0x32D3C0
        elseif PatchVersion == "1.26a" then
                set pUnitDataNode       = pGameDLL + 0xAB445C
                set pUnitUIDataNode     = pGameDLL + 0xAB58D4
                set pGetUnitUIData      = pGameDLL + 0x32C880
        elseif PatchVersion == "1.27a" then
                set pUnitDataNode       = pGameDLL + 0xBEC470
                set pUnitUIDataNode     = pGameDLL + 0xBE6114
                set pGetUnitUIData      = pGameDLL + 0x327020
        elseif PatchVersion == "1.27b" then
                set pUnitDataNode       = pGameDLL + 0xD709D8
                set pUnitUIDataNode     = pGameDLL + 0xBE6114
                set pGetUnitUIData      = pGameDLL + 0x344760
        elseif PatchVersion == "1.28f" then
                set pUnitDataNode       = pGameDLL + 0xD38810
                set pUnitUIDataNode     = pGameDLL + 0xD324B4
                set pGetUnitUIData      = pGameDLL + 0x378720
            endif
        endif
    endfunction
    //===========================================
endlibrary

//===========================================================================
function InitTrig_MemHackUnitBaseAPI takes nothing returns nothing
    //set gg_trg_MemHackUnitBaseAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackUnitNormalAPI
//===========================================================================
//TESH.scrollpos=24
//TESH.alwaysfold=0
//! nocjass
library MemoryHackUnitNormalAPI
    globals
        integer pUnitData                   = 0
        integer pRedrawUnit                 = 0
        integer pCommonSilence              = 0
        integer pPauseUnitDisabler          = 0
        integer pSetStunToUnit              = 0
        integer pUnsetStunToUnit            = 0
        integer pSetUnitTexture             = 0
        integer pGetHeroNeededXP            = 0

        integer pApplyUnitUpgrades          = 0
        integer pUnapplyUnitUpgrades        = 0

        integer pUpdateUnitInfoBar          = 0

        integer pMorphUnitToTypeId          = 0
        integer pUpdateHeroBar              = 0
        integer pRefreshPortraitIfSelected  = 0
        integer pRefreshInfoBarIfSelected   = 0
        
        integer pSetUnitFacingFlag          = 0
    endglobals
    
    // CUnit API
    function CUnitApplyUpgrades takes integer pUnit returns nothing
        if pUnit != 0 and pApplyUnitUpgrades != 0 then
            call this_call_1( pApplyUnitUpgrades, pUnit )
        endif
    endfunction

    function CUnitUnapplyUpgrades takes integer pUnit returns nothing
        if pUnit != 0 and pUnapplyUnitUpgrades != 0 then
            call this_call_1( pUnapplyUnitUpgrades, pUnit )
        endif
    endfunction

    function CUnitUpdateInfoBar takes integer pUnit returns nothing
        if pUnit != 0 and pUpdateUnitInfoBar != 0 then
            call this_call_1( pUpdateUnitInfoBar, pUnit )
        endif
    endfunction

    function CUnitUpdateHeroBar takes integer pUnit, integer unk1 returns nothing
        if pUnit != 0 and pUpdateHeroBar != 0 then
            call this_call_2( pUpdateHeroBar, pUnit, unk1 )
        endif
    endfunction
    
    function CUnitRefreshPortraitOnSelect takes integer pUnit, integer unk1 returns nothing
        if pUnit != 0 and pRefreshPortraitIfSelected != 0 then
            call this_call_2( pRefreshPortraitIfSelected, pUnit, unk1 )
        endif
    endfunction
    
    function CUnitRefreshInfoBarOnSelect takes integer pUnit returns integer
        if pUnit != 0 and pRefreshInfoBarIfSelected != 0 then
            return this_call_1( pRefreshInfoBarIfSelected, pUnit )
        endif

        return 0
    endfunction

    function CUnitAddAbilityEx takes integer pUnit, integer aid, boolean checkduplicate returns nothing
        local boolean flag = false

        if pUnit != 0 and aid != 0 then
            if not ( checkduplicate and GetUnitAbilityReal( pUnit, aid, 0, 1, 1, 1 ) != 0 ) then
                call CUnitUnapplyUpgrades( pUnit )
                set flag = CUnitAddAbility( pUnit, aid )
                call CUnitApplyUpgrades( pUnit )
                
                if flag then
                    call CUnitUpdateInfoBar( pUnit )
                endif
            endif
        endif
    endfunction

    function CUnitRemoveAbilityEx takes integer pUnit, integer aid, boolean removeduplicates returns nothing
        local integer pAbil = 0
        local boolean flag = false

        if pUnit != 0 and aid != 0 then
            loop
                set pAbil = GetUnitAbilityReal( pUnit, aid, 0, 1, 1, 1 )

                if pAbil != 0 then
                    set flag = CUnitRemoveAbility( pUnit, pAbil )

                    if not removeduplicates then
                        set pAbil = 0
                    endif
                endif

                exitwhen pAbil == 0
            endloop

            if flag then
                call this_call_1( pUpdateUnitInfoBar, pUnit )
            endif
        endif
    endfunction

    function CUnitMorphToTypeIdEx takes integer pUnit, integer id, integer unk1, integer unk2, integer unk3, integer unk4, integer unk5, integer unk6, integer unk7, integer unk8, integer unk9 returns boolean
        // This function imitates spells like Metamorphosis etc, but without additional leaks.
        if pUnit > 0 and pMorphUnitToTypeId != 0 then
            if ReadRealMemory( pUnit + 0x30 ) != id then
                return this_call_11( pMorphUnitToTypeId, pUnit, id, unk1, unk2, unk3, unk4, unk5, unk6, unk7, unk8, unk9 ) != 0
            endif
        endif
        
        return false
    endfunction
    
    function CUnitMorphToTypeId takes integer pUnit, integer id returns boolean
        return CUnitMorphToTypeIdEx( pUnit, id, 1282, 0, 0, 2, 2, 1, 0, 0, 0 )
    endfunction
    //===========================================
    
    // jUnit API
    function GetUnitTypeIdReal takes unit u returns integer
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            return ReadRealMemory( pData + 0x30 )
        endif

        return 0
    endfunction

    function SetUnitTypeId takes unit u, integer i returns nothing
        // Note: This is simply change for portrait and some cosmetic stuff!
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            call WriteRealMemory( pData + 0x30, i )
        endif
    endfunction

    function MorphUnitToTypeId takes unit u, integer id returns boolean
        return CUnitMorphToTypeId( ConvertHandle( u ), id )
    endfunction
    
    function UpdateHeroBar takes unit u returns nothing
        call CUnitUpdateHeroBar( ConvertHandle( u ), 0 )
    endfunction
    
    function RefreshUnitPortraitOnSelect takes unit u returns nothing
        call CUnitRefreshPortraitOnSelect( ConvertHandle( u ), 1 )
    endfunction

    function RefreshUnitInfoBarOnSelect takes unit u returns nothing
        call CUnitRefreshInfoBarOnSelect( ConvertHandle( u ) )
    endfunction
    
    function MorphUnitToTypeIdEx takes unit u, integer id returns integer
        // This function imitates spells like Metamorphosis etc, but without additional leaks.
        local integer pUnit = ConvertHandle( u )

        if pUnit > 0 then
            if ReadRealMemory( pUnit + 0x30 ) != id then
                call CUnitMorphToTypeId( pUnit, id )
                call CUnitUpdateHeroBar( pUnit, 0 )
                call CUnitRefreshPortraitOnSelect( pUnit, 1 )
                return CUnitRefreshInfoBarOnSelect( pUnit )
            endif
        endif

        return 0
    endfunction

    function GetHeroNeededXPForLevel takes unit u, integer level returns integer
        local integer pUnit = ConvertHandle( u )

        if pUnit > 0 then
            if IsUnitType( u, UNIT_TYPE_HERO ) then
                if pGetHeroNeededXP > 0 then
                    return this_call_2( pGetHeroNeededXP, pUnit, level )
                endif
            endif
        endif

        return 0
    endfunction

    function ApplyUnitUpgrades takes unit u returns nothing
        call CUnitApplyUpgrades( ConvertHandle( u ) )
    endfunction
    
    function UnapplyUnitUpgrades takes unit u returns nothing
        call CUnitUnapplyUpgrades( ConvertHandle( u ) )
    endfunction
    
    function UpdateUnitInfoBar takes unit u returns nothing
        call CUnitUpdateInfoBar( ConvertHandle( u ) )
    endfunction
    
    function AddUnitAbilityEx takes unit u, integer aid, boolean checkduplicate returns nothing
        call CUnitAddAbilityEx( ConvertHandle( u ), aid, checkduplicate )
    endfunction
    
    function RemoveUnitAbilityEx takes unit u, integer aid, boolean removeduplicates returns nothing
        call CUnitRemoveAbilityEx( ConvertHandle( u ), aid, removeduplicates )
    endfunction

    function GetHeroNeededXP takes unit u returns integer
        return GetHeroNeededXPForLevel( u, GetUnitLevel( u ) )
    endfunction

    function GetUnitVertexColour takes unit u returns integer
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            return ReadRealMemory( pData + 0x2D4 )
        endif

        return 0
    endfunction

    function GetUnitVertexColourA takes unit u returns integer
        return GetByteFromInteger( GetUnitVertexColour( u ), 1 )
    endfunction

    function GetUnitVertexColourR takes unit u returns integer
        return GetByteFromInteger( GetUnitVertexColour( u ), 2 )
    endfunction

    function GetUnitVertexColourG takes unit u returns integer
        return GetByteFromInteger( GetUnitVertexColour( u ), 3 )
    endfunction

    function GetUnitVertexColourB takes unit u returns integer
        return GetByteFromInteger( GetUnitVertexColour( u ), 4 )
    endfunction

    function SetUnitModel takes unit u, string model returns nothing
        call SetObjectModel( ConvertHandle( u ), model )
    endfunction

    function SetUnitTexture takes unit u, string texturepath, integer textureId returns integer
        local integer pUnit = ConvertHandle( u )
        local integer pTexture = 0

        if pUnit > 0 then
            if texturepath != "" then
                set pTexture = LoadCBackDropFrameTexture( texturepath, false )

                if pTexture > 0 and textureId > 0 then
                    return fast_call_3( pSetUnitTexture, ReadRealMemory( pUnit + 0x28 ), pTexture, textureId )
                endif
            endif
        endif

        return 0
    endfunction
    
    function GetUnitImpactZ takes unit u returns real
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            return GetRealFromMemory( ReadRealMemory( pData + 0x228 ) )
        endif

        return 0.
    endfunction

    function SetUnitImpactZ takes unit u, real impactZ returns nothing
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            call WriteRealMemory( pData + 0x228, SetRealIntoMemory( impactZ ) )
        endif
    endfunction

    function RedrawUnit takes unit u returns nothing
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            call this_call_1( pRedrawUnit, pData )
        endif
    endfunction

    function IsAttackDisabled takes unit u returns boolean
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            set pData = ReadRealMemory( pData + 0x1E8 )

            if pData > 0 then
                return ReadRealMemory( pData + 0x40 ) > 0
            endif
        endif

        return false
    endfunction

    function UnitDisableAttack takes unit u returns nothing
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            set pData = ReadRealMemory( pData + 0x1E8 )

            if pData > 0 then
                call WriteRealMemory( pData + 0x40, 0 )
            endif
        endif
    endfunction
    
    function UnitEnableAttack takes unit u returns nothing
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            set pData = ReadRealMemory( pData + 0x1E8 )

            if pData > 0 then
                call WriteRealMemory( pData + 0x40, 1 )
            endif
        endif
    endfunction

    function GetUnitCritterFlag takes unit u returns integer
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            // 0 - normal | 1 - critter
            return ReadRealMemory( pData + 0x60 )
        endif

        return -1
    endfunction

    function SetUnitCritterFlag takes unit u, integer id returns nothing
        // Acts similar to 'Amec', meaning if unit has flag equal to 1
        // then he is considered a creep and will be ignored by autoattacks.
        // However, an attack may still be forced with 'A' key or rightclick
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            if id >= 0 and id <= 1 then
                call WriteRealMemory( pData + 0x60, id )
            endif
        endif
    endfunction
    
    function GetUnitTimedLife takes unit u returns real
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            set pData = GetUnitAbility( u, 'BTLF' )

            if pData > 0 then
                set pData = ReadRealMemory( pData + 0x90 )

                if pData > 0 then
                    return GetRealFromMemory( ReadRealMemory( pData + 0x4 ) )
                endif
            endif
        endif

        return 0.
    endfunction

    function SetUnitTimedLife takes unit u, real dur returns nothing
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            set pData = GetUnitAbility( u, 'BTLF' )

            if pData > 0 then
                set pData = ReadRealMemory( pData + 0x90 )

                if pData > 0 then
                    call WriteRealMemory( pData + 0x4, SetRealIntoMemory( dur ) )
                endif
            endif
        endif
    endfunction

    function SetUnitPhased takes unit u returns nothing
        // Must be used with a slight delay AFTER cast, the minimum is one frame after successful cast!
        local integer data  = GetUnitBaseDataById( GetUnitTypeId( u ) ) + 0x1AC
        local integer p1    = ReadRealMemory( data )
        local integer p2    = ReadRealMemory( data + 0x4 )

        call WriteRealMemory( data, 0x8 )
        call WriteRealMemory( data + 0x4, 0x10 )
        call SetUnitPathing( u, true )
        call WriteRealMemory( data, p1 )
        call WriteRealMemory( data + 0x4, p2 )
    endfunction

    function UnitApplySilence takes unit u, boolean flag returns nothing
        local integer pUnit = ConvertHandle( u )

        if pUnit > 0 then
            call this_call_2( pCommonSilence, pUnit, B2I( flag ) )
        endif
    endfunction

    function UnitDisableAbilities takes unit u, boolean flag returns nothing
        // Visually equal to pause: all skills are hidden and silenced
        local integer pUnit = ConvertHandle( u )

        if pUnit > 0 then
            call this_call_5( pPauseUnitDisabler, pUnit, 1, B2I( flag ), 0, 0 )
        endif
    endfunction
    
    function UnitSetStunFlag takes unit u, boolean add returns nothing
        local integer pData = ConvertHandle( u )
        
        if pData > 0 then
            if add then                         
                call this_call_2( pSetStunToUnit, ConvertHandle( u ), ConvertHandle( u ) )
            else
                call this_call_1( pUnsetStunToUnit, ConvertHandle( u ) )
            endif
        endif
    endfunction

    function IsUnitStunned takes unit u returns boolean
        local integer pHandle = ConvertHandle( u )
        
        if pHandle > 0 then
            return ReadRealMemory( pHandle + 0x198 ) > 0
        endif

        return false
    endfunction

    function UnitApplyStun takes unit u returns nothing //unsafe, do not use unless you tested it through
        local integer pHandle = ConvertHandle( u )

        if pHandle > 0 then
            call WriteRealMemory( pHandle + 0x198, 0 )
        endif
    endfunction

    function IsUnitMovementDisabled takes unit u returns boolean
        local integer pdata = GetHandleId( u )

        if pdata > 0 then
            set pdata = ConvertHandle( u )

            if pdata > 0 then
                set pdata = ReadRealMemory( pdata + 0x1EC )

                if pdata > 0 then
                    return ReadRealMemory( pdata + 0x7C ) > 0
                endif
            endif
        endif

        return false
    endfunction

    function SetUnitControl takes unit u, integer flagval, integer moveval, integer atackval, integer invval returns nothing
        local integer pUnit = ConvertHandle( u )
        local integer flags
        local integer Amov
        local integer Aatk
        local integer AInv 

        if pUnit > 0 then
            set flags = ReadRealMemory( pUnit + 0x248 )
            set Aatk  = ReadRealMemory( pUnit + 0x1E8 )
            set Amov  = ReadRealMemory( pUnit + 0x1EC )
            set AInv  = ReadRealMemory( pUnit + 0x1F8 )
            
            if not IsFlagBitSet( flags, 512 ) then
                call WriteRealMemory( pUnit + 0x248, flags + flagval )
            endif

            if Amov > 0 then
                call WriteRealMemory( Amov + 0x40, ReadRealMemory( Amov + 0x40 ) + moveval )
            endif

            if Aatk > 0 then
                call WriteRealMemory( Aatk + 0x40, ReadRealMemory( Aatk + 0x40 ) + atackval )
            endif

            if AInv > 0 then
                call WriteRealMemory( AInv + 0x3C, ReadRealMemory( AInv + 0x3C ) + invval )
            endif
        endif
    endfunction

    function UnitDisableControl takes unit u returns nothing
        //Hides all command buttons and sets the Ward flag. Unit will keep its current order, and player can’t give new orders
        //Notice the the unit can’t be ordered with triggers as well. To issue an order you need to temporarily reenable control
        call SetUnitControl( u, 512, 1, 1, 1 )
    endfunction

    function UnitEnableControl takes unit u returns nothing
        //Removes the Ward flag and reenables Amov and Aatk
        call SetUnitControl( u, -512, -1, -1, -1 )
    endfunction

    function UnitRemoveMovementDisables takes unit u returns nothing
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            set pData = ReadRealMemory( pData + 0x1EC )

            if pData > 0 then
                call WriteRealMemory( ReadRealMemory( pData + 0x1EC ) + 0x7C, 0 )
            endif
        endif
    endfunction

    function SetUnitMovement takes integer pData, boolean flag returns nothing
        if pData > 0 then
            set pData = ReadRealMemory( pData + 0x1EC )

            if pData > 0 then
                call WriteRealMemory( pData + 0x7C, B2I( not flag ) ) //  ReadRealMemory( pdata ) + d
            endif
        endif
    endfunction

    function UnitEnableMovement takes unit u returns nothing
        if u == null then
            return
        endif

        call SetUnitMovement( ConvertHandle( u ), false )
    endfunction

    function UnitDisableMovement takes unit u returns nothing
        if u == null then
            return
        endif

        call SetUnitMovement( ConvertHandle( u ), true )
    endfunction

    function UnitDisableMovementEx takes unit u, boolean disable returns nothing
        local integer i = 2
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            if not disable then
                set i = 1
            endif

            call PauseUnit( u, true )
            set pData = ReadRealMemory( pData + 0x1EC )
            
            if pData > 0 then
                call SetAddressAbilityDisabled( pData, i ) //pointer to 'Amov' is located at offset 123 of unit object, Aatk is at offset 122, and AInv is offset 124
            endif

            call PauseUnit( u, false )
        endif
    endfunction

    function IsUnitInventoryDisabled takes unit u returns boolean
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            set pData = ReadRealMemory( pData + 0x1F8 )

            if pData > 0 then
                return I2B( ReadRealMemory( pData + 0x3C ) )
            endif
        endif
    
        return false
    endfunction
    
    function UnitEnableInventory takes unit u, boolean flag returns nothing
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            set pData = ReadRealMemory( pData + 0x1F8 )

            if pData > 0 then
                set pData = pData + 0x3C
                call WriteRealMemory( pData, B2I( not flag ) )
            endif
        endif
    endfunction

    function GetAddressLocustFlags takes integer pHash1, integer pHash2 returns integer
        local integer pObj = GetCObjectFromHash( pHash1, pHash2 )

        if pObj > 0 then
            return ReadRealMemory( pObj + 0x94 )
        endif

        return 0
    endfunction

    function SetLocustFlags takes unit u, integer i returns nothing //These flags can make unit immune to truesight
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            set pData = pData + 0x16C
            set pData = GetAddressLocustFlags( ReadRealMemory( pData ), ReadRealMemory( pData + 4 ) )

            if pData > 0 then
                call WriteRealMemory( pData + 0x34, i )
            endif
        endif
    endfunction

    function UnitEnableTruesightImmunity takes unit u returns nothing
        call SetLocustFlags( u, 0x08000000 ) //I don’t really know what other side effects may be caused by this, at least GroupEnum is not affected
    endfunction

    function UnitDisableTruesightImmunity takes unit u returns nothing
        call SetLocustFlags( u, 0 )
    endfunction

    function GetUnitFlags takes unit u returns integer
        local integer pData = ConvertHandle( u )
        
        if pData > 0 then
            return ReadRealMemory( pData + 0x20 )
        endif

        return 0
    endfunction

    function SetUnitFlags takes unit u, integer i returns nothing
        local integer pData = ConvertHandle( u )
        
        if pData > 0 then
            call WriteRealMemory( pData + 0x20, i )
        endif
    endfunction

    function AddUnitFlags takes unit u, integer i returns nothing
        call SetUnitFlags( u, GetUnitFlags( u ) + i )
    endfunction
    
    function GetUnitFlags_2 takes unit u returns integer
        local integer pData = ConvertHandle( u )
        
        if pData > 0 then
            return ReadRealMemory( pData + 0x5C )
        endif

        return 0
    endfunction

    function SetUnitFlags_2 takes unit u, integer i returns nothing
        local integer pData = ConvertHandle( u )
        
        if pData > 0 then
            call WriteRealMemory( pData + 0x5C, i )
        endif
    endfunction

    function AddUnitFlags_2 takes unit u, integer i returns nothing
        call SetUnitFlags_2( u, GetUnitFlags_2( u ) + i )
    endfunction

    function GetUnitVisibilityClass takes unit u returns integer
        local integer a = ConvertHandle( u )
        local integer res = 0

        if a > 0 then
            set res = ReadRealMemory( a + 0x130 )

            if res > 0 then
                set res = GetCAgentFromHash( res, ReadRealMemory( a + 0x134 ) )
            endif
        endif

        return res
    endfunction

    function SetUnitVisibleByPlayer takes unit u, player p, integer c returns nothing
        local integer a = GetUnitVisibilityClass( u )

        if a > 0 then
            call WriteRealMemory( a + 0x2C + 4 * GetPlayerId( p ), c )
            if c > 0 and not IsFlagBitSet( ReadRealMemory( a + 0x24 ), Player2Flag( p ) ) then
                call WriteRealMemory( a + 0x24, ReadRealMemory( a + 0x24 ) + Player2Flag( p ) )
            elseif c==0 and IsFlagBitSet( ReadRealMemory( a + 0x24 ), Player2Flag( p ) ) then
                call WriteRealMemory( a + 0x24, ReadRealMemory( a + 0x24 ) - Player2Flag( p ) )
            endif
        endif
    endfunction

    function IsUnitInvulnerable takes unit u returns boolean
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            return IsFlagBitSet( ReadRealMemory( pData + 0x20 ), 8 )
        endif

        return false
    endfunction

    function GetUnitInvulnerableCounter takes unit u returns integer
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            return ReadRealMemory( pData + 0xE8 )
        endif

        return 0
    endfunction

    function SetUnitInvulnerableCounter takes unit u, integer i returns nothing
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            call WriteRealMemory( pData + 0xE8, i )
        endif
    endfunction

    function ModifyInvulnerableCounter takes unit u, integer diff returns nothing
        if u != null then
            call SetUnitInvulnerableCounter( u, GetUnitInvulnerableCounter( u ) + diff )
        endif
    endfunction

    function IsUnitInvulnerable2 takes unit u returns boolean
        return GetUnitInvulnerableCounter( u ) > 0
    endfunction

    function SetUnitFacingEx takes unit u, real facing, boolean isinstant returns nothing
        local integer pObject   = ConvertHandle( u )
        local integer vtable    = 0
        local integer pSmartPos = 0
        local integer pPosPos   = 0

        if pObject != 0 then
            set vtable = ReadRealMemory( pObject )

            if vtable != 0 then
                set pSmartPos = this_call_1( ReadRealMemory( vtable + 0xB8 ), pObject )

                if pSmartPos != 0 then
                    set pPosPos = GetCObjectFromHashGroup( pSmartPos + 0x08 )
                    
                    if pPosPos != 0 then
                        set vtable = ReadRealMemory( pPosPos )
                        
                        if vtable != 0 then
                            set facing = Deg2Rad( facing )
                            call WriteRealMemory( pReservedIntArg1, SetRealIntoMemory( facing ) )
                            call this_call_2( ReadRealMemory( vtable + 0x4C ), pPosPos, pReservedIntArg1 )

                            if isinstant then
                                call this_call_1( ReadRealMemory( vtable + 0x58 ), pPosPos )
                            endif
                        endif
                    endif
                endif
            endif
        endif
    endfunction

    function SetUnitFacingInstantOld takes unit u, real a returns nothing
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            set pData = GetCObjectFromHashGroup( pData + 0xA0 )

            if pData > 0 then
                set pData = ReadRealMemory( pData + 0x28 )

                if pData > 0 then
                    call SetUnitFacing( u, a )
                    call WriteRealMemory( pData + 0xA4, SetRealIntoMemory( Deg2Rad( a ) ) )
                endif
            endif
        endif
    endfunction

    function GetUnitMoveType takes unit u returns integer
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            set pData = GetCObjectFromHashGroup( pData + 0x16C )

            if pData > 0 then
                set pData = ReadRealMemory( pData + 0xA8 )

                if pData > 0 then
                    return ReadRealMemory( pData + 0x9C )
                endif
            endif
        endif

        return 0
    endfunction

    function SetUnitMoveType takes unit u, integer m_type returns nothing
        // foot = 33554434 | fly = 67108868 | amph = -2147483520
        // This method only properly works if unit has FLY movement as default, els.
        // Meaning only a unit with default move type of flying can lose flying pathing and gain it back.
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            set pData = GetCObjectFromHashGroup( pData + 0x16C )

            if pData > 0 then
                set pData = ReadRealMemory( pData + 0xA8 )

                if pData > 0 then
                    call WriteRealMemory( pData + 0x9C, m_type )
                endif
            endif
        endif
    endfunction

    function GetHeroPrimaryAttribute takes unit u returns integer //1 = str, 2 = int, 3 = agi
        local integer a = ConvertHandle( u )

        if a > 0 then
            set a = ReadRealMemory( a + 0x1F0 )

            if a > 0 then
                return ReadRealMemory( a + 0xCC )
            endif
        endif

        return 0
    endfunction

    function SetHeroPrimaryAttribute takes unit u, integer i returns nothing
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            if IsUnitIdType( GetUnitTypeId( u ), UNIT_TYPE_HERO ) then
                set pData = ReadRealMemory( pData + 0x1F0 )

                if pData > 0 then
                    call WriteRealMemory( pData + 0xCC, i )
                endif
            endif
        endif
    endfunction

    function GetUnitAttackAbility takes unit u returns integer
        local integer pData = ConvertHandle( u )
        
        if pData > 0 then
            return ReadRealMemory( pData + 0x1E8 )
        endif
        
        return 0
    endfunction

    function SetUnitAttackAbility takes unit u, integer pAddr returns nothing
        local integer pData = ConvertHandle( u )
        
        if pData > 0 then
            call WriteRealMemory( pData + 0x1E8, pAddr )
        endif
    endfunction
    
    function GetUnitAttackOffsetValue takes unit u, integer pOff returns integer
        local integer pData = GetUnitAttackAbility( u )

        if pData > 0 then
            return ReadRealMemory( pData + pOff )
        endif

        return 0
    endfunction

    function GetUnitNextAttackTimestamp takes unit u returns real
        local integer pData = GetUnitAttackAbility( u )

        if pData > 0 then
            set pData = ReadRealMemory( pData + 0x1E4 )

            if pData > 0 then
                return GetRealFromMemory( ReadRealMemory( pData + 0x4 ) )
            endif
        endif

        return -1.
    endfunction

    function UnitResetAttackCooldown takes unit u returns boolean
        local integer pData = GetUnitAttackAbility( u )

        if pData > 0 then
            set pData = ReadRealMemory( pData + 0x1E4 )

            if pData > 0 then
                call WriteRealMemory( pData + 0x1E4, 0 )
                return true
            endif
        endif

        return false
    endfunction

    function UnitNullifyCurrentAttack takes unit u returns string
        local integer pData = GetUnitAttackAbility( u )

        if pData > 0 then
            set pData = ReadRealMemory( pData + 0x1F4 )

            if pData > 0 then
                call WriteRealMemory( pData + 0x1F4, 0 )
                return "nulled"
            else
                return "already empty"
            endif
        else
            return "cannot attack"
        endif

        return "no attack has been found"
    endfunction

    function AddUnitExtraAttack takes unit u returns boolean
        local integer pData = GetUnitAttackAbility( u )
        local real attackdelay

        if pData > 0 then
            set pData = ReadRealMemory( pData + 0x1E4 )

            if pData > 0 then
                set attackdelay = CleanReal( IndexToReal( ReadRealMemory( pData + 0x8 )  ) )

                if attackdelay > 0 then
                    call WriteRealMemory( pData + 0x4, CleanInt( RealToIndex( GetUnitNextAttackTimestamp( u ) - attackdelay ) ) )
                    return true
                endif
            endif
        endif

        return false
    endfunction

    function GetUnitAttackTypeByIndex takes unit u, integer index returns integer
        if index == 0 or index == 1 then
            return GetUnitAttackOffsetValue( u, 0xF4 + 4 * index )
        endif

        return -1
    endfunction

    function GetUnitAttackType1 takes unit u returns integer
        return GetUnitAttackTypeByIndex( u, 0 )
    endfunction

    function GetUnitAttackType2 takes unit u returns integer
        return GetUnitAttackTypeByIndex( u, 1 )
    endfunction

    function SetUnitAttackOffsetValue takes unit u, integer offset, integer val returns nothing
        local integer pData = GetUnitAttackAbility( u )

        if pData > 0 then
            call WriteRealMemory( pData + offset, val )
        endif
    endfunction
    
    function SetUnitAttackTypeByIndex takes unit u, integer i, integer attacknum returns nothing
        //6 = hero, 5 = chaos, 4 = magic, 3 = siege, 2 = piercing, 1 = normal, 0 = spell?
        //values over 6 takes incorrect multipliers from nearby memory, do not use them
        call SetUnitAttackOffsetValue( u, 0xF4 + 4 * attacknum, i )
    endfunction

    function SetUnitAttackType1 takes unit u, integer i returns nothing
        call SetUnitAttackTypeByIndex( u, i, 0 )
    endfunction

    function SetUnitAttackType2 takes unit u, integer i returns nothing
        call SetUnitAttackTypeByIndex( u, i, 1 )
    endfunction

    function GetUnitWeaponSound takes unit u returns integer
        return GetUnitAttackOffsetValue( u, 0xE8 )
    endfunction

    function SetUnitWeaponSound takes unit u, integer i returns nothing
        call SetUnitAttackOffsetValue( u, 0xE8, i )
    endfunction
    
    function GetUnitWeaponType takes unit u returns integer
        return GetUnitAttackOffsetValue( u, 0xDC )
    endfunction
    
    function SetUnitWeaponType takes unit u, integer i returns nothing
        // unit's weapon type is melee, ranged, splash, artillery, etc -> 0 = melee, 1 = instant, 2 = ranger, 5 = splash, 6 = mbounce | up to 8
        call SetUnitAttackOffsetValue( u, 0xDC, i )
    endfunction

    function GetUnitBaseDamage takes unit u returns integer
        return GetUnitAttackOffsetValue( u, 0xA0 )
    endfunction

    function SetUnitBaseDamage takes unit u, integer i returns nothing
        call SetUnitAttackOffsetValue( u, 0xA0, i )
    endfunction

    function AddUnitBaseDamage takes unit u, integer bonus returns nothing
        call SetUnitBaseDamage( u, GetUnitBaseDamage( u ) + bonus )
    endfunction

    function GetUnitBonusDamage takes unit u returns integer
        return GetUnitAttackOffsetValue( u, 0xAC )
    endfunction

    function SetUnitBonusDamage takes unit u, integer i returns nothing
        //setting green bonus automatically adjusts base damage to fit
        call SetUnitAttackOffsetValue( u, 0xAC, i )
    endfunction

    function AddUnitBonusDamage takes unit u, integer i returns nothing
        call SetUnitBonusDamage( u, GetUnitBonusDamage( u ) + i )
    endfunction

    function GetUnitTotalDamage takes unit u returns integer
        return GetUnitBaseDamage( u ) + GetUnitBonusDamage( u )
    endfunction

    function GetUnitBaseAttributeDamage takes unit u returns integer
        return GetUnitAttackOffsetValue( u, 0xA4 )
    endfunction

    function SetUnitBaseAttributeDamage takes unit u, integer i returns nothing
        call SetUnitAttackOffsetValue( u, 0xA4, i )
    endfunction

    function GetUnitDamageDicesSideCount takes unit u returns integer
        return GetUnitAttackOffsetValue( u, 0x94 )
    endfunction

    function SetUnitDamageDicesSideCount takes unit u, integer i returns nothing
        call SetUnitAttackOffsetValue( u, 0x94, i )
    endfunction

    function GetUnitDamageDicesCount takes unit u returns integer
        return GetUnitAttackOffsetValue( u, 0x88 )
    endfunction
    
    function SetUnitDamageDicesCount takes unit u, integer i returns nothing
        call SetUnitAttackOffsetValue( u, 0x88, i )
    endfunction

    function GetUnitAttackRangeByIndex takes unit u, integer index returns real
        if index == 0 or index == 1 then
            return GetRealFromMemory( GetUnitAttackOffsetValue( u, 0x258 + 0x24 * index ) )
        endif

        return 0.
    endfunction

    function SetUnitAttackRangeByIndex takes unit u, integer index, real r returns nothing
        if index == 0 or index == 1 then
            call SetUnitAttackOffsetValue( u, 0x258 + 0x24 * index, SetRealIntoMemory( r ) )
        endif
    endfunction
    
    function GetUnitAttackRange1 takes unit u returns real
        return GetUnitAttackRangeByIndex( u, 0 )
    endfunction 

    function SetUnitAttackRange1 takes unit u, real r returns nothing
        call SetUnitAttackRangeByIndex( u, 0, r )
    endfunction

    function GetUnitAttackRange2 takes unit u returns real
        return GetUnitAttackRangeByIndex( u, 1 )
    endfunction

    function SetUnitAttackRange2 takes unit u, real r returns nothing
       call SetUnitAttackRangeByIndex( u, 1, r )
    endfunction

    function GetUnitBATByIndex takes unit u, integer index returns real
        if index == 0 or index == 1 then
            return GetRealFromMemory( GetUnitAttackOffsetValue( u, 0x158 + 0x8 * index ) )
        endif

        return 0.
    endfunction

    function SetUnitBATByIndex takes unit u, integer index, real r returns nothing
        if index == 0 or index == 1 then
            call SetUnitAttackOffsetValue( u, 0x158 + 0x8 * index, SetRealIntoMemory( r ) )
        endif
    endfunction

    function GetUnitBAT1 takes unit u returns real
        return GetUnitBATByIndex( u, 0 )
    endfunction

    function SetUnitBAT1 takes unit u, real r returns nothing
        call SetUnitBATByIndex( u, 0, r )
    endfunction

    function GetUnitBAT2 takes unit u returns real
        return GetUnitBATByIndex( u, 1 )
    endfunction
    
    function SetUnitBAT2 takes unit u, real r returns nothing
        call SetUnitBATByIndex( u, 1, r )
    endfunction

    function GetUnitAttackPointByIndex takes unit u, integer index returns real
        if index == 0 or index == 1 then
            return GetRealFromMemory( GetUnitAttackOffsetValue( u, 0x16C + 0x10 * index ) )
        endif

        return 0.
    endfunction

    function SetUnitAttackPointByIndex takes unit u, integer index, real r returns nothing
        if index == 0 or index == 1 then
            call SetUnitAttackOffsetValue( u, 0x16C + 0x10 * index, SetRealIntoMemory( r ) )
        endif
    endfunction
    
    function GetUnitAttackPoint1 takes unit u returns real
        return GetUnitAttackPointByIndex( u, 0 )
    endfunction
    
    function SetUnitAttackPoint1 takes unit u, real r returns nothing
        call SetUnitAttackPointByIndex( u, 0, r )
    endfunction

    function GetUnitAttackPoint2 takes unit u returns real
        return GetUnitAttackPointByIndex( u, 1 )
    endfunction

    function SetUnitAttackPoint2 takes unit u, real r returns nothing
        call SetUnitAttackPointByIndex( u, 1, r )
    endfunction

    function GetUnitAttackEnabledIndex takes unit u returns integer
        return GetUnitAttackOffsetValue( u, 0x104 )
    endfunction

    function GetUnitAttackBackswing takes unit u returns real
        return GetRealFromMemory( GetUnitAttackOffsetValue( u, 0x190 ) )
    endfunction 

    function SetUnitAttackBackswing takes unit u, real r returns nothing
        call SetUnitAttackOffsetValue( u, 0x190, SetRealIntoMemory( r ) )
    endfunction

    function GetUnitAttackSpeed takes unit u returns real
        return GetRealFromMemory( GetUnitAttackOffsetValue( u, 0x1B0 ) )
    endfunction
    
    function SetUnitAttackSpeed takes unit u, real r returns nothing
        call SetUnitAttackOffsetValue( u, 0x1B0, SetRealIntoMemory( r ) )
    endfunction

    function AddUnitAttackSpeed takes unit u, real r returns nothing
        call SetUnitAttackSpeed( u, GetUnitAttackSpeed( u ) + r )
    endfunction

    function GetUnitAttackDamage takes unit u returns real
        local integer dmg = GetUnitDamageDicesCount( u )
        local integer spread = GetRandomInt( dmg, dmg * GetUnitDamageDicesSideCount( u ) )

        return I2R( GetUnitBaseDamage( u ) + GetUnitBonusDamage( u ) + spread )
    endfunction
    
    function GetUnitArmourType takes unit u returns integer
        //armor types: 0 - Light; 1 - Medium; 2 - Heavy; 3 - Fortified; 4 - Normal; 5 - Hero; 6 - Divine; 7 - unarmored; | rest seems to have Light properties
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            return ReadRealMemory( pData + 0xE4 )
        endif

        return 0
    endfunction

    function SetUnitArmourType takes unit u, integer id returns nothing
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            call WriteRealMemory( pData + 0xE4, id )
        endif
    endfunction

    function GetUnitArmour takes unit u returns real
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            return GetRealFromMemory( ReadRealMemory( pData + 0xE0 ) )
        endif
        
        return 0.
    endfunction

    function SetUnitArmour takes unit u, real r returns nothing
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            call WriteRealMemory( pData + 0xE0, SetRealIntoMemory( r ) )
        endif
    endfunction

    function AddUnitArmour takes unit u, real value returns nothing
        call SetUnitArmour( u, GetUnitArmour( u ) + value )
    endfunction

    function GetUnitTimeScale takes unit u returns real
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            return GetRealFromMemory( ReadRealMemory( pData + 0x300 ) )
        endif

        return 0.
    endfunction

    function GetUnitBaseMoveSpeed takes unit u returns real
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            set pData = ReadRealMemory( pData + 0x1EC ) //Amov
            
            if pData > 0 then
                return GetRealFromMemory( ReadRealMemory( pData + 0x70 ) )
            endif
        endif

        return 0.
    endfunction

    function GetUnitBonusMoveSpeed takes unit u returns real
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            set pData = ReadRealMemory( pData + 0x1EC ) //Amov
            
            if pData > 0 then
                return GetRealFromMemory( ReadRealMemory( pData + 0x78 ) )
            endif
        endif

        return -1000. // To ensure we failed to get Bonus MoveSpeed.
    endfunction

    function SetUnitBonusMoveSpeed takes unit u, real r returns boolean
        local integer pData = ConvertHandle( u )

        if pData > 0 then
            set pData = ReadRealMemory( pData + 0x1EC ) //Amov
            
            if pData > 0 then
                call WriteRealMemory( pData + 0x78, SetRealIntoMemory( r ) )
                call SetUnitMoveSpeed( u, GetRealFromMemory( ReadRealMemory( pData + 0x70 ) ) ) //required to update ms instantly
                return true
            endif
        endif

        return false
    endfunction

    function AddUnitBonusMovespeed takes unit u, real r returns nothing
        call SetUnitBonusMoveSpeed( u, GetUnitBonusMoveSpeed( u ) + r )
    endfunction

    function GetUnitCurrentSight takes unit u returns real
        local integer pData = ConvertHandle( u )
        
        if pData > 0 then
            set pData = GetCObjectFromHashGroup( pData + 0x104 )

            if pData > 0 then
                return GetRealFromMemory( ReadRealMemory( pData + 0x78 ) )
            endif
        endif

        return 0.
    endfunction

    function SetUnitCurrentSight takes unit u, real newsight returns nothing
        local integer pData = ConvertHandle( u )
        
        if pData > 0 then
            set pData = GetCObjectFromHashGroup( pData + 0x104 )

            if pData > 0 then
                call UnitAddAbility( u, 'AIsi' )
                call UnitRemoveAbility( u, 'AIsi' )
                call WriteRealMemory( pData + 0x78, SetRealIntoMemory( newsight ) )
            endif
        endif
    endfunction
    
    function SetUnitMaxLife takes unit u, real newhp returns nothing
        local integer pData = ConvertHandle( u )
        
        if pData > 0 then
            set pData = GetCObjectFromHashGroup( pData + 0xA0 )

            if pData > 0 then
                call WriteRealMemory( pData + 0x84, SetRealIntoMemory( newhp ) )
            endif
        endif
    endfunction

    function AddUnitMaxLife takes unit u, real value returns nothing
        call SetUnitMaxLife( u, GetUnitState( u, UNIT_STATE_MAX_LIFE ) + value )
    endfunction

    function SetUnitMaxMana takes unit u, real newmp returns nothing
        local integer pData = ConvertHandle( u )
        
        if pData > 0 then
            set pData = GetCObjectFromHashGroup( pData + 0xC0 )

            if pData > 0 then
                call WriteRealMemory( pData + 0x84, SetRealIntoMemory( newmp ) )
            endif
        endif
    endfunction

    function AddUnitMaxMana takes unit u, real value returns nothing
        call SetUnitMaxMana( u, GetUnitState( u, UNIT_STATE_MAX_MANA ) + value )
    endfunction

    function GetWidgetLifeRegen takes widget u returns real
        local integer pData = ConvertHandle( u )
        
        if pData > 0 then
            set pData = GetCObjectFromHashGroup( pData + 0xA0 )

            if pData > 0 then
                return GetRealFromMemory( ReadRealMemory( pData + 0x7C ) )
            endif
        endif

        return 0.
    endfunction

    function GetUnitLifeRegen takes unit u returns real
        return GetWidgetLifeRegen( u )
    endfunction

    function SetUnitLifeRegen takes unit u, real r returns nothing
        local integer pData = ConvertHandle( u )
        local real curhp    = GetWidgetLife( u )

        if pData > 0 then
            if curhp > 0 then
                set pData = GetCObjectFromHashGroup( pData + 0xA0 )

                if pData > 0 then
                    call WriteRealMemory( pData + 0x7C, SetRealIntoMemory( r ) )
                    call SetWidgetLife( u, curhp )
                endif
            endif
        endif
    endfunction

    function AddUnitLifeRegen takes unit u, real r returns nothing
        call SetUnitLifeRegen( u, GetUnitLifeRegen( u ) + r )
    endfunction

    function GetUnitManaRegen takes unit u returns real
        local integer pData = ConvertHandle( u )
        
        if pData > 0 then
            set pData = GetCObjectFromHashGroup( pData + 0xC0 )

            if pData > 0 then
                return GetRealFromMemory( ReadRealMemory( pData + 0x7C ) )
            endif
        endif

        return 0.
    endfunction

    function SetUnitManaRegen takes unit u, real r returns nothing
        local integer pData = ConvertHandle( u )
        local real curmp = GetUnitState( u, UNIT_STATE_MANA )

        if pData > 0 then
            if curmp > 0 then
                set pData = GetCObjectFromHashGroup( pData + 0xC0 )

                if pData > 0 then
                    call WriteRealMemory( pData + 0x7C, SetRealIntoMemory( r ) )
                    call SetUnitState( u, UNIT_STATE_MANA, curmp )
                endif
            endif
        endif
    endfunction

    function AddUnitManaRegen takes unit u, real r returns nothing
        call SetUnitManaRegen( u, GetUnitManaRegen( u ) + r )
    endfunction
    //===========================================

    function Init_MemHackUnitNormalAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pUnitData                   = pGameDLL + 0xACB2B4
                set pRedrawUnit                 = pGameDLL + 0x285350
                set pCommonSilence              = pGameDLL + 0x0773A0
                set pPauseUnitDisabler          = pGameDLL + 0x077420
                set pSetStunToUnit              = pGameDLL + 0x270420
                set pUnsetStunToUnit            = pGameDLL + 0x283650
                set pSetUnitTexture             = pGameDLL + 0x4D3DE0
                set pGetHeroNeededXP            = pGameDLL + 0x208270
                set pUpdateUnitInfoBar          = pGameDLL + 0x333370
                set pMorphUnitToTypeId          = pGameDLL + 0x2A2A40
                set pUpdateHeroBar              = pGameDLL + 0x270970
                set pApplyUnitUpgrades          = pGameDLL + 0x2B3FC0
                set pUnapplyUnitUpgrades        = pGameDLL + 0x2B3FF0
                set pRefreshPortraitIfSelected  = pGameDLL + 0x270930
                set pRefreshInfoBarIfSelected   = pGameDLL + 0x270940
        elseif PatchVersion == "1.26a" then
                set pUnitData                   = pGameDLL + 0xAB445C
                set pRedrawUnit                 = pGameDLL + 0x284830
                set pCommonSilence              = pGameDLL + 0x076770
                set pPauseUnitDisabler          = pGameDLL + 0x0767F0
                set pSetStunToUnit              = pGameDLL + 0x2A6440
                set pUnsetStunToUnit            = pGameDLL + 0x282B30
                set pSetUnitTexture             = pGameDLL + 0x4D32E0
                set pGetHeroNeededXP            = pGameDLL + 0x26EB50
                set pUpdateUnitInfoBar          = pGameDLL + 0x332830
                set pMorphUnitToTypeId          = pGameDLL + 0x2A1F20
                set pUpdateHeroBar              = pGameDLL + 0x26FE50
                set pApplyUnitUpgrades          = pGameDLL + 0x2B34A0
                set pUnapplyUnitUpgrades        = pGameDLL + 0x2B34D0
                set pRefreshPortraitIfSelected  = pGameDLL + 0x26FE10
                set pRefreshInfoBarIfSelected   = pGameDLL + 0x26FE20
                set pSetUnitFacingFlag          = pGameDLL + 0x3C5B1F
        elseif PatchVersion == "1.27a" then
                set pUnitData                   = pGameDLL + 0xBEC48C // "Unit '%s' missing required UI data - not valid in game.", -> v4 = dword_6F...
                set pRedrawUnit                 = pGameDLL + 0x67FB00
                set pCommonSilence              = pGameDLL + 0x471C40
                set pPauseUnitDisabler          = pGameDLL + 0x46F180
                set pSetStunToUnit              = pGameDLL + 0x66B600
                set pUnsetStunToUnit            = pGameDLL + 0x65AE60
                set pSetUnitTexture             = pGameDLL + 0x186F40
                set pGetHeroNeededXP            = pGameDLL + 0x668050
                set pUpdateUnitInfoBar          = pGameDLL + 0x3598C0
                set pMorphUnitToTypeId          = pGameDLL + 0x653220
                set pUpdateHeroBar              = pGameDLL + 0x67FA80
                set pApplyUnitUpgrades          = pGameDLL + 0x6AA8E0
                set pUnapplyUnitUpgrades        = pGameDLL + 0x6AD4E0
                set pRefreshPortraitIfSelected  = pGameDLL + 0x676610
                set pRefreshInfoBarIfSelected   = pGameDLL + 0x676600
        elseif PatchVersion == "1.27b" then
                set pUnitData                   = pGameDLL + 0xD709F4
                set pRedrawUnit                 = pGameDLL + 0x69D240
                set pCommonSilence              = pGameDLL + 0x48F380
                set pPauseUnitDisabler          = pGameDLL + 0x48C8C0
                set pSetStunToUnit              = pGameDLL + 0x688D30
                set pUnsetStunToUnit            = pGameDLL + 0x678590
                set pSetUnitTexture             = pGameDLL + 0x1A4C60
                set pGetHeroNeededXP            = pGameDLL + 0x685780
                set pUpdateUnitInfoBar          = pGameDLL + 0x377060
                set pMorphUnitToTypeId          = pGameDLL + 0x670950
                set pUpdateHeroBar              = pGameDLL + 0x69D1C0
                set pApplyUnitUpgrades          = pGameDLL + 0x6C8020
                set pUnapplyUnitUpgrades        = pGameDLL + 0x6CAC20
                set pRefreshPortraitIfSelected  = pGameDLL + 0x693D40
                set pRefreshInfoBarIfSelected   = pGameDLL + 0x693D30
        elseif PatchVersion == "1.28f" then
                set pUnitData                   = pGameDLL + 0xD3882C
                set pRedrawUnit                 = pGameDLL + 0x6D13F0
                set pCommonSilence              = pGameDLL + 0x4C3490
                set pPauseUnitDisabler          = pGameDLL + 0x4C09D0
                set pSetStunToUnit              = pGameDLL + 0x6BCEC0
                set pUnsetStunToUnit            = pGameDLL + 0x6AC6C0
                set pSetUnitTexture             = pGameDLL + 0x1D74F0
                set pGetHeroNeededXP            = pGameDLL + 0x6B9910
                set pUpdateUnitInfoBar          = pGameDLL + 0x3AB170
                set pMorphUnitToTypeId          = pGameDLL + 0x6A4A80
                set pUpdateHeroBar              = pGameDLL + 0x6D1370
                set pApplyUnitUpgrades          = pGameDLL + 0x6FC1D0
                set pUnapplyUnitUpgrades        = pGameDLL + 0x6FEDD0
                set pRefreshPortraitIfSelected  = pGameDLL + 0x6C7F00
                set pRefreshInfoBarIfSelected   = pGameDLL + 0x6C7EF0
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackUnitNormalAPI takes nothing returns nothing
    //set gg_trg_MemHackUnitNormalAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackGroupAPI
//===========================================================================
//TESH.scrollpos=12
//TESH.alwaysfold=0
//! nocjass
library MemoryHackGroupAPI
    globals
        integer iGroupIterator       = 0
        integer pGroupGetUnitByIndex = 0
    endglobals

    function GetAddressGroupUnitCount takes integer pObj returns integer
        if pObj > 0 then
            return ReadRealMemory( pObj + 0x34 )
        endif
        
        return 0
    endfunction

    function GetAddressGroupAddressUnitByIndex takes integer pObj, integer index returns integer
        if pObj > 0 then
            return this_call_2( pGroupGetUnitByIndex, pObj + 0x24, index )
        endif

        return 0
    endfunction

    function GetGroupUnitCount takes group g returns integer
        return GetAddressGroupUnitCount( ConvertHandle( g ) )
    endfunction
    
    function GetUnitFromGroupByIndex takes group g, integer index returns unit
        local integer pObj = GetAddressGroupAddressUnitByIndex( ConvertHandle( g ), index )

        if pObj > 0 then
            set pObj = ObjectToHandleId( pObj )

            if pObj > 0 then
                return I2U( pObj )
            endif
        endif

        return null
    endfunction
    
    function GetRandomUnitFromGroup takes group g returns unit
        local integer pObj  = ConvertHandle( g )
        local integer count = 0
        
        if pObj > 0 then
            set count = GetAddressGroupUnitCount( pObj )
            if count > 0 then
                set pObj  = GetAddressGroupAddressUnitByIndex( pObj, GetRandomInt( 0, count - 1 ) )

                if pObj > 0 then
                    set pObj = ObjectToHandleId( pObj )
                    
                    if pObj > 0 then
                        return I2U( pObj )
                    endif
                endif
            endif
        endif

        return null
    endfunction
    
    function ForEach takes group g returns unit
        local integer pObj = GetAddressGroupAddressUnitByIndex( ConvertHandle( g ), iGroupIterator )

         if pObj > 0 then
            set iGroupIterator = iGroupIterator + 1
            set pObj = ObjectToHandleId( pObj )

            if pObj > 0 then
                return I2U( pObj )
            endif
        else
            set iGroupIterator = 0
        endif

        return null
    endfunction

    function Init_MemHackGroupAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pGroupGetUnitByIndex = pGameDLL + 0x422560
        elseif PatchVersion == "1.26a" then
                set pGroupGetUnitByIndex = pGameDLL + 0x421A20
        elseif PatchVersion == "1.27a" then
                set pGroupGetUnitByIndex = pGameDLL + 0x272910
        elseif PatchVersion == "1.27b" then
                set pGroupGetUnitByIndex = pGameDLL + 0x290570
        elseif PatchVersion == "1.28f" then
                set pGroupGetUnitByIndex = pGameDLL + 0x230AA0
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackGroupAPI takes nothing returns nothing
    //set gg_trg_MemHackGroupAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackMouseAPI
//
// This trigger can be safely removed, since it provides probably no use to a normal mapmaker, since the data is local anyways.
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library MemoryHackMouseAPI
    globals
        integer pGameClass2         = 0
        integer pGlobalMouseEvent   = 0
    endglobals

    function GetCursorX takes nothing returns integer
        local integer pMouse = GetCursorPos( )
        
        if pMouse > 0 then
            return ReadRealMemory( pCursorCoords + 0x0 )
        endif

        return 0
    endfunction

    function GetCursorY takes nothing returns integer
        local integer pMouse = GetCursorPos( )
        
        if pMouse > 0 then
            return ReadRealMemory( pCursorCoords + 0x4 )
        endif

        return 0
    endfunction

    function GetCursorXRelative takes nothing returns integer
        local integer pMouse = GetCursorPos( )

        if pMouse > 0 then
            if ScreenToClient( pHWND_WC3, pCursorCoords ) > 0 then
                return ReadRealMemory( pCursorCoords + 0x0 )
            endif
        endif

        return 0
    endfunction

    function GetCursorYRelative takes nothing returns integer
        local integer pMouse = GetCursorPos( )

        if pMouse > 0 then
            if ScreenToClient( pHWND_WC3, pCursorCoords ) > 0 then
                return ReadRealMemory( pCursorCoords + 0x4 )
            endif
        endif

        return 0
    endfunction

    function GetMouseWorldEnv takes nothing returns integer
        return ReadRealMemory( ReadRealMemory( pGameClass2 ) + 0x3BC ) + 0x310
    endfunction

    function GetMouseWorldX takes nothing returns real
        return GetRealFromMemory( ReadRealMemory( GetMouseWorldEnv( ) + 0x0 ) )
    endfunction

    function GetMouseWorldY takes nothing returns real
        return GetRealFromMemory( ReadRealMemory( GetMouseWorldEnv( ) + 0x4 ) )
    endfunction

    function GetMouseWorldZ takes nothing returns real
        return GetRealFromMemory( ReadRealMemory( GetMouseWorldEnv( ) + 0x8 ) )
    endfunction
    
    function Init_MemHackMouseAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pGameClass2         = pGameDLL + 0xACBDD8
                set pGlobalMouseEvent   = pGameDLL + 0xAB0454
        elseif PatchVersion == "1.26a" then
                set pGameClass2         = pGameDLL + 0xAB4F80
                set pGlobalMouseEvent   = pGameDLL + 0xA9A434
        elseif PatchVersion == "1.27a" then
                set pGameClass2         = pGameDLL + 0xBE6350 // (_DWORD *)Storm_401(1108, "CGameUI.cpp", 6831, 
                set pGlobalMouseEvent   = pGameDLL + 0xB66308 //  = &CMouseEvent::`vftable`;
        elseif PatchVersion == "1.27b" then
                set pGameClass2         = pGameDLL + 0xD6A8B8
                set pGlobalMouseEvent   = pGameDLL + 0xCE3A8C
        elseif PatchVersion == "1.28f" then
                set pGameClass2         = pGameDLL + 0xD326F0
                set pGlobalMouseEvent   = pGameDLL + 0xCB1AD4
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackMouseAPI takes nothing returns nothing
    //set gg_trg_MemHackMouseAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: InitMemoryHack
//===========================================================================
//TESH.scrollpos=54
//TESH.alwaysfold=0
//! nocjass
globals
    integer pGameDLL     = 0
    string PatchVersion = ""
endglobals

function Init_MemoryHack takes nothing returns nothing
    if PatchVersion != "" then
        call DisplayTextToPlayer( GetLocalPlayer( ), 0, 0, "MemHackAPI v1.6" )
        call DisplayTextToPlayer( GetLocalPlayer( ), 0, 0, "Patch Version: " + PatchVersion )

        // Before removing any of the Init_API functions, make sure you removed functions that depend on them!
        // Do NOT put any of the hooks or memory modifications BEFORE all of these init methods are done.
        // You can however disable and remove stuff you don't need, but some of the modules may still have connections.
        // Remove things that you don't need responsibly!

        //====================Init====================
        call Init_APITypecast( )                        // API for general value typecasting, required by some of the functions!
        call Init_APIMemory( )                          // API for general memory read/write management, everything else depends on this!
        call Init_APIMemoryCalls( )                     // API for tapping into  std/this/cdecl calls and much more, pretty much core of everything.
        call Init_APIMemoryBitwise( )                   // API for bitwise operations many other functions use this.
        call Init_APIMemoryKernel( )                    // API for accessing some of the WinAPI functions, mostly needed for VirtualProtect.
        call Init_APIMemoryMPQ( )                       // API for managing MPQs and files in general, generally this is useless to average mapmaker.
        call Init_APIMemoryString( )                    // API for getting/setting strings from/into memory, most functions use this!
        call Init_APIMemoryStormDLL( )                  // API containing some needed functions from Storm.dll, be cautious with this API.
        call Init_APIMemoryGameData( )                  // API for getting essential data from memory.
        call Init_APIMemoryObjectData( )                // API for object data modification, Effect/Trackable and some Unit functions refer to this.
        call Init_APIMemoryGameUI( )                    // API for general UI handling, and GameUI structure, serves as a core to FrameAPI and UIAPI.
        call Init_APIMemoryGameUIButton( )              // API for Button managment and data handling, getting and even setting information is possible.
        call Init_APIMemoryGameWindow( )                // API that contains functions and data for managing Warcraft 3 game window.
        call Init_MemHackConstantsAPI( )                // API for editing of constants in Warcraft 3, at the moment only OPLimit added.
        call Init_MemHackCFrameAPI( )                   // API Containing base functions for frames of CFrame type.
        call Init_MemHackCLayerAPI( )                   // API Containing base functions for frames of CLayer type.
        call Init_MemHackCBackDropFrameAPI( )           // API Containing base functions for frames of CBackDropFrame type.
        call Init_MemHackCEditBoxAPI( )                 // API Containing base functions for frames of CEditBox type.
        call Init_MemHackCLayoutFrameAPI( )             // API Containing base functions for frames of CLayoutFrame type.
        call Init_MemHackCModelFrameAPI( )              // API Containing base functions for frames of CModelFrame type.
        call Init_MemHackCSimpleButtonAPI( )            // API Containing base functions for frames of CSimpleButton type.
        call Init_MemHackCSimpleFontAPI( )              // API Containing base functions for frames of CSimpleFont type.
        call Init_MemHackCSimpleGlueAPI( )              // API Containing base functions for frames of CSimpleGlue type.
        call Init_MemHackCSimpleFrameAPI( )             // API Containing base functions for frames of CSimpleFrame type.
        call Init_MemHackCSimpleMessageFrameAPI( )      // API Containing base functions for frames of CSimpleMessageFrame type.
        call Init_MemHackCSliderAPI( )                  // API Containing base functions for frames of CSlider type.
        call Init_MemHackCSpriteFrameAPI( )             // API Containing base functions for frames of CSpriteFrame type.
        call Init_MemHackCTextAreaAPI( )                // API Containing base functions for frames of CTextArea type.
        call Init_MemHackCTextFrameAPI( )               // API Containing base functions for frames of CTextFrame type.
        call Init_MemHackCSimpleStatusBarAPI( )         // API Containing base functions for frames of CSimpleStatusBar type.
        call Init_MemHackCStatusBarAPI( )               // API Containing base functions for frames of CStatusBar type.
        call Init_MemHackCSimpleTextureAPI( )           // API Containing base functions for frames of CSimpleTexture type.
        call Init_MemHackCSimpleRegionAPI( )            // API Containing base functions for frames of CSimpleRegion type.
        call Init_MemHackFrameAPI( )                    // API allowing you to modify SOME frames, peek for more information.
        call Init_MemHackUIAPI( )                       // API allowing you to modify SOME UI elements, contains mostly userfriendly API.
        call Init_MemHackPlayerAPI( )                   // Not required, simply contains some niche functions, non-userfriendly API at the moment.
        call Init_MemHackAbilityAddressAPI( )           // API allowing you to modify ability data freely, peek into the library for the functions.
        call Init_MemHackAbilityBaseAPI( )              // Refers to Init_MemHackAbilityAddressAPI and UIBaseData, contains a simple user-friendly API.
        call Init_MemHackAbilityNormalAPI( )            // Refers to Init_MemHackAbilityAddressAPI, contains a simple user-friendly API.
        call Init_MemHackAbilityUnitAPI( )              // Refers to Init_MemHackAbilityAddressAPI, contains a simple user-friendly API.
        call Init_MemHackCWidgetBaseAPI( )              // API Allowing you to modify some Widget UI/Base data, this is partially used by Base Item API and Base Unit API.
        call Init_MemHackCWidgetNormalAPI( )            // Contains a small portion of things that can be done to widgets, i.e. anything based of widget. 
        call Init_MemHackItemBaseAPI( )                 // API allowing you to modify item's base data.
        call Init_MemHackItemNormalAPI( )               // Contains a small portion of things that can be done to items.
        call Init_MemHackUnitBaseAPI( )                 // API allowing you to modify unit's base data.
        call Init_MemHackUnitNormalAPI( )               // API allowing you to modify unit data freely, peek into the library for the functions.
        call Init_MemHackGroupAPI( )                    // API allowing you to gain access to more functions involving groups, such as ForEach.
        call Init_MemHackEffectAPI( )                   // API allowing you to modify effect data freely, peek into the library for the functions.
        call Init_MemHackTrackableAPI( )                // Since trackables share the same structure as effects they get same API as effects do.
        call Init_MemHackCastAbility( )                 // API for ability cast, Not required if you are fine with using orders.
        call Init_MemHackMouseAPI( )                    // API for getting local World Mouse position, will cause desync if used on synced functions!
        //=============================================

        //===============Additional APIs=============== // These APIs are for user to decide wherever they are needed or no, you are free to comment them out.
        call Init_APIMemoryRestorer( )                  // API that is responsible for cleaning up all memory modifications after exiting the map. I suggest leaving it UNCOMMENTED, as it cleans up memory.
        //call Init_AntiHack( )                         // Not required, this only works on 1.24e, 1.26a and a bit on 1.27b, as it states it counters hacks.
        call Init_MemHackBerserkHook( )               // Not required, please check what it does and modify or remove if you don't need/understand it!
        call Init_MemHackDamageEventHook( )           // Not required if you do not care about expanding Damage Event, i.e. for getting data pre-damage.
        //call Init_APIMemoryWenHao( )                  // Not required, this simply injects wenhao_plugin.tga with its functionality, and so on...
        call Init_MemHackCustomAbilityChargesHook( )  // Not required, adds visual charges to abilities, note, they are only visual!
        //call Init_DrawAllCooldowns( )                 // Not required, this simple mimics what my WFE can do, in short, this is deprecated.
        //=============================================

        //=================Your Stuff==================

        //=============================================
    else
        call DisplayTextToPlayer( GetLocalPlayer( ), 0, 0, "Unsupported patch version!" )
    endif

    call DestroyTimer( GetExpiredTimer( ) )
endfunction

//===========================================================================
function InitTrig_InitMemoryHack takes nothing returns nothing
    //set gg_trg_InitMemoryHack = CreateTrigger(  )
    set bj_FORCE_PLAYER[ 0 ] = CreateForce( )
    call ForceAddPlayer( bj_FORCE_PLAYER[ 0 ], Player( 0 ) )
    call ForForce( bj_FORCE_PLAYER[ 0 ], I2C( C2I( function UnlockMemory ) + 0x8 ) )
    call TimerStart( CreateTimer( ), .05, false, function Init_MemoryHack )
endfunction
//! endnocjass
//===========================================================================
// Trigger: InitMainHook
//
// This is a specific trigger/code made for versions 1.27b and above, more information about it will be explained in the comments in the code itself.
// For those who are below 1.27b (1.27a and lower) can ignore this "main" function hook, meaning all you have to do is disable this trigger.
//===========================================================================
//TESH.scrollpos=7
//TESH.alwaysfold=0
//! nocjass
library ZzendOpMap

function main2 takes nothing returns nothing
    // Map specific data, remove it and replace with your things, etc...
    local real map_min_x = -3328.
    local real map_min_y = -3584.
    local real map_max_x = 3328.
    local real map_max_y = 3072.
    local real c_m_l = GetCameraMargin( CAMERA_MARGIN_LEFT )
    local real c_m_b = GetCameraMargin( CAMERA_MARGIN_BOTTOM )
    local real c_m_r = GetCameraMargin( CAMERA_MARGIN_RIGHT )
    local real c_m_t = GetCameraMargin( CAMERA_MARGIN_TOP )
    call SetCameraBounds( map_min_x + c_m_l, map_min_y + c_m_b, map_max_x - c_m_r, map_max_y - c_m_t, map_min_x + c_m_l, map_max_y - c_m_t, map_max_x - c_m_r, map_min_y + c_m_b )
    call SetDayNightModels( "Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl", "Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl" )

    call InitTrig_Testing( )
    // All of the above is just map specific data, replace it with yours!
    
    // Your stuff goes here...
    
    // This is just to init testing code, feel free to remove it!
endfunction

endlibrary

library InitMain
// This is where we hook "main" function that World Editor generates, so we have full control over it.
//! inject main
//! dovjassinit
// We are calling for MemHack FIRST, to ensure that it works (this is crucial on patches 1.27b and above).
// The reason is simple, apparently locals sometimes occupy the memory that we need to open WRITE functionality, hence causing a crash.
// Also, this allows you as a user to freely control what is and what is NOT needed in your map.
call InitTrig_InitMemoryHack( )
call CreateAllUnits( )
// Now that MemHack is loaded, you can call whatever functions you need. Initialisers and such, but remember, do NOT put ANYTHING above MemHack execution.
// Your stuff goes here...
// Note, if you are too lazy to re-do everything, you can check what your main function currently contains.
// Rename it to let's say main2 and just call main2 right below InitTrig_InitMemoryHack function.
call main2( ) // this is an example you can also do: call ExecuteFunc( "main2" )

// Note: If you use ExecuteFunc, make sure that there are NO SUBSEQUENT ExecuteFunc inside of main2, this could cause the threading issue.
//! endinject

// You can also hook config function in the same way and modify it if needed (which is suggested for direct control over slots and such).
endlibrary

//===========================================================================
function InitTrig_InitMainHook takes nothing returns nothing
//    set gg_trg_InitMainHook = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: TestHookedDamageEvent
//
// This trigger can be removed, as it serves only for demonstration of how to use a modified Damaged Event.
// You can freely remove/disable this trigger.
//===========================================================================
//TESH.scrollpos=50
//TESH.alwaysfold=0
//! nocjass
library TestHookedDamageEvent
    globals
        group DE_Group     = null
        unit DE_TempUnit   = null
        trigger DE_Trigger = null
    endglobals

    function GetDamageId takes integer dmg_t returns integer
        return log( dmg_t, 2 ) // Gets base 2 logarithm of WeaponType.
    endfunction
    
    function OnUnitDamagedHandlerEx takes integer eventData, unit source, unit target, real dmg returns boolean
        local real init_dmg = CleanReal( IndexToReal( ReadRealMemory( eventData + 0x04 ) ) )
        local integer phys  = ReadRealMemory( eventData + 0x08 ) // Pointer to parametres or flag saved by damage source, results may vary!
        local integer unk_1 = ReadRealMemory( eventData + 0x0C ) // ??
        local integer pTarg = ReadRealMemory( eventData + 0x10 ) // Target
        local integer data  = ReadRealMemory( eventData + 0x00 ) // CDamageData
        local integer src_u = ReadRealMemory( data + 0x00 ) // CUnit source
        local integer wpn_t = ReadRealMemory( data + 0x04 ) // weapon_type
        local integer flags = ReadRealMemory( data + 0x0C ) // flags
        local real real_dmg = CleanReal( IndexToReal( ReadRealMemory( data + 0x10 ) ) ) // damage
        local integer dmg_t = ReadRealMemory( data + 0x14 ) // Use GetDamageTypeByAddr( dmg_t ) to get Damage Type id.
        local integer atk_t = ReadRealMemory( data + 0x20 )
        local boolean retval = false // set this value to true, if you handled what you needed in here so OnUnitDamagedHandler will simply end.

        // Attack Types: Spell = 0, Normal = 1, Piercing = 2, Siege = 3, Magic = 4, Chaos = 5, Hero = 6
        // Weapon Types: Melee = 0, Instant = 1, Ranged = 2, ?? = 3, ?? = 4, Splash = 5, Bounce = 6, ?? = 7, ?? = 8
        // 0x4 - DO NOT DEAL DAMAGE (?) | 0x8 - Multishot | 0x10 - Projectile | 0x20 - Penetrates invulnerability
        // 0x40 - DO NOT cause "unit attacked" for the owner (red blinking) (cleave & splash use it!)
        // 0x100 - Melee | 0x101 - Ranged
        // 0x200 - DO NOT cause "unit attacked" for the owner (minimap ping, etc) used in Cyclone (land), hex (end), etc, not sure
        // plain 0x40 == cleave, 0x141 == splash | 0x80 - autocast modifier? | 0x10 - slow aura flag (not a relevant damage? nullify any damage value)
        // Damage Types: ConvertDamageType( i ) = 2 ^ i => ConvertDamageType( 5 ) = 2 ^ 5 = 32 = DAMAGE_TYPE_ENHANCED | Thus reverse is MathLog( 32, 2 ) => 5

        if false then // Miscellaneous Checks
            if flags == 0x10 and phys == ConvertHandle( target ) then // Check WindWalk | Thunderbolt
                //call DisplayTextToPlayer( GetLocalPlayer( ), 0, 0, "WindWalk" )
            endif

            if flags == 0x1 and atk_t == 0 and dmg_t == 0x20 and GetUnitAbilityLevel( source, 'NONE' ) > 0 then // Check Fan of Knives based on Id.
                // Change 'NONE' to your Fan of Knives id, to check if damage was caused by it.
            endif
        endif

        if phys == 1 then // Non-Spell Damage || ( IsFlagBitSet( flags, 0x100 ) or IsFlagBitSet( flags, 0x101 ) ) and atk_t != 0
            //call ClearTextMessages( )
            call DisplayTextToPlayer( GetLocalPlayer( ), 0, 0, "Physical Damage" )
        else
            call DisplayTextToPlayer( GetLocalPlayer( ), 0, 0, "Magical Damage" )
        endif

        //call DisplayTextToPlayer( GetLocalPlayer( ), 0, 0, "Attack Type: " + I2S( atk_t ) + "\n" + "Damage Type: " + I2S( dmg_t ) + "\n" + "Weapon Type: " + I2S( wpn_t ) )
        return retval
    endfunction

    function OnUnitDamagedHandler takes unit source, unit target, real dmg returns nothing
        local integer evntData  = GetDamageEventESPData( )
        local boolean skipBasic = false

        if evntData != 0 then // Check if we had hooked OnDamage data, if not we skip it to not cause a fatal error.
            set skipBasic = OnUnitDamagedHandlerEx( evntData, source, target, dmg )
            call DisplayTextToPlayer( GetLocalPlayer( ), 0, 0, "OnUnitDamagedHandlerEx" )
        else
            call DisplayTextToPlayer( GetLocalPlayer( ), 0, 0, "OnUnitDamagedHandler" )
        endif

        if not skipBasic then
            // Here you can put anything related to EVENT_UNIT_DAMAGED that does not need MemHack.
            // Edit return value in the function in conditions you set to true, if you wish to skip it reaching this part of the code
            
        endif
    endfunction

    function OnUnitDamagedAction takes nothing returns nothing
        call DisableTrigger( GetTriggeringTrigger( ) )
        call OnUnitDamagedHandler( GetEventDamageSource( ), GetTriggerUnit( ), GetEventDamage( ) )
        call EnableTrigger( GetTriggeringTrigger( ) )
    endfunction
endlibrary
//===========================================================================
function TestHookedDamageEventEnumUnits takes nothing returns nothing
    call GroupEnumUnitsInRect( DE_Group, GetWorldBounds( ), null )
    loop
        set DE_TempUnit = FirstOfGroup( DE_Group )
        exitwhen DE_TempUnit == null
        call TriggerRegisterUnitEvent( DE_Trigger, DE_TempUnit, EVENT_UNIT_DAMAGED )
        call GroupRemoveUnit( DE_Group, DE_TempUnit )
    endloop
endfunction

function InitTrig_TestHookedDamageEvent takes nothing returns nothing
    if DE_Trigger == null then // Init Damaged Event
        set DE_Group   = CreateGroup( )
        set DE_Trigger = CreateTrigger( )
        call TriggerAddAction( DE_Trigger, function OnUnitDamagedAction )
    endif

    if DE_Trigger != null then
        call TestHookedDamageEventEnumUnits( )
    endif
    //set gg_trg_TestHookedDamageEvent = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackDrawCooldown
//===========================================================================
//TESH.scrollpos=220
//TESH.alwaysfold=0
//! nocjass
library MemoryHackzDrawCooldowns
    globals
        hashtable pCDTable = InitHashtable( )
        timer pCDDrawTimer = CreateTimer( )
        integer pSomeFrame = 0
    endglobals

    function GetBTableShadow takes integer buttonId, integer id returns integer
        return LoadInteger( pCDTable, StringHash( "Button_" + I2S( buttonId ) ), StringHash( "Shadow_" + I2S( id ) ) )
    endfunction

    function GetBTableText takes integer buttonId returns integer
        return LoadInteger( pCDTable, StringHash( "Button_" + I2S( buttonId ) ), StringHash( "Text" ) )
    endfunction

    function DrawButtonCooldown takes integer id, integer pButton returns boolean
        local integer i = 0
        local real cd
        local string text = ""

        if pButton > 0 then
            set cd = GetButtonCooldown( pButton )

            if cd > 0. then
                if cd >= 10. then
                    set text = I2S( R2I( cd ) )
                else
                    set text = R2SW( cd, 1, 1 )
                endif
            endif

            loop
                exitwhen i > 7
                //if i == 0 or i == 3 or i == 7 then
                    call SetCSimpleFontText( GetBTableShadow( id, i ), text )
                //endif
                set i = i + 1
            endloop

            call SetCSimpleFontText( GetBTableText( id ), text )
            return true
        endif

        return false
    endfunction

    function CreateButtonCooldown takes integer id, integer pButton returns boolean
        local integer pFrame = 0
        local integer i = 0

        if pButton > 0 then
            loop
                exitwhen i > 7
                //if i == 0 or i == 3 or i == 7 then
                    set pFrame = CreateCSimpleFont( pButton )
                    call SetCSimpleRegionVertexColourEx( pFrame, 0xFF, 0x00, 0x00, 0x00 )
                    call SetCSimpleFontStringFont( pFrame, "Fonts\\FRIZQT__.TTF", .1, 0 )
                    call SetCSimpleFontText( pFrame, "" )
                    call SetCSimpleFontStringScale( pFrame, 1.5 )
                    call SaveInteger( pCDTable, StringHash( "Button_" + I2S( id ) ), StringHash( "Shadow_" + I2S( i ) ), pFrame )
                //endif
                set i = i + 1
            endloop

            set pFrame = CreateCSimpleFont( pButton )
            call SetCSimpleRegionVertexColourEx( pFrame, 0xFF, 0xFF, 0xFF, 0xFF )
            call SetCSimpleFontStringFont( pFrame, "Fonts\\FRIZQT__.TTF", .095, 0 )
            call SetCSimpleFontText( pFrame, "" )
            call SetFramePoint( pFrame, ANCHOR_CENTER, pButton, ANCHOR_CENTER, 0., 0. )
            call SaveInteger( pCDTable, StringHash( "Button_" + I2S( id ) ), StringHash( "Text" ), pFrame )

            call SetFramePoint( GetBTableShadow( id, 0 ), ANCHOR_CENTER, pFrame, ANCHOR_CENTER, 0.0003, -0.0003 ) // +
            call SetFramePoint( GetBTableShadow( id, 1 ), ANCHOR_CENTER, pFrame, ANCHOR_CENTER, 0.0003, 0. )
            call SetFramePoint( GetBTableShadow( id, 2 ), ANCHOR_CENTER, pFrame, ANCHOR_CENTER, 0.0003, 0.0003 )
            call SetFramePoint( GetBTableShadow( id, 3 ), ANCHOR_CENTER, pFrame, ANCHOR_CENTER, 0., 0.0003 ) // +
            call SetFramePoint( GetBTableShadow( id, 4 ), ANCHOR_CENTER, pFrame, ANCHOR_CENTER, -0.0003, 0.0003 )
            call SetFramePoint( GetBTableShadow( id, 5 ), ANCHOR_CENTER, pFrame, ANCHOR_CENTER, -0.0003, 0. )
            call SetFramePoint( GetBTableShadow( id, 6 ), ANCHOR_CENTER, pFrame, ANCHOR_CENTER, -0.0003, -0.0003 )
            call SetFramePoint( GetBTableShadow( id, 7 ), ANCHOR_CENTER, pFrame, ANCHOR_CENTER, 0., -0.0003 ) // +
            return true
        endif

        return false
    endfunction

    function DrawAllButtonCooldowns takes nothing returns nothing
        local integer i = 0
        local integer j = 0
        local integer k = 0
        local real dis  = 0.
        local real cd   = 0.
        local integer p = 0

        if not HaveSavedBoolean( pCDTable, StringHash( "pCDTable" ), StringHash( "IsInit" ) ) then
            call SaveBoolean( pCDTable, StringHash( "pCDTable" ), StringHash( "IsInit" ), true )
            
            loop
                exitwhen i > 17
                if i == 12 then
                    set j = 0
                endif

                if i < 12 then
                    set p = GetSkillBarButton( j )
                else
                    set p = GetItemBarButton( j )
                endif

                call CreateButtonCooldown( i, p )
                set i = i + 1
                set j = j + 1
            endloop
        endif

        set i = 0
        set j = 0
        loop
            exitwhen i > 17
            if i == 12 then
                set j = 0
            endif

            if i < 12 then
                set p = GetSkillBarButton( j )
            else
                set p = GetItemBarButton( j )
            endif

            call DrawButtonCooldown( i, p )
            set i = i + 1
            set j = j + 1
        endloop
    endfunction

    globals
        integer array pCDTextShadow
        integer array pCDFrame
    endglobals
    
    function OldStyleCooldownDrawing takes nothing returns nothing
        local integer i = 0
        local integer j = 0
        local integer k = 0
        local real dis  = 0.
        local real cd   = 0.
        local integer p = 0

        if pSomeFrame == 0 then
            set p = GetSkillBarButton( 5 )

            if p > 0 then
                loop
                    exitwhen k > 7
                    set pCDTextShadow[ k ] = CreateCSimpleFont( p )
                    call SetCSimpleRegionVertexColourEx( pCDTextShadow[ k ], 0xFF, 0x00, 0x00, 0x00 )
                    call SetCSimpleFontStringFont( pCDTextShadow[ k ], "Fonts\\FRIZQT__.TTF", .1, 0 )
                    call SetCSimpleFontText( pCDTextShadow[ k ], "60" )
                    call SetCSimpleFontStringScale( pCDTextShadow[ k ], 1.5 )
                    set k = k + 1
                endloop

                set pSomeFrame = CreateCSimpleFont( p )
                call SetCSimpleRegionVertexColourEx( pSomeFrame, 0xFF, 0xFF, 0xFF, 0xFF )
                call SetCSimpleFontStringFont( pSomeFrame, "Fonts\\FRIZQT__.TTF", .095, 0 )
                call SetCSimpleFontText( pSomeFrame, "60" )
                call SetFramePoint( pSomeFrame, ANCHOR_CENTER, p, ANCHOR_CENTER, 0., 0. )

                call SetFramePoint( pCDTextShadow[ 0 ], ANCHOR_CENTER, pSomeFrame, ANCHOR_CENTER, 0.0003, -0.0003 )
                call SetFramePoint( pCDTextShadow[ 1 ], ANCHOR_CENTER, pSomeFrame, ANCHOR_CENTER, 0.0003, 0. )
                call SetFramePoint( pCDTextShadow[ 2 ], ANCHOR_CENTER, pSomeFrame, ANCHOR_CENTER, 0.0003, 0.0003 )
                call SetFramePoint( pCDTextShadow[ 3 ], ANCHOR_CENTER, pSomeFrame, ANCHOR_CENTER, 0., 0.0003 )
                call SetFramePoint( pCDTextShadow[ 4 ], ANCHOR_CENTER, pSomeFrame, ANCHOR_CENTER, -0.0003, 0.0003 )
                call SetFramePoint( pCDTextShadow[ 5 ], ANCHOR_CENTER, pSomeFrame, ANCHOR_CENTER, -0.0003, 0. )
                call SetFramePoint( pCDTextShadow[ 6 ], ANCHOR_CENTER, pSomeFrame, ANCHOR_CENTER, -0.0003, -0.0003 )
                call SetFramePoint( pCDTextShadow[ 7 ], ANCHOR_CENTER, pSomeFrame, ANCHOR_CENTER, 0., -0.0003 )

                //set pBackground = CreateCSimpleFont( p ) //CreateCSimpleTexture
                //call BJDebugMsg( "SetFrameSize = " + I2S( SetFrameSize( pBackground, .005, .005 ) ) )
                //call BJDebugMsg( "FillCSimpleTexture = " + I2S( FillCSimpleTexture( pBackground, 0xC0000000 ) ) )
                //call BJDebugMsg( "SetFramePointTexture = " + I2S( SetFramePoint( pBackground, ANCHOR_CENTER, pFrame, ANCHOR_CENTER, 0., 0. ) ) )

                //call BJDebugMsg( "UpdateFrame( pFrame ) = " + I2S( B2I( UpdateFrame( pFrame ) > 0 ) ) )
                //call BJDebugMsg( "ShowFrame( pFrame ) = " + I2S( ShowFrame( pFrame ) ) )
                //call BJDebugMsg( "SetFrameSize = " + I2S( SetFrameSize( pCDFrame[ i ], 0.2, 0. ) ) )
            endif
        endif

        loop
            exitwhen i > 17
            if i == 12 then
                set j = 0
            endif

            if i >= 9 and i <= 11 then
                set dis = .025
            else
                set dis = 0.
            endif

            if pCDFrame[ i ] == 0 then
                set pCDFrame[ i ] = CreateFrame( "UITextCenter", pGameUI, 20 + i )

                if pCDFrame[ i ] > 0 then
                    if i < 12 then
                        set p = GetSkillBarButton( j )
                    else
                        set p = GetItemBarButton( j )
                    endif

                    call SetFrameSize( pCDFrame[ i ], 0.2, 0. ) // call SetFrameSize( pCDFrame[ i ], 0.117, 0.03 )
                    call SetFramePoint( pCDFrame[ i ], ANCHOR_CENTER, p, ANCHOR_CENTER, dis, 0. )
                    call SetFrameFont( pCDFrame[ i ], "Fonts\\FRIZQT__.TTF", 15., 1 ) // 1 = shadow
                endif
            endif

            if pCDFrame[ i ] > 0 then
                if i < 12 then
                    set p = GetSkillBarButton( j )
                else
                    set p = GetItemBarButton( j )
                endif

                if p > 0 then
                    set cd = GetButtonCooldown( p )

                    if cd > 0. then
                        if cd >= 10. then
                            call SetFrameText( pCDFrame[ i ], I2S( R2I( cd ) ) )
                        else
                            call SetFrameText( pCDFrame[ i ], R2SW( cd, 1, 1 ) )
                        endif
                    else
                        call SetFrameText( pCDFrame[ i ], "" )
                    endif
                endif
            endif
            set i = i + 1
            set j = j + 1
        endloop

        //return
        //if pFrame == 0 then
            //set pFrame = CreateFrame( "UITextCenter", pGameUI, 20 )

            //if pFrame > 0 then
                //call SetFrameSize( pFrame, 0.117, 0.03 )
                //call SetFrameText( pFrame, "|cff00ff0060...|r" )
                //call SetFramePoint( pFrame, 1, GetCommandBarButton( 2, 0 ), 1, 0., -.007 )
                //call SetFrameText( pFrame, "|cff00ff00Pizdec-desu|r" )
            //endif
        //endif
    endfunction

    function DrawAllCooldownSetDelay takes real delay returns nothing
        call TimerStart( pCDDrawTimer, delay, true, function DrawAllButtonCooldowns )
    endfunction
    
    function Init_DrawAllCooldowns takes nothing returns nothing
        call DrawAllCooldownSetDelay( .01 )
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackDrawCooldown takes nothing returns nothing
    //set gg_trg_MemHackDrawCooldown = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackDamageHook
//
// This trigger is required if you want to generate damage event hook to enhance its capabilities.
// If you remove Init_MemHackDamageEventHook, and still use GetDamageEventESPData, it may cause fatal error!
//===========================================================================
//TESH.scrollpos=36
//TESH.alwaysfold=0
//! nocjass
library MemoryHackDamageEventHook
    globals
		integer pDamageStack 				= 0
		integer pDamageHook  				= 0
        integer pUnitVtable                 = 0
        
        trigger DamageTestTrig = CreateTrigger( )
    endglobals

	function GetDamageEventESPData takes nothing returns integer
		local integer Length = ReadRealMemory( pDamageStack )

		if ( Length > 0 ) then
			return ReadRealMemory( pDamageStack + 0x04 + 0x04 * ( Length - 1 ) )
		endif

		return 0
	endfunction
    
    function PreDamageData takes nothing returns nothing
        call BJDebugMsg( "PreDamageData" )
    endfunction

	function Init_DamageEventHook takes nothing returns nothing
        // This simply grabs data from CDamageData in CUnitOnDamage.
        // To replicate this in C++, we simply save data before calling the function and after.
        // Hence we will have predamage and postdamage data.
        // WriteRealMemorys below simply write asm code to replicate this method.

		local integer pSlot72			= pUnitVtable + 0x120 // 1.26a = 6F2A40D0 | CUnitOnDamage | 0x4 * 0x48
		local integer OldProtection 	= ChangeOffsetProtection( pSlot72, 4, 0x04 )
		local integer PreviousMethod 	= ReadRealMemory( pSlot72 )

		set pDamageStack 				= Malloc( 0x4 + 0x4 * 1024 ) // MAX_DAMAGE_STACK_SIZE = 1024
		set pDamageHook 				= AllocateExecutableMemory( 0x60 ) // due to call WriteRealMemory( pDamageHook + 0x5C, 0x0010C2C9 )

		call WriteRealMemory( pSlot72, pDamageHook )
		call ChangeOffsetProtection( pSlot72, 4, OldProtection )

		call WriteRealMemory( pDamageHook + 0x00, 0x8DE58955 )
		call WriteRealMemory( pDamageHook + 0x04, 0x53E82464 )
		call WriteRealMemory( pDamageHook + 0x08, 0xB8F84D89 )
		call WriteRealMemory( pDamageHook + 0x0C, pDamageStack )
		call WriteRealMemory( pDamageHook + 0x10, 0x890C558B )
		call WriteRealMemory( pDamageHook + 0x14, 0x558BE855 )
		call WriteRealMemory( pDamageHook + 0x18, 0x10528B0C )
		call WriteRealMemory( pDamageHook + 0x1C, 0x8BEC5589 )
		call WriteRealMemory( pDamageHook + 0x20, 0x55891055 )
		call WriteRealMemory( pDamageHook + 0x24, 0x14558BF0 )
		call WriteRealMemory( pDamageHook + 0x28, 0x8DF45589 )
		call WriteRealMemory( pDamageHook + 0x2C, 0xC389E84D )
		call WriteRealMemory( pDamageHook + 0x30, 0x4C89138B )
		call WriteRealMemory( pDamageHook + 0x34, 0x03830490 )
		call WriteRealMemory( pDamageHook + 0x38, 0x4D8B9001 )
        
		call WriteRealMemory( pDamageHook + 0x3C, 0x1475FFF8 )
		call WriteRealMemory( pDamageHook + 0x40, 0x8B1075FF )
		call WriteRealMemory( pDamageHook + 0x44, 0x8B500C45 )
		call WriteRealMemory( pDamageHook + 0x48, 0xB8500845 )
		call WriteRealMemory( pDamageHook + 0x4C, PreviousMethod )
		call WriteRealMemory( pDamageHook + 0x50, 0x4589D0FF ) // call eax (PreviousMethod)
		call WriteRealMemory( pDamageHook + 0x54, 0x012B83FC )
		call WriteRealMemory( pDamageHook + 0x58, 0x5BFC458B )
		call WriteRealMemory( pDamageHook + 0x5C, 0x0010C2C9 )
	endfunction

    function Init_MemHackDamageEventHook takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pUnitVtable = pGameDLL + 0x943A94
        elseif PatchVersion == "1.26a" then
                set pUnitVtable = pGameDLL + 0x931934
        elseif PatchVersion == "1.27a" then
                set pUnitVtable = pGameDLL + 0xA4A704
        elseif PatchVersion == "1.27b" then
                set pUnitVtable = pGameDLL + 0xB77EB0
        elseif PatchVersion == "1.28f" then
                set pUnitVtable = pGameDLL + 0xB68914
            endif

            if pUnitVtable > 0 then
                call Init_DamageEventHook( )
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackDamageHook takes nothing returns nothing
    //set gg_trg_MemHackDamageHook = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackBerserkHook
//
// This trigger can be safely removed, since you need to configure Init_BerserkAbilityHook for it to actually do anything.
// Make sure you read the instructions CAREFULLY, mistake is NOT an option!
//===========================================================================
//TESH.scrollpos=93
//TESH.alwaysfold=0
//! nocjass
library MemoryHackBerserkHook
    globals
        integer pBerserkHookProtection = 0
        integer pBerserkOrderAddr      = 0
        integer pBerserkHookMemory     = 0
        integer pBerserkCurMemPos      = 0
        integer pBerserkTotalMemSize   = 0
    endglobals

    function BerserkHookMemAlloc takes integer abilCount returns nothing
        // This is a function that will automatycally allocate necessary memory, this has to be called before BerserkHookEnd( ).
        // The whole point is, to prepare a jump function for the pBerserkOrderAddr, and whatever we write to pBerserkHookMemory, will then be called from pBerserkOrderAddr.
        set pBerserkTotalMemSize = 0x10 * abilCount + 0x4 + 0x4 // size = 0x10 * Abilities hooked + 0x4 (hook start) + 0x4 (hook end)
        // since I hook 3 abilities the result will be -> 0x10 * 3 + 0x4 + 0x4 => 0x30 + 0x8 => 0x38
        set pBerserkHookMemory = AllocateExecutableMemory( pBerserkTotalMemSize )

        //===================================Do NOT touch this!===============================================
        call WriteRealMemory( pBerserkHookMemory +  0x0, 0x3D34418B ) // mov eax, dword ptr[ ecx + 0x34 ];
        //====================================================================================================
    endfunction

    function BerserkHookStart takes nothing returns nothing
        // this has to be called at the very start, so we "remove" function protection, this allows us to modify its bytecode.
        set pBerserkHookProtection = ChangeOffsetProtection( pBerserkOrderAddr, 0xA, 0x40 )
    endfunction

    function BerserkHookEnd takes nothing returns nothing
        // This HAS to be called at the end, so the bytecode is updated with jump to the newly written memory.

        //===================================Do NOT touch this!===============================================
        call WriteRealMemory( pBerserkOrderAddr + 0x0, 0x000000E9 ) // jmp
        call WriteRealMemory( pBerserkOrderAddr + 0x3, 0x00000090 ) // nop
        call WriteRealMemory( pBerserkOrderAddr + 0x1, pBerserkHookMemory - pBerserkOrderAddr - 0x5 )
        set pBerserkHookProtection = ChangeOffsetProtection( pBerserkOrderAddr, 0xA, pBerserkHookProtection )
        //====================================================================================================        
    endfunction

    function SetBerserkOrder takes integer mempos, integer abilId, integer orderId returns nothing
        // Simple function that pushes the said abilId and orderId to the memory position along with the data.
        // This is used in AddBerserkOrder, which is a simplified version, to "remove" the hook, just put an empty abil Id, so the check never picks it up.
        if mempos + 0x10 > pBerserkTotalMemSize then // prevent overflow
            return
        endif

        //===========================Hook Ability Id to change its order Id========================================
        call WriteRealMemory( pBerserkHookMemory + mempos +  0x4,     abilId ) // cmp eax, 'Abil';  | Checks AbilityId
        call WriteRealMemory( pBerserkHookMemory + mempos +  0x8, 0xB8900775 ) // jne next; nop;    | Jump next if not equal
        call WriteRealMemory( pBerserkHookMemory + mempos +  0xC,    orderId ) // mov eax, OrderId; | Sets OrderId to eax
        call WriteRealMemory( pBerserkHookMemory + mempos + 0x10, 0x3D9090C3 ) // retn eax;         | returns eax
        //=========================================================================================================

        // Write at 0x000000C3 to end hooking, this is REQUIRED or game will freeze.
        call WriteRealMemory( pBerserkHookMemory + mempos + 0x14, 0x000000C3 ) // retn | else returns original order (eax)
        // Note, every edit requires for this process to be repeated, until you are finally done.

        set pBerserkCurMemPos = mempos + 0x10
    endfunction

    function SetBerserkOrderByIdEx takes integer abilId, integer newabilId, integer neworderId returns nothing
        local integer i = 0
        local integer mempos = 0

        loop
            set mempos = i * 0x10
            exitwhen mempos > pBerserkCurMemPos

            if ReadRealMemory( mempos + 0x4 ) == abilId then
                call SetBerserkOrder( mempos, newabilId, neworderId )
                return
            endif

            set i = i + 1
        endloop
    endfunction

    function SetBerserkOrderById takes integer abilId, integer neworderId returns nothing
        call SetBerserkOrderByIdEx( abilId, abilId, neworderId )
    endfunction

    function RemoveBerserkOrderById takes integer abilId returns nothing
        call SetBerserkOrderByIdEx( abilId, abilId, 852100 )
    endfunction

    function AddBerserkOrder takes integer abilId, integer orderId returns nothing
        call SetBerserkOrder( pBerserkCurMemPos, abilId, orderId )
    endfunction

    function Init_BerserkHookEx takes integer abilCount returns nothing
        // This is an example, meaning you have to call BerserkAbilityHookStart( ) and BerserkHookMemAlloc( NUMBER ) to allocate memory
        // Then you can add hooks for the abilities with AddBerserkOrder or SetBerserkOrder, AddBerserkOrder simply uses SetBerserkOrder (which is protected from overflow)
        call BerserkHookStart( )
        call BerserkHookMemAlloc( abilCount )

        // These 3 functions will cause 'A000' to return 852099 order id, 'A001' to return 852164 order id and 'A002' to return 852161 order id, instead of the original Berserk order Id.
        call AddBerserkOrder( 'A000', 852099 ) // pBerserkCurMemPos = 0
        call AddBerserkOrder( 'A001', 852164 ) // pBerserkCurMemPos = 0x10
        call AddBerserkOrder( 'A003', 852161 ) // pBerserkCurMemPos = 0x20
        //

        // If you want to "unhook" the ability, you can functions like these: 
        // call SetBerserkOrderByIdEx( 'A000', 'A000', 852100 ) // or call SetBerserkOrderByIdEx( 'A000', 0, 0 ) // but I suggest the former.
        // call RemoveBerserkOrderById( 'A000' ) // this calls to SetBerserkOrderByIdEx
        // call SetBerserkOrderById( 'A000', 852100 ) // this calls to SetBerserkOrderByIdEx
        // Or lastly you can just use the memposition
        // call SetBerserkOrder( 0, 0, 0 ) // as pBerserkCurMemPos = 0 for 'A000' // which would be // call SetBerserkOrder( 0x10, 0, 0 ) // as pBerserkCurMemPos = 0x10 for 'A001'

        call BerserkHookEnd( ) // ALWYS necessary to call at the end, so we push the newly written bytecode to the original function
    endfunction

    function Init_BerserkHook takes nothing returns nothing
        call Init_BerserkHookEx( 3 ) // change with any number you want, this will simply decide how much memory needs to be allocated.
    endfunction

    function Init_MemHackBerserkHook takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pBerserkOrderAddr = pGameDLL + 0x1C7750
        elseif PatchVersion == "1.26a" then
                set pBerserkOrderAddr = pGameDLL + 0x1C6C40
        elseif PatchVersion == "1.27a" then
                set pBerserkOrderAddr = pGameDLL + 0x4C67F0 // return 852100;
        elseif PatchVersion == "1.27b" then
                set pBerserkOrderAddr = pGameDLL + 0x4E3F40
        elseif PatchVersion == "1.28f" then
                set pBerserkOrderAddr = pGameDLL + 0x518060
            endif

            call Init_BerserkHook( )
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackBerserkHook takes nothing returns nothing
    //set gg_trg_MemHackBerserkHook = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCustomAbilityChargesHook
//
// Hook to add/substract "charges" from abilities, these "charges" are only visual, meaning you are forcing the game to simply draw the amount of "charges" you specify.
// Had to rewrite a bit original code and clean it out, also I have added 1.27a support (duh).
//===========================================================================
//TESH.scrollpos=131
//TESH.alwaysfold=0
//! nocjass
library MemoryHackTestAbilityChargesHook
    globals
        integer pDrawAbilityCharges         = 0
        integer pCommonAIJumpOut            = 0
        integer pGameUIAbilityChargesBox    = 0
        integer pGameUIAbilityChargesCount  = 0
        integer pHTLoadInteger              = 0
        integer pHTLoadBoolean              = 0
        integer pUnitUpdateCommandPanel     = 0
    
        hashtable ChargesIndicatorData      = InitHashtable( )
        integer ChargesIndicatorDataHandle  = GetHandleId( ChargesIndicatorData )
        integer pCustomChargesDisplayer     = 0
    endglobals

    function InitCustomChargesData takes nothing returns nothing
        local integer i = 0
        local integer memSize = 0x140 // size = pCustomChargesDisplayer + 0x13C | last offset + 0x4

        set pCustomChargesDisplayer = AllocateExecutableMemory( memSize )

        loop
            exitwhen i > ( memSize - 0x4 )
            call WriteRealMemory( pCustomChargesDisplayer + i, 0x0 )
            set i = i + 4
        endloop

        call WriteRealMemory( pCustomChargesDisplayer +   0x0, 0x0824448B )
        call WriteRealMemory( pCustomChargesDisplayer +   0x4, 0x7C8B5756 )
        call WriteRealMemory( pCustomChargesDisplayer +   0x8, 0x57500C24 )
        call WriteRealMemory( pCustomChargesDisplayer +   0xC, 0x8DE8F18B )
        call WriteRealMemory( pCustomChargesDisplayer +  0x10, 0x85000372 )

        call WriteRealMemory( pCustomChargesDisplayer +  0xF, pDrawAbilityCharges - ( pCustomChargesDisplayer + 0xF ) - 0x4 )

        call WriteRealMemory( pCustomChargesDisplayer +  0x14, 0x397C75FF )
        call WriteRealMemory( pCustomChargesDisplayer +  0x18, 0x777F407E )
        call WriteRealMemory( pCustomChargesDisplayer +  0x1C, 0x51605E5F )
        call WriteRealMemory( pCustomChargesDisplayer +  0x20, 0x4E8B9090 )
        call WriteRealMemory( pCustomChargesDisplayer +  0x24, 0xCC40B830 )
        call WriteRealMemory( pCustomChargesDisplayer +  0x28, 0xD0FF6F2D )

        call WriteRealMemory( pCustomChargesDisplayer +  0x26, pCommonAIJumpOut )

        call WriteRealMemory( pCustomChargesDisplayer +  0x2C, 0x6974C085 )
        call WriteRealMemory( pCustomChargesDisplayer +  0x30, 0x8B905159 )
        call WriteRealMemory( pCustomChargesDisplayer +  0x34, 0x3476FFD8 )
        call WriteRealMemory( pCustomChargesDisplayer +  0x38, 0x99996850 )
        call WriteRealMemory( pCustomChargesDisplayer +  0x3C, 0x10B89999 )

        call WriteRealMemory( pCustomChargesDisplayer +  0x3A, ChargesIndicatorDataHandle )

        call WriteRealMemory( pCustomChargesDisplayer +  0x40, 0xFF6F3CAB )
        call WriteRealMemory( pCustomChargesDisplayer +  0x3F, pHTLoadBoolean )

        call WriteRealMemory( pCustomChargesDisplayer +  0x44, 0x0CC483D0 )
        call WriteRealMemory( pCustomChargesDisplayer +  0x48, 0x4C74C085 )
        call WriteRealMemory( pCustomChargesDisplayer +  0x4C, 0x90905990 )
        call WriteRealMemory( pCustomChargesDisplayer +  0x50, 0x828B168B )
        call WriteRealMemory( pCustomChargesDisplayer +  0x54, 0x00000308 )
        call WriteRealMemory( pCustomChargesDisplayer +  0x58, 0x53347E8B )
        call WriteRealMemory( pCustomChargesDisplayer +  0x5C, 0xD0FFCE8B )
        call WriteRealMemory( pCustomChargesDisplayer +  0x60, 0x533476FF )
        call WriteRealMemory( pCustomChargesDisplayer +  0x64, 0x99999968 )
        call WriteRealMemory( pCustomChargesDisplayer +  0x68, 0xB8D88B99 )
        
        call WriteRealMemory( pCustomChargesDisplayer +  0x65, ChargesIndicatorDataHandle )

        call WriteRealMemory( pCustomChargesDisplayer +  0x6C, pHTLoadInteger )

        call WriteRealMemory( pCustomChargesDisplayer +  0x70, 0xC483D0FF )
        call WriteRealMemory( pCustomChargesDisplayer +  0x74, 0x51C88B0C )
        call WriteRealMemory( pCustomChargesDisplayer +  0x78, 0xCF8BD38B )
        call WriteRealMemory( pCustomChargesDisplayer +  0x7C, 0x332E10B8 )
        call WriteRealMemory( pCustomChargesDisplayer +  0x80, 0x6AD0FF6F )
        
        call WriteRealMemory( pCustomChargesDisplayer +  0x7D, pGameUIAbilityChargesBox )

        call WriteRealMemory( pCustomChargesDisplayer +  0x84, 0x8BD38B01 )
        call WriteRealMemory( pCustomChargesDisplayer +  0x88, 0x2E40B8CF )
        call WriteRealMemory( pCustomChargesDisplayer +  0x8C, 0xD0FF6F33 )
        
        call WriteRealMemory( pCustomChargesDisplayer +  0x8A, pGameUIAbilityChargesCount )

        call WriteRealMemory( pCustomChargesDisplayer +  0x90, 0x5F07EB5B )
        call WriteRealMemory( pCustomChargesDisplayer +  0x94, 0x0008C25E )
        call WriteRealMemory( pCustomChargesDisplayer +  0x98, 0xC2615990 )
        call WriteRealMemory( pCustomChargesDisplayer +  0x9C, 0x90900008 )
        call WriteRealMemory( pCustomChargesDisplayer +  0xA0, 0x0824448B )
        call WriteRealMemory( pCustomChargesDisplayer +  0xA4, 0x7C8B5756 )
        call WriteRealMemory( pCustomChargesDisplayer +  0xA8, 0x57500C24 )
        call WriteRealMemory( pCustomChargesDisplayer +  0xAC, 0x8390F18B )
        call WriteRealMemory( pCustomChargesDisplayer +  0xB0, 0x859008C4 )
        call WriteRealMemory( pCustomChargesDisplayer +  0xB4, 0x397C75FF )
        call WriteRealMemory( pCustomChargesDisplayer +  0xB8, 0x777F407E )
        call WriteRealMemory( pCustomChargesDisplayer +  0xBC, 0x51605E5F )
        call WriteRealMemory( pCustomChargesDisplayer +  0xC0, 0x4E8B9090 )
        call WriteRealMemory( pCustomChargesDisplayer +  0xC4, 0xCC40B830 )
        call WriteRealMemory( pCustomChargesDisplayer +  0xC8, 0xD0FF6F2D )
        
        call WriteRealMemory( pCustomChargesDisplayer +  0xC6, pCommonAIJumpOut )

        call WriteRealMemory( pCustomChargesDisplayer +  0xCC, 0x6974C085 )
        call WriteRealMemory( pCustomChargesDisplayer +  0xD0, 0x8B905159 )
        call WriteRealMemory( pCustomChargesDisplayer +  0xD4, 0x3476FFD8 )
        call WriteRealMemory( pCustomChargesDisplayer +  0xD8, 0x99996850 )
        call WriteRealMemory( pCustomChargesDisplayer +  0xDC, 0x10B89999 )

        call WriteRealMemory( pCustomChargesDisplayer +  0xDA, ChargesIndicatorDataHandle )

        call WriteRealMemory( pCustomChargesDisplayer +  0xE0, 0xFF6F3CAB )

        call WriteRealMemory( pCustomChargesDisplayer +  0xDF, pHTLoadBoolean )

        call WriteRealMemory( pCustomChargesDisplayer +  0xE4, 0x0CC483D0 )
        call WriteRealMemory( pCustomChargesDisplayer +  0xE8, 0x4C74C085 )
        call WriteRealMemory( pCustomChargesDisplayer +  0xEC, 0x90905990 )
        call WriteRealMemory( pCustomChargesDisplayer +  0xF0, 0x828B168B )
        call WriteRealMemory( pCustomChargesDisplayer +  0xF4, 0x00000308 )
        call WriteRealMemory( pCustomChargesDisplayer +  0xF8, 0x53347E8B )
        call WriteRealMemory( pCustomChargesDisplayer +  0xFC, 0xD0FFCE8B )
        call WriteRealMemory( pCustomChargesDisplayer + 0x100, 0x533476FF )
        call WriteRealMemory( pCustomChargesDisplayer + 0x104, 0x99999968 )
        call WriteRealMemory( pCustomChargesDisplayer + 0x108, 0xB8D88B99 )

        call WriteRealMemory( pCustomChargesDisplayer + 0x105, ChargesIndicatorDataHandle )

        call WriteRealMemory( pCustomChargesDisplayer + 0x10C, pHTLoadInteger )

        call WriteRealMemory( pCustomChargesDisplayer + 0x110, 0xC483D0FF )
        call WriteRealMemory( pCustomChargesDisplayer + 0x114, 0x51C88B0C )
        call WriteRealMemory( pCustomChargesDisplayer + 0x118, 0xCF8BD38B )
        call WriteRealMemory( pCustomChargesDisplayer + 0x11C, 0x332E10B8 )
        call WriteRealMemory( pCustomChargesDisplayer + 0x120, 0x6AD0FF6F )

        call WriteRealMemory( pCustomChargesDisplayer + 0x11D, pGameUIAbilityChargesBox )

        call WriteRealMemory( pCustomChargesDisplayer + 0x124, 0x8BD38B01 )
        call WriteRealMemory( pCustomChargesDisplayer + 0x128, 0x2E40B8CF )
        call WriteRealMemory( pCustomChargesDisplayer + 0x12C, 0xD0FF6F33 )

        call WriteRealMemory( pCustomChargesDisplayer + 0x12A, pGameUIAbilityChargesCount )

        call WriteRealMemory( pCustomChargesDisplayer + 0x130, 0x5F07EB5B )
        call WriteRealMemory( pCustomChargesDisplayer + 0x134, 0x0008C25E )
        call WriteRealMemory( pCustomChargesDisplayer + 0x138, 0xC2615990 )
        call WriteRealMemory( pCustomChargesDisplayer + 0x13C, 0x90900008 )
    endfunction

    function InitCustomAbilityAddressChargesHook takes integer pAbil returns nothing
        local integer pData         = 0
        local integer pAddr         = 0
        local integer oldprotection = 0

        if pAbil > 0 then
            set pData = ReadRealMemory( pAbil ) + 0x1C4
            set pAddr = ReadRealMemory( pData )

            if pAddr > 0 then
                if pAddr == pDrawAbilityCharges or pAddr == pGameDLL + 0x00020AF0 then
                    set oldprotection = ChangeOffsetProtection( pData, 0x4, 0x40 )

                    if pAddr == pDrawAbilityCharges then
                        call WriteRealMemory( pData, pCustomChargesDisplayer )
                    elseif pAddr == pGameDLL + 0x00020AF0 then
                        call WriteRealMemory( pData, pCustomChargesDisplayer + 0xA0 )
                    endif

                    call ChangeOffsetProtection( pData, 0x4, oldprotection )
                else
                    call DisplayTextToPlayer( GetLocalPlayer( ), 0, 0, "Invalid Address: " + I2S( pAddr ) )
                endif
            endif
        endif
    endfunction

    function EnableCustomUnitAbilityCharges takes unit u, integer aid returns nothing
        call SaveBoolean( ChargesIndicatorData, GetHandleId( u ), aid, true )
    endfunction

    function DisableCustomUnitAbilityCharges takes unit u, integer aid returns nothing
        call SaveBoolean( ChargesIndicatorData, GetHandleId( u ), aid, false )
    endfunction

    function GetCustomUnitAbilityCharges takes unit u, integer aid returns integer
        return LoadInteger( ChargesIndicatorData, GetHandleId( u ), aid )
    endfunction

    function SetCustomUnitAbilityCharges takes unit u, integer aid, integer charges returns nothing
        if not HaveSavedBoolean( ChargesIndicatorData, GetHandleId( u ), aid ) then
            call InitCustomAbilityAddressChargesHook( GetUnitAbilityData( u, aid, 1 ) )
            call SaveBoolean( ChargesIndicatorData, GetHandleId( u ), aid, true )
        endif

        call SaveInteger( ChargesIndicatorData, GetHandleId( u ), aid, charges )
    endfunction

    function Init_MemHackCustomAbilityChargesHook takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pDrawAbilityCharges         = pGameDLL + 0x0385E0
                set pCommonAIJumpOut            = pGameDLL + 0x2DD760
                set pGameUIAbilityChargesBox    = pGameDLL + 0x333950
                set pGameUIAbilityChargesCount  = pGameDLL + 0x333980
                set pHTLoadInteger              = pGameDLL + 0x3CB5D0
                set pHTLoadBoolean              = pGameDLL + 0x3CB650
        elseif PatchVersion == "1.26a" then
                set pDrawAbilityCharges         = pGameDLL + 0x0378A0
                set pCommonAIJumpOut            = pGameDLL + 0x2DCC40
                set pGameUIAbilityChargesBox    = pGameDLL + 0x332E10
                set pGameUIAbilityChargesCount  = pGameDLL + 0x332E40
                set pHTLoadInteger              = pGameDLL + 0x3CAA90
                set pHTLoadBoolean              = pGameDLL + 0x3CAB10
        elseif PatchVersion == "1.27a" then
                set pDrawAbilityCharges         = pGameDLL + 0x413FE0 // !(*(int (**)(void))(*a1 + 788))() && (!a3 || a4 == v4[27]) )
                set pCommonAIJumpOut            = pGameDLL + 0x88F250 // GetBuilding -> JUMPOUT
                set pGameUIAbilityChargesBox    = pGameDLL + 0x359C00 // v9, v7 + 852027, v11, a2, v9);
                set pGameUIAbilityChargesCount  = pGameDLL + 0x359C30 // under ^
                set pHTLoadInteger              = pGameDLL + 0x1F0710 // LoadInteger
                set pHTLoadBoolean              = pGameDLL + 0x1F04D0 // LoadBoolean
        elseif PatchVersion == "1.27b" then
                set pDrawAbilityCharges         = pGameDLL + 0x431720
                set pCommonAIJumpOut            = pGameDLL + 0x9BA350
                set pGameUIAbilityChargesBox    = pGameDLL + 0x3773A0
                set pGameUIAbilityChargesCount  = pGameDLL + 0x3773D0
                set pHTLoadInteger              = pGameDLL + 0x20E150
                set pHTLoadBoolean              = pGameDLL + 0x20DF10
        elseif PatchVersion == "1.28f" then
                set pDrawAbilityCharges         = pGameDLL + 0x465830
                set pCommonAIJumpOut            = pGameDLL + 0x96F2E0
                set pGameUIAbilityChargesBox    = pGameDLL + 0x3AB4B0
                set pGameUIAbilityChargesCount  = pGameDLL + 0x3AB4E0
                set pHTLoadInteger              = pGameDLL + 0x240940
                set pHTLoadBoolean              = pGameDLL + 0x240700
            endif

            if pDrawAbilityCharges > 0 then
                call InitCustomChargesData( )
                //call ReallocateCallMemory( )
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackCustomAbilityChargesHook takes nothing returns nothing
    //set gg_trg_MemHackCustomAbilityChargesHook = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: Testing
//
// This code can be removed, as it is only is needed for tests it yields no benefits or usage elsewise.
//===========================================================================
//TESH.scrollpos=109
//TESH.alwaysfold=0
//! nocjass
library SystemDebug
    globals
        integer pTempFrame = 0
        unit uTemp = null
        group gTemp = null
        effect eTemp = null
        item itTemp = null
        destructable desTemp = null

        integer pSimpleFrame = 0
        integer pTexture = 0

        hashtable TestTable = InitHashtable( )
        timer testTimer = CreateTimer( )

        boolean testout = true
        boolean iswhexpause = true
    endglobals
endlibrary



library ZzATestCode

function TestBenchmarking takes nothing returns nothing
    local integer p     = 0
    local integer i     = 0
    local integer time  = 0

    set i    = 0
    set time = GetLocalTime( 0 )
    loop
        exitwhen i == 10000
        // Some stuff here

        set i = i + 1
    endloop
    set time  = GetLocalTime( 0 ) - time
    call DisplayTextToPlayer( GetLocalPlayer( ), 0, 0, "First Delay: " + I2S( time ) + "ms" )

    set i    = 0
    set time = GetLocalTime( 0 )
    loop
        exitwhen i == 10000
        // Some other stuff here

        set i = i + 1
    endloop
    set time  = GetLocalTime( 0 ) - time
    call DisplayTextToPlayer( GetLocalPlayer( ), 0, 0, "Second Delay: " + I2S( time ) + "ms" )
endfunction

function Test_Code_3 takes nothing returns nothing
    //local integer pSimpleFrame = 0 //CreateCSimpleFrame( 0 )
    //local integer pTexture = 0 //CreateCSimpleTexture( pSimpleFrame )
    //local real tempx = GetUnitX( uTemp ) - GetCameraTargetPositionX( )
    //local real tempy = GetUnitY( uTemp ) - GetCameraTargetPositionY( )
    local real tempx = 0.
    local real tempy = 0.

    return
    if pTempFrame == 0 and false then
        set pTempFrame = CreateFrame( "UITextCenter", pGameUI, 20 )
        
        if pTempFrame > 0 then
            call SetFrameSize( pTempFrame, .117, .03 )
            call SetFramePoint( pTempFrame, 1, pGameUI, 1, 0, -.007 )
            call SetFrameText( pTempFrame, "Test Frame :)" )
        endif
    endif
    
    if pTexture == 0 then
        set pSimpleFrame = CreateCSimpleFrame( 0 )
        set pTexture     = CreateCSimpleTexture( pSimpleFrame )
        call SetFrameWidth( pTexture, .05 )
        call SetFrameHeight( pTexture, .02 )
        call SetCSimpleTextureTexture( pTexture, "UI\\Feedback\\HPBarConsole\\human-healthbar-fill.blp", true )
        call FillCSimpleTexture( pTexture, 0xFF00FF00 )
        call BJDebugMsg( "SetFramePoint( pSimpleFrame, ANCHOR_TOP, pGameUI, ANCHOR_TOP, 0., 0. ) = " + I2S( SetFramePoint( pSimpleFrame, ANCHOR_TOP, pGameUI, ANCHOR_TOP, 0., 0. ) ) )
        call BJDebugMsg( "SetFramePoint( pTexture, ANCHOR_TOP, GetUIWorldFrameWar3( ), ANCHOR_TOP, 0., 0. ) = " + I2S( SetFramePoint( pTexture, ANCHOR_TOP, GetUIWorldFrameWar3( ), ANCHOR_TOP, 0., 0. ) ) )
        call BJDebugMsg( "UpdateFrame( pSimpleFrame ) = " + I2S( UpdateFrame( pSimpleFrame ) ) )
    endif

    if pTexture > 0 then
        if GetUnitFramePosition( ConvertHandle( uTemp ) ) then
            set tempx = GetRealFromMemory( ReadRealMemory( pUnitFramePosition ) )
            set tempy = GetRealFromMemory( ReadRealMemory( pUnitFramePosition + 0x4 ) )

            call ClearTextMessages( )
            call BJDebugMsg( "GetUnitFramePositionX = " + R2S( tempx ) )
            call BJDebugMsg( "GetUnitFramePositionY = " + R2S( tempy ) )
            //call SetFrameAbsolutePoint( pTexture, ANCHOR_BOTTOM, SetRealIntoMemory( tempx ), SetRealIntoMemory( tempy ) )
            //call BJDebugMsg( "UpdateFrame( pSimpleFrame ) = " + I2S( UpdateFrame( pSimpleFrame ) ) )
        endif
    endif
endfunction

function Test_Code_2 takes nothing returns nothing
    if testout then
        call BJDebugMsg( "pGameDLL: " + IntToHex( pGameDLL ) )
        call BJDebugMsg( "iGameVersion: " + IntToHex( iGameVersion ) )
        call BJDebugMsg( "pJassEnvAddress: "  + IntToHex( pJassEnvAddress ) )
        call BJDebugMsg( "pJassVmAddress: "  + IntToHex( GetJassVM( 1 ) ) )
        call BJDebugMsg( "pJassHandleTable: "  + IntToHex( GetJassTable( ) ) )
        call BJDebugMsg( "GetStringAddress( Test ): "  + IntToHex( GetStringAddress( "Test" ) ) )
        set testout = false
    endif
endfunction

function Test_Code_1 takes nothing returns nothing
    local integer i = 0
    local integer pPointer = 0
    local integer pTempFrame1 = 0
    
    call EnableOPLimit( false ) // This removes operation limit, hence allowing us to use benchmark method above.
    // Since it has over 20000 complex operations, we need to remove limit to complete benchmark without exiting the thread until it fully completes.
    //call LoadTOCFile( "UI\\Data\\List.toc" )

    //set pTempFrame1 = CreateFrame( "ChatHistoryBackdrop", pGameUI, 20 ) //CreateCBackdropFrame( pGameUI, 20 )
    //call SetFrameSize( pTempFrame1, .14 , .373 )
    //call SetFrameAbsolutePoint( pTempFrame1, 0, 0.11, 0.16 )

    set uTemp = CreateUnit( Player( 0 ), 'H000', 100., 50., 270 )
    //call UnitAddAbility( uTemp, 'AOsh' )
    //call SetUnitAbilityLevel( uTemp, 'AOsh', 2 )
    call UnitAddAbility( uTemp, 'A000' )
    call UnitAddAbility( uTemp, 'A001' )
    //call UnitAddAbility( uTemp, 'A002' )
    call UnitAddAbility( uTemp, 'A003' )
    //call SetUnitMaxLife( uTemp, 9999. )
    set itTemp = CreateItem( 'afac', 20., 30. )
    
    call SetCustomUnitAbilityCharges( uTemp, 'A000', 2 )

    call TimerStart( GetExpiredTimer( ), .1, false, function TestBenchmarking )
    //call BJDebugMsg( "iTemp -> " + GetItemBaseName( itTemp ) )
    //
    return
    //call BJDebugMsg( "GetAbilityBaseUIByIdById( 'AOsh' ) = " + IntToHex( GetAbilityBaseUIById( 'AOsh' ) ) )

    call SetAbilityBaseMissleArtById( 'AOsh', "units\\human\\Peasant\\Peasant.mdl" )
    call SetAbilityBaseIconById( 'AOsh', "ReplaceableTextures\\CommandButtons\\BTNMagicLariet.blp" )
    call SetAbilityBaseTipById( 'AOsh', 1, "Hehe test" )
    call SetAbilityBaseUbertipById( 'AOsh', 1, "Data edited :)" )
    call SetAbilityBaseButtonXById( 'AOsh', 1 )
    call SetAbilityBaseButtonYById( 'AOsh', 1 )
    
    //call BJDebugMsg( "GetAbilityBaseMissleArtById( 'AOsh' ) = " + GetAbilityBaseMissleArtById( 'AOsh' ) )
    //call BJDebugMsg( "GetAbilityBaseIconById( 'AOsh' ) = " + GetAbilityBaseIconById( 'AOsh' ) )

    //call BJDebugMsg( "pAttackTrig = " + IntToHex( ReadRealMemory( ReadRealMemory( ReadRealMemory( ConvertHandle( uTemp ) + 0x1E8 ) ) + 0x2CC ) ) ) // 1.26a = 6F0C6920
    // MissleFunc 1.26a = 6F0CF660 

    //call LoadTOCFile( "uitoc.toc" )

    //call TimerStart( GetExpiredTimer( ), .1, false, function TestBenchmarking )
    //call TimerStart( GetExpiredTimer( ), .01, true, function Test_Code_2 )
endfunction

//===========================================================================
function InitTrig_Testing takes nothing returns nothing
    //set gg_trg_Testing = CreateTrigger(  )
    call PanCameraToTimed( 0., 0., 0. )
    call FogEnable( false )
    call FogMaskEnable( false )
    call TimerStart( CreateTimer( ), .1, false, function Test_Code_1 )
endfunction

endlibrary
//! endnocjass
//===========================================================================
// Trigger: MemHackCSpriteUberAPI
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCASpriteUberAPI
    function GetSpriteUberColour takes integer pSpriteUber returns integer
        if pSpriteUber != 0 then
            return ReadRealMemory( pSpriteUber + 0x148 )
        endif

        return 0
    endfunction

    function SetSpriteUberAlpha takes integer pSpriteUber, integer alpha returns nothing
        call SetSpriteBaseAlphaEx( pSpriteUber, alpha, true )
    endfunction    

    function SetSpriteUberColour takes integer pSpriteUber, integer colour returns nothing
        call SetSpriteBaseColourEx( pSpriteUber, colour, true )
    endfunction

    function SetSpriteUberColourEx takes integer pSpriteUber, integer red, integer green, integer blue, integer alpha returns nothing
        if pSpriteUber != 0 then
            call SetSpriteUberColour( pSpriteUber, CreateInteger1( alpha, red, green, blue ) )
        endif
    endfunction
    
    function SetSpriteUberVertexColour takes integer pSpriteUber, integer red, integer green, integer blue, integer alpha returns nothing
        call SetSpriteUberColourEx( pSpriteUber, red, green, blue, alpha )
        //call SetSpriteUberAlpha( pSpriteUber, alpha )
    endfunction

    function GetSpriteUberColourA takes integer pSpriteUber returns integer
        if pSpriteUber != 0 then
            return GetByteFromInteger( GetSpriteUberColour( pSpriteUber ), 1 )
        endif
        
        return -1
    endfunction

    function SetSpriteUberColourA takes integer pSpriteUber, integer alpha returns nothing
        local integer colour = 0

        if pSpriteUber != 0 then
            set colour = GetSpriteUberColour( pSpriteUber )
            call SetSpriteUberColour( pSpriteUber, CreateInteger1( alpha, GetByteFromInteger( colour, 2 ), GetByteFromInteger( colour, 3 ), GetByteFromInteger( colour, 4 ) ) )
        endif
    endfunction

    function GetSpriteUberColourR takes integer pSpriteUber returns integer
        if pSpriteUber != 0 then
            return GetByteFromInteger( GetSpriteUberColour( pSpriteUber ), 2 )
        endif

        return -1
    endfunction

    function SetSpriteUberColourR takes integer pSpriteUber, integer red returns nothing
        local integer colour = 0

        if pSpriteUber != 0 then
            set colour = GetSpriteUberColour( pSpriteUber )
            call SetSpriteUberColour( pSpriteUber, CreateInteger1( GetByteFromInteger( colour, 1 ), red, GetByteFromInteger( colour, 3 ), GetByteFromInteger( colour, 4 ) ) )
        endif
    endfunction
    
    function GetSpriteUberColourG takes integer pSpriteUber returns integer
        if pSpriteUber != 0 then
            return GetByteFromInteger( GetSpriteUberColour( pSpriteUber ), 3 )
        endif

        return -1
    endfunction

    function SetSpriteUberColourG takes integer pSpriteUber, integer green returns nothing
        local integer colour = 0

        if pSpriteUber != 0 then
            set colour = GetSpriteUberColour( pSpriteUber )
            call SetSpriteUberColour( pSpriteUber, CreateInteger1( GetByteFromInteger( colour, 1 ), GetByteFromInteger( colour, 2 ), green, GetByteFromInteger( colour, 4 ) ) )
        endif
    endfunction

    function GetSpriteUberColourB takes integer pSpriteUber returns integer
        if pSpriteUber != 0 then
            return GetByteFromInteger( GetSpriteUberColour( pSpriteUber ), 4 )
        endif

        return -1
    endfunction

    function SetSpriteUberColourB takes integer pSpriteUber, integer blue returns nothing
        local integer colour = 0

        if pSpriteUber != 0 then
            set colour = GetSpriteUberColour( pSpriteUber )
            call SetSpriteUberColour( pSpriteUber, CreateInteger1( GetByteFromInteger( colour, 1 ), GetByteFromInteger( colour, 2 ), GetByteFromInteger( colour, 3 ), blue ) )
        endif
    endfunction
    
    function SetSpriteUberAnimationByIndex takes integer pSpriteUber, integer index returns nothing
        // Does not work on CSpriteUberMini, refer to GetSpriteUber for explanation.

        if pSpriteUber != 0 then
            //call fast_call_3( pSetSpriteUberAnimation, pSpriteUber, index, 0 )
        endif
    endfunction

    function GetSpriteUberX takes integer pSpriteUber returns real
        return GetSpriteBaseFloat( pSpriteUber, 0xC0 )
    endfunction

    function SetSpriteUberX takes integer pSpriteUber, real x returns nothing
        call SetSpriteBaseFloat( pSpriteUber, 0xC0, x )
    endfunction

    function GetSpriteUberY takes integer pSpriteUber returns real
        return GetSpriteBaseFloat( pSpriteUber, 0xC4 )
    endfunction

    function SetSpriteUberY takes integer pSpriteUber, real y returns nothing
        call SetSpriteBaseFloat( pSpriteUber, 0xC4, y )
    endfunction

    function GetSpriteUberZ takes integer pSpriteUber returns real
        return GetSpriteBaseFloat( pSpriteUber, 0xC8 )
    endfunction

    function SetSpriteUberZ takes integer pSpriteUber, real z returns nothing
        call SetSpriteBaseFloat( pSpriteUber, 0xC8, z )
    endfunction

    function SetSpriteUberPosition takes integer pSpriteUber, real x, real y, real z returns nothing
        if pSpriteUber != 0 then
            call WriteRealFloat( pSpriteUber + 0xC0, x )
            call WriteRealFloat( pSpriteUber + 0xC4, y )
            call WriteRealFloat( pSpriteUber + 0xC8, z )
        endif
    endfunction

    function GetSpriteUberTimeScale takes integer pSpriteUber returns real
        return GetSpriteBaseFloat( pSpriteUber, 0x190 )
    endfunction

    function SetSpriteUberTimeScale takes integer pSpriteUber, real speed returns nothing
        call SetSpriteBaseFloat( pSpriteUber, 0x190, speed )
    endfunction

    function GetSpriteUberScale takes integer pSpriteUber returns real
        return GetSpriteBaseScale( pSpriteUber, true )
    endfunction

    function SetSpriteUberScale takes integer pSpriteUber, real scale returns nothing
        call SetSpriteBaseScale( pSpriteUber, scale, true )
    endfunction

    // Effect Rotation API Radians
    function GetSpriteUberYawRad takes integer pSpriteUber returns real // Z | Yaw | returns Degrees!
        return GetSpriteBaseYawRad( pSpriteUber, true )
    endfunction

    function GetSpriteUberPitchRad takes integer pSpriteUber returns real // Y | returns Degrees!
        return GetSpriteBasePitchRad( pSpriteUber, true )
    endfunction

    function GetSpriteUberRollRad takes integer pSpriteUber returns real // X | returns Degrees!
        return GetSpriteBaseRollRad( pSpriteUber, true )
    endfunction

    function GetSpriteUberFacingRad takes integer pSpriteUber returns real // Z | Yaw | returns Degrees!
        return GetSpriteUberYawRad( pSpriteUber )
    endfunction

    function SetSpriteUberSpaceRotationRad takes integer pSpriteUber, real yaw, real pitch, real roll returns nothing
        call SetSpriteBaseSpaceRotationRad( pSpriteUber, yaw, pitch, roll, true )
    endfunction

    function SetSpriteUberYawRad takes integer pSpriteUber, real angle returns nothing // Z Yaw | In Degrees!
        call SetSpriteBaseYawRad( pSpriteUber, angle, true )
    endfunction

    function SetSpriteUberPitchRad takes integer pSpriteUber, real angle returns nothing // Y | In Degrees!
        call SetSpriteBasePitchRad( pSpriteUber, angle, true )
    endfunction

    function SetSpriteUberRollRad takes integer pSpriteUber, real angle returns nothing // X | In Degrees!
        call SetSpriteBaseRollRad( pSpriteUber, angle, true )
    endfunction

    function SetSpriteUberOrientationRad takes integer pSpriteUber, real yaw, real pitch, real roll returns nothing
        call SetSpriteBaseOrientationRad( pSpriteUber, yaw, pitch, roll, true )
    endfunction
    //===================================================================
    
    // Effect Rotation API Degrees
    function SetSpriteUberSpaceRotation takes integer pSpriteUber, real yaw, real pitch, real roll returns nothing
        call SetSpriteUberSpaceRotationRad( pSpriteUber, Deg2Rad( yaw ), Deg2Rad( pitch ), Deg2Rad( roll ) )
    endfunction
    
    function GetSpriteUberYaw takes integer pSpriteUber returns real // Z | Yaw | returns Degrees!
        return Rad2Deg( GetSpriteUberYawRad( pSpriteUber ) )
    endfunction

    function GetSpriteUberFacing takes integer pSpriteUber returns real
        return Rad2Deg( GetSpriteUberFacingRad( pSpriteUber ) )
    endfunction
    
    function GetSpriteUberPitch takes integer pSpriteUber returns real
        return Rad2Deg( GetSpriteUberPitchRad( pSpriteUber ) )
    endfunction

    function GetSpriteUberRoll takes integer pSpriteUber returns real
        return Rad2Deg( GetSpriteUberRollRad( pSpriteUber ) )
    endfunction

    function SetSpriteUberYaw takes integer pSpriteUber, real angle returns nothing
        call SetSpriteUberYawRad( pSpriteUber, Deg2Rad( angle ) )
    endfunction

    function SetSpriteUberFacing takes integer pSpriteUber, real angle returns nothing
        call SetSpriteUberYawRad( pSpriteUber, Deg2Rad( angle ) )
    endfunction

    function SetSpriteUberPitch takes integer pSpriteUber, real angle returns nothing
        call SetSpriteUberPitchRad( pSpriteUber, Deg2Rad( angle ) )
    endfunction

    function SetSpriteUberRoll takes integer pSpriteUber, real angle returns nothing
        call SetSpriteUberRollRad( pSpriteUber, Deg2Rad( angle ) )
    endfunction

    function SetSpriteUberOrientation takes integer pSpriteUber, real yaw, real pitch, real roll returns nothing
        call SetSpriteUberOrientationRad( pSpriteUber, Deg2Rad( yaw ), Deg2Rad( pitch ), Deg2Rad( roll ) )
    endfunction
    //===================================================================

    function SetSpriteUberScaleXYZ takes integer pSpriteUber, real x, real y, real z returns nothing
        call SetSpriteBaseScaleXYZ( pSpriteUber, x, y, z, true )
    endfunction

    function ResetSpriteUberMatrix takes integer pSpriteUber returns nothing
        call ResetSpriteBaseMatrix( pSpriteUber, true )
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackCSpriteUberAPI takes nothing returns nothing
    //set gg_trg_MemHackCSpriteUberAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCSpriteBaseAPI
//===========================================================================
//TESH.scrollpos=290
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCASpriteBaseAPI
    globals
        integer pSetSpriteObjectAnimation = 0
    endglobals

    function GetSpriteBaseFloat takes integer pSpriteBase, integer offset returns real
        if pSpriteBase != 0 then
            return ReadRealFloat( pSpriteBase + offset )
        endif

        return 0.
    endfunction

    function SetSpriteBaseFloat takes integer pSpriteBase, integer offset, real value returns real
        if pSpriteBase != 0 then
            call WriteRealFloat( pSpriteBase + offset, value )
        endif

        return 0.
    endfunction

    function GetSpriteBaseX takes integer pSpriteBase, boolean isuber returns real
        local integer offset = 0
        
        if not isuber then
            set offset = 0x88
        else
            set offset = 0xC0
        endif

        return GetSpriteBaseFloat( pSpriteBase, offset )
    endfunction

    function SetSpriteBaseX takes integer pSpriteBase, real x, boolean isuber returns nothing
        local integer offset = 0
        
        if not isuber then
            set offset = 0x88
        else
            set offset = 0xC0
        endif

        call SetSpriteBaseFloat( pSpriteBase, offset, x )
    endfunction

    function GetSpriteBaseY takes integer pSpriteBase, boolean isuber returns real
        local integer offset = 0
        
        if not isuber then
            set offset = 0x8C
        else
            set offset = 0xC4
        endif

        return GetSpriteBaseFloat( pSpriteBase, offset )
    endfunction

    function SetSpriteBaseY takes integer pSpriteBase, real y, boolean isuber returns nothing
        local integer offset = 0
        
        if not isuber then
            set offset = 0x8C
        else
            set offset = 0xC4
        endif

        call SetSpriteBaseFloat( pSpriteBase, offset, y )
    endfunction

    function GetSpriteBaseZ takes integer pSpriteBase, boolean isuber returns real
        local integer offset = 0
        
        if not isuber then
            set offset = 0x90
        else
            set offset = 0xC8
        endif

        return GetSpriteBaseFloat( pSpriteBase, offset )
    endfunction

    function SetSpriteBaseZ takes integer pSpriteBase, real z, boolean isuber returns nothing
        local integer offset = 0
        
        if not isuber then
            set offset = 0x90
        else
            set offset = 0xC8
        endif

        call SetSpriteBaseFloat( pSpriteBase, offset, z )
    endfunction

    function SetSpriteBasePosition takes integer pSpriteBase, real x, real y, real z, boolean isuber returns nothing
        local integer offset = 0

        if pSpriteBase != 0 then
            if not isuber then
                set offset = pSpriteBase + 0x88
            else
                set offset = pSpriteBase + 0xC0
            endif

            call WriteRealFloat( pSpriteBase + 0x0, x )
            call WriteRealFloat( pSpriteBase + 0x4, y )
            call WriteRealFloat( pSpriteBase + 0x8, z )
        endif
    endfunction    

    function GetSpriteBaseTimeScale takes integer pSpriteUber, boolean isuber returns real
        local integer offset = 0
        
        if not isuber then
            // pSpriteMini->pModelComplex->pAnimationComplex[18] // ((pSpriteMini[8])[38])[18]
        else
            return GetSpriteBaseFloat( pSpriteUber, 0x190 )
        endif

        return 0.
    endfunction

    function GetSpriteBaseScale takes integer pSpriteMini, boolean isuber returns real
        local integer offset = 0
        
        if not isuber then
            set offset = 0x94
        else
            set offset = 0xE8
        endif

        return GetSpriteBaseFloat( pSpriteMini, offset )
    endfunction

    function SetSpriteBaseScale takes integer pSpriteMini, real scale, boolean isuber returns nothing
        local integer offset = 0
        
        if not isuber then
            set offset = 0x94
        else
            set offset = 0xE8
        endif

        call SetSpriteBaseFloat( pSpriteMini, offset, scale )
    endfunction
    
    function UpdateSpriteBase takes integer pSpriteBase returns nothing
        if pSpriteBase != 0 then
            call this_call_1( ReadRealMemory( ReadRealMemory( pSpriteBase ) + 0x14 ), pSpriteBase )
        endif
    endfunction

    function SetSpriteBasePositionEx takes integer pSpriteBase, real x, real y, real z returns nothing
        if pSpriteBase != 0 then
            call WriteRealMemory( pVector3Arg + 0x0, SetRealIntoMemory( x ) )
            call WriteRealMemory( pVector3Arg + 0x4, SetRealIntoMemory( y ) )
            call WriteRealMemory( pVector3Arg + 0x8, SetRealIntoMemory( z ) )
            
            call this_call_2( ReadRealMemory( ReadRealMemory( pSpriteBase ) + 0x1C ), pSpriteBase, pVector3Arg )
        endif
    endfunction

    function SetSpriteBaseScaleEx takes integer pSpriteBase, real scale returns nothing
        if pSpriteBase != 0 then
            call this_call_2( ReadRealMemory( ReadRealMemory( pSpriteBase ) + 0x24 ), pSpriteBase, SetRealIntoMemory( scale ) )
        endif
    endfunction

    function SetSpriteBaseTimeScaleEx takes integer pSpriteBase, real timescale returns nothing
        if pSpriteBase != 0 then
            call this_call_2( ReadRealMemory( ReadRealMemory( pSpriteBase ) + 0x28 ), pSpriteBase, SetRealIntoMemory( timescale ) )
        endif
    endfunction

    function SetSpriteBaseColourEx takes integer pSpriteBase, integer colour, boolean flag returns nothing
        if pSpriteBase != 0 then
            call WriteRealMemory( pReservedIntArg1, colour )
            call this_call_2( ReadRealMemory( ReadRealMemory( pSpriteBase ) + 0x30 ), pSpriteBase, pReservedIntArg1 )

            if flag then
                call UpdateSpriteBase( pSpriteBase )
            endif
        endif
    endfunction

    function SetSpriteBaseAlphaEx takes integer pSpriteBase, integer alpha, boolean flag returns nothing
        if pSpriteBase != 0 and alpha >= 0 and alpha <= 0xFF then
            call this_call_2( ReadRealMemory( ReadRealMemory( pSpriteBase ) + 0x34 ), pSpriteBase, alpha )

            if flag then
                call UpdateSpriteBase( pSpriteBase )
            endif
        endif
    endfunction

    function SetSpriteBaseAnimationByIndexWithRarity takes integer pSpriteBase, integer index, integer rarity returns nothing
        if pSetSpriteObjectAnimation != 0 and pSpriteBase != 0 then
            call fast_call_3( pSetSpriteObjectAnimation, pSpriteBase, index, rarity )
        endif
    endfunction
    
    function SetSpriteBaseAnimationByIndex takes integer pSpriteBase, integer index returns nothing
        call SetSpriteBaseAnimationByIndexWithRarity( pSpriteBase, index, 0 )
    endfunction

    // Effect Rotation API Radians
    function GetSpriteBaseYawRad takes integer pSpriteBase, boolean isuber returns real // Z | Yaw | returns Degrees!
        local integer pMatrix   = 0
        local real r11          = 0.
        local real r21          = 0.
        local real r31          = 0.
        local real yaw          = 0.
        local real pitch        = 0.

        if pSpriteBase != 0 then
            if not isuber then
                set pMatrix = pSpriteBase + 0x64
            else
                set pMatrix = pSpriteBase + 0x108
            endif

            set r11   = ReadRealFloat( pMatrix +  0x0 )
            set r21   = ReadRealFloat( pMatrix +  0xC )
            set r31   = ReadRealFloat( pMatrix + 0x18 )
            set pitch = -Asin( r31 ) // Atan2( -r31, SquareRoot( Pow( r32, 2 ) + Pow( r33, 2 ) ) )
            set yaw   = -Atan2( r21, r11 )

            if yaw < 0 then
                set yaw = 6.28319 + yaw
            endif
        endif

        return yaw
    endfunction

    function GetSpriteBasePitchRad takes integer pSpriteBase, boolean isuber returns real // Y | returns Degrees!
        local integer pMatrix   = 0
        local real r31          = 0.
        local real r32          = 0.
        local real r33          = 0.
        local real pitch        = 0.

        if pSpriteBase != 0 then
            if not isuber then
                set pMatrix = pSpriteBase + 0x7C
            else
                set pMatrix = pSpriteBase + 0x120
            endif

            set r31   = ReadRealFloat( pMatrix + 0x0 )
            set r32   = ReadRealFloat( pMatrix + 0x4 )
            set r33   = ReadRealFloat( pMatrix + 0x8 )
            set pitch = -Asin( r31 ) // Atan2( -r31, SquareRoot( Pow( r32, 2 ) + Pow( r33, 2 ) ) )

            if r31 < 0. and r33 > 0. then
                set pitch = pitch
        elseif r31 < 0. and r33 < 0. then
                set pitch = 3.14159 - pitch
        elseif r31 > 0. and r33 < 0. then
                set pitch = 3.14159 - pitch
        elseif r31 > 0. and r33 > 0. then
                set pitch = 6.28319 + pitch
            endif
        endif
        
        return pitch
    endfunction

    function GetSpriteBaseRollRad takes integer pSpriteBase, boolean isuber returns real // X | returns Degrees!
        local integer pMatrix   = 0
        local real r31          = 0.
        local real r32          = 0.
        local real r33          = 0.
        local real pitch        = 0.
        local real roll         = 0.

        if pSpriteBase != 0 then
            if not isuber then
                set pMatrix = pSpriteBase + 0x7C
            else
                set pMatrix = pSpriteBase + 0x120
            endif

            set r31     = ReadRealFloat( pMatrix + 0x0 )
            set r32     = ReadRealFloat( pMatrix + 0x4 )
            set r33     = ReadRealFloat( pMatrix + 0x8 )
            set pitch   = -Asin( r31 )
            set roll    = Atan2( r32 / Cos( pitch ), r33 / Cos( pitch ) )

            if roll < 0. then
                set roll = 6.28319 + roll
            endif
        endif
        
        return roll
    endfunction

    function GetSpriteBaseFacingRad takes integer pSpriteBase, boolean isuber returns real // Z | Yaw | returns Degrees!
        return GetSpriteBaseYawRad( pSpriteBase, isuber )
    endfunction

    function SetSpriteBaseSpaceRotationRad takes integer pSpriteBase, real yaw, real pitch, real roll, boolean isuber returns nothing
        local integer pMatrix   = 0
        local real Sx = Sin( roll )
        local real Sy = Sin( pitch )
        local real Sz = Sin( -yaw )
        local real Cx = Cos( roll )
        local real Cy = Cos( pitch )
        local real Cz = Cos( -yaw )

        if pSpriteBase != 0 then
            if not isuber then
                set pMatrix = pSpriteBase + 0x64
            else
                set pMatrix = pSpriteBase + 0x108
            endif

            call WriteRealFloat( pMatrix +  0x0, Cy * Cz )
            call WriteRealFloat( pMatrix +  0x4, -Cy * Sz )
            call WriteRealFloat( pMatrix +  0x8, Sy )
            call WriteRealFloat( pMatrix +  0xC, Cz * Sx * Sy + Cx * Sz )
            call WriteRealFloat( pMatrix + 0x10, Cx * Cz - Sx * Sy * Sz )
            call WriteRealFloat( pMatrix + 0x14, -Cy * Sx )
            call WriteRealFloat( pMatrix + 0x18, -Cx * Cz * Sy + Sx * Sz )
            call WriteRealFloat( pMatrix + 0x1C, Cz * Sx + Cx * Sy * Sz )
            call WriteRealFloat( pMatrix + 0x20, Cx * Cy )
        endif
    endfunction

    function SetSpriteBaseYawRad takes integer pSpriteBase, real angle, boolean isuber returns nothing // Z Yaw | In Degrees!
        local integer pMatrix   = 0
        local real r31          = 0.
        local real r32          = 0.
        local real r33          = 0.
        local real pitch        = 0.
        local real roll         = 0.

        if pSpriteBase != 0 then
            if not isuber then
                set pMatrix = pSpriteBase + 0x7C
            else
                set pMatrix = pSpriteBase + 0x120
            endif

            set r31      = ReadRealFloat( pMatrix + 0x0 )
            set r32      = ReadRealFloat( pMatrix + 0x4 )
            set r33      = ReadRealFloat( pMatrix + 0x8 )
            set pitch    = -Asin( r31 ) //Atan2( -r31, SquareRoot( Pow( r32, 2 ) + Pow( r33, 2 ) ) )
            set roll     = Atan2( r32 / Cos( pitch ), r33 / Cos( pitch ) )

            call SetSpriteBaseSpaceRotationRad( pSpriteBase, angle, pitch, roll, isuber )
        endif
    endfunction

    function SetSpriteBasePitchRad takes integer pSpriteBase, real angle, boolean isuber returns nothing // Y | In Degrees!
        local integer pMatrix   = 0
        local real r11          = 0.
        local real r21          = 0.
        local real r32          = 0.
        local real r33          = 0.
        local real yaw          = 0.
        local real roll         = 0.

        if pSpriteBase != 0 then
            if not isuber then
                set pMatrix = pSpriteBase + 0x64
            else
                set pMatrix = pSpriteBase + 0x108
            endif

            set r11     = ReadRealFloat( pMatrix + 0x0 )
            set r21     = ReadRealFloat( pMatrix + 0xC )
            set r32     = ReadRealFloat( pMatrix + 0x1C )
            set r33     = ReadRealFloat( pMatrix + 0x20 )
            set yaw     = Atan2( r21 / Cos( angle ), r11 / Cos( angle ) )
            set roll    = Atan2( r32 / Cos( angle ), r33 / Cos( angle ) )

            call SetSpriteBaseSpaceRotationRad( pSpriteBase, yaw, angle, roll, isuber )
        endif
    endfunction

    function SetSpriteBaseRollRad takes integer pSpriteBase, real angle, boolean isuber returns nothing // X | In Degrees!
        local integer pMatrix   = 0
        local real r11          = 0.
        local real r21          = 0.
        local real r31          = 0.
        local real yaw          = 0.
        local real pitch        = 0.

        if pSpriteBase != 0 then
            if not isuber then
                set pMatrix = pSpriteBase + 0x64
            else
                set pMatrix = pSpriteBase + 0x108
            endif

            set r11     = ReadRealFloat( pMatrix +  0x0 )
            set r21     = ReadRealFloat( pMatrix +  0xC )
            set r31     = ReadRealFloat( pMatrix + 0x18 )
            set pitch   = -Asin( r31 ) // Atan2( -r31, SquareRoot( Pow( r32, 2 ) + Pow( r33, 2 ) ) )
            set yaw     = Atan2( r21 / Cos( pitch ), r11 / Cos( pitch ) )

            call SetSpriteBaseSpaceRotationRad( pSpriteBase, yaw, pitch, angle, isuber )
        endif
    endfunction

    function SetSpriteBaseOrientationRad takes integer pSpriteBase, real yaw, real pitch, real roll, boolean isuber returns nothing
        if pSpriteBase != 0 then
            call SetSpriteBaseSpaceRotationRad( pSpriteBase, yaw, pitch, roll, isuber )
        endif
    endfunction
    //===================================================================
    
    // Effect Rotation API Degrees
    function SetSpriteBaseSpaceRotation takes integer pSpriteBase, real yaw, real pitch, real roll, boolean isuber returns nothing
        call SetSpriteBaseSpaceRotationRad( pSpriteBase, Deg2Rad( yaw ), Deg2Rad( pitch ), Deg2Rad( roll ), isuber )
    endfunction
    
    function GetSpriteBaseYaw takes integer pSpriteBase, boolean isuber returns real // Z | Yaw | returns Degrees!
        return Rad2Deg( GetSpriteBaseYawRad( pSpriteBase, isuber ) )
    endfunction

    function GetSpriteBaseFacing takes integer pSpriteBase, boolean isuber returns real
        return Rad2Deg( GetSpriteBaseFacingRad( pSpriteBase, isuber ) )
    endfunction
    
    function GetSpriteBasePitch takes integer pSpriteBase, boolean isuber returns real
        return Rad2Deg( GetSpriteBasePitchRad( pSpriteBase, isuber ) )
    endfunction

    function GetSpriteBaseRoll takes integer pSpriteBase, boolean isuber returns real
        return Rad2Deg( GetSpriteBaseRollRad( pSpriteBase, isuber ) )
    endfunction

    function SetSpriteBaseYaw takes integer pSpriteBase, real angle, boolean isuber returns nothing
        call SetSpriteBaseYawRad( pSpriteBase, Deg2Rad( angle ), isuber )
    endfunction

    function SetSpriteBaseFacing takes integer pSpriteBase, real angle, boolean isuber returns nothing
        call SetSpriteBaseYawRad( pSpriteBase, Deg2Rad( angle ), isuber )
    endfunction

    function SetSpriteBasePitch takes integer pSpriteBase, real angle, boolean isuber returns nothing
        call SetSpriteBasePitchRad( pSpriteBase, Deg2Rad( angle ), isuber )
    endfunction

    function SetSpriteBaseRoll takes integer pSpriteBase, real angle, boolean isuber returns nothing
        call SetSpriteBaseRollRad( pSpriteBase, Deg2Rad( angle ), isuber )
    endfunction

    function SetSpriteBaseOrientation takes integer pSpriteBase, real yaw, real pitch, real roll, boolean isuber returns nothing
        call SetSpriteBaseOrientationRad( pSpriteBase, Deg2Rad( yaw ), Deg2Rad( pitch ), Deg2Rad( roll ), isuber )
    endfunction
    //===================================================================

    function SetSpriteBaseScaleXYZ takes integer pSpriteBase, real x, real y, real z, boolean isuber returns nothing
        local integer pMatrix   = 0

        if pSpriteBase != 0 then
            if not isuber then
                set pMatrix = pSpriteBase + 0x64
            else
                set pMatrix = pSpriteBase + 0x108
            endif

            call WriteRealFloat( pMatrix +  0x0, x )
            call WriteRealFloat( pMatrix + 0x10, y )
            call WriteRealFloat( pMatrix + 0x20, z )
        endif
    endfunction

    function ResetSpriteBaseMatrix takes integer pSpriteBase, boolean isuber returns nothing
        local integer pMatrix   = 0

        if pSpriteBase != 0 then
            if not isuber then
                set pMatrix = pSpriteBase + 0x64
            else
                set pMatrix = pSpriteBase + 0x108
            endif

            call WriteRealFloat( pMatrix +  0x0, 1. )
            call WriteRealFloat( pMatrix +  0x4, 0. )
            call WriteRealFloat( pMatrix +  0x8, 0. )
            call WriteRealFloat( pMatrix +  0xC, 0. )
            call WriteRealFloat( pMatrix + 0x10, 1. )
            call WriteRealFloat( pMatrix + 0x14, 0. )
            call WriteRealFloat( pMatrix + 0x18, 0. )
            call WriteRealFloat( pMatrix + 0x1C, 0. )
            call WriteRealFloat( pMatrix + 0x20, 1. )
        endif
    endfunction

    function Init_MemHackCSpriteBaseAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then
                set pSetSpriteObjectAnimation = pGameDLL + 0x4D8700
        elseif PatchVersion == "1.26a" then
                set pSetSpriteObjectAnimation = pGameDLL + 0x4D7C00
        elseif PatchVersion == "1.27a" then
                set pSetSpriteObjectAnimation = pGameDLL + 0x186820 // v20 = *v6 & 0x1000000;
        elseif PatchVersion == "1.27b" then
                set pSetSpriteObjectAnimation = pGameDLL + 0x1A4540
        elseif PatchVersion == "1.28f" then
                set pSetSpriteObjectAnimation = pGameDLL + 0x1D6DD0
            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackCSpriteBaseAPI takes nothing returns nothing
    //set gg_trg_MemHackCSpriteBaseAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
// Trigger: MemHackCSpriteMiniAPI
//===========================================================================
//TESH.scrollpos=136
//TESH.alwaysfold=0
//! nocjass
library MemoryHackCASpriteMiniAPI
    function GetSpriteMiniX takes integer pSpriteMini returns real
        return GetSpriteBaseX( pSpriteMini, false )
    endfunction

    function SetSpriteMiniX takes integer pSpriteMini, real x returns nothing
        call SetSpriteBaseX( pSpriteMini, x, false )
    endfunction

    function GetSpriteMiniY takes integer pSpriteMini returns real
        return GetSpriteBaseY( pSpriteMini, false )
    endfunction

    function SetSpriteMiniY takes integer pSpriteMini, real y returns nothing
        call SetSpriteBaseY( pSpriteMini, y, false )
    endfunction

    function GetSpriteMiniZ takes integer pSpriteMini returns real
        return GetSpriteBaseZ( pSpriteMini, false )
    endfunction

    function SetSpriteMiniZ takes integer pSpriteMini, real z returns nothing
        call SetSpriteBaseZ( pSpriteMini, z, false )
    endfunction

    function SetSpriteMiniPosition takes integer pSpriteMini, real x, real y, real z returns nothing
        call SetSpriteBasePosition( pSpriteMini, x, y, z, false )
    endfunction

    function GetSpriteMiniTimeScale takes integer pSpriteMini returns real
        // pSpriteMini->pModelComplex->pAnimationComplex[18] // ((pSpriteMini[8])[38])[18]
        return 0.
    endfunction

    function SetSpriteMiniTimeScale takes integer pSpriteMini, real speed returns nothing
        call SetSpriteBaseTimeScaleEx( pSpriteMini, speed )
    endfunction

    function GetSpriteMiniScale takes integer pSpriteMini returns real
        return GetSpriteBaseScale( pSpriteMini, false )
    endfunction

    function SetSpriteMiniScale takes integer pSpriteMini, real scale returns nothing
        call SetSpriteBaseScale( pSpriteMini, scale, false )
    endfunction

    function SetSpriteMiniPositionEx takes integer pSpriteMini, real x, real y, real z returns nothing
        call SetSpriteBasePositionEx( pSpriteMini, x, y, z )
    endfunction

    function SetSpriteMiniScaleEx takes integer pSpriteMini, real scale returns nothing
        call SetSpriteBaseScaleEx( pSpriteMini, scale )
    endfunction

    function SetSpriteMiniColour takes integer pSpriteMini, integer colour, boolean flag returns nothing
        call SetSpriteBaseColourEx( pSpriteMini, colour, flag )
    endfunction

    function SetSpriteMiniAlpha takes integer pSpriteMini, integer alpha, boolean flag returns nothing
        call SetSpriteBaseAlphaEx( pSpriteMini, alpha, flag )
    endfunction

    function SetSpriteMiniAnimationByIndexWithRarity takes integer pSpriteMini, integer index, integer rarity returns nothing
        call SetSpriteBaseAnimationByIndexWithRarity( pSpriteMini, index, rarity )
    endfunction
    
    function SetSpriteMiniAnimationByIndex takes integer pSpriteMini, integer index returns nothing
        call SetSpriteMiniAnimationByIndexWithRarity( pSpriteMini, index, 0 )
    endfunction
    
    // Effect Rotation API Radians
    function GetSpriteMiniYawRad takes integer pSpriteMini returns real // Z | Yaw | returns Degrees!
        return GetSpriteBaseYawRad( pSpriteMini, false )
    endfunction

    function GetSpriteMiniPitchRad takes integer pSpriteMini returns real // Y | returns Degrees!
        return GetSpriteBasePitchRad( pSpriteMini, false )
    endfunction

    function GetSpriteMiniRollRad takes integer pSpriteMini returns real // X | returns Degrees!
        return GetSpriteBaseRollRad( pSpriteMini, false )
    endfunction

    function GetSpriteMiniFacingRad takes integer pSpriteMini returns real // Z | Yaw | returns Degrees!
        return GetSpriteMiniYawRad( pSpriteMini )
    endfunction

    function SetSpriteMiniSpaceRotationRad takes integer pSpriteMini, real yaw, real pitch, real roll returns nothing
        call SetSpriteBaseSpaceRotationRad( pSpriteMini, yaw, pitch, roll, false )
    endfunction

    function SetSpriteMiniYawRad takes integer pSpriteMini, real angle returns nothing // Z Yaw | In Degrees!
        call SetSpriteBaseYawRad( pSpriteMini, angle, false )
    endfunction

    function SetSpriteMiniPitchRad takes integer pSpriteMini, real angle returns nothing // Y | In Degrees!
        call SetSpriteBasePitchRad( pSpriteMini, angle, false )
    endfunction

    function SetSpriteMiniRollRad takes integer pSpriteMini, real angle returns nothing // X | In Degrees!
        call SetSpriteBaseRollRad( pSpriteMini, angle, false )
    endfunction

    function SetSpriteMiniOrientationRad takes integer pSpriteMini, real yaw, real pitch, real roll returns nothing
        call SetSpriteBaseOrientationRad( pSpriteMini, yaw, pitch, roll, false )
    endfunction
    //===================================================================
    
    // Effect Rotation API Degrees
    function SetSpriteMiniSpaceRotation takes integer pSpriteMini, real yaw, real pitch, real roll returns nothing
        call SetSpriteMiniSpaceRotationRad( pSpriteMini, Deg2Rad( yaw ), Deg2Rad( pitch ), Deg2Rad( roll ) )
    endfunction
    
    function GetSpriteMiniYaw takes integer pSpriteMini returns real // Z | Yaw | returns Degrees!
        return Rad2Deg( GetSpriteMiniYawRad( pSpriteMini ) )
    endfunction

    function GetSpriteMiniFacing takes integer pSpriteMini returns real
        return Rad2Deg( GetSpriteMiniFacingRad( pSpriteMini ) )
    endfunction
    
    function GetSpriteMiniPitch takes integer pSpriteMini returns real
        return Rad2Deg( GetSpriteMiniPitchRad( pSpriteMini ) )
    endfunction

    function GetSpriteMiniRoll takes integer pSpriteMini returns real
        return Rad2Deg( GetSpriteMiniRollRad( pSpriteMini ) )
    endfunction

    function SetSpriteMiniYaw takes integer pSpriteMini, real angle returns nothing
        call SetSpriteMiniYawRad( pSpriteMini, Deg2Rad( angle ) )
    endfunction

    function SetSpriteMiniFacing takes integer pSpriteMini, real angle returns nothing
        call SetSpriteMiniYawRad( pSpriteMini, Deg2Rad( angle ) )
    endfunction

    function SetSpriteMiniPitch takes integer pSpriteMini, real angle returns nothing
        call SetSpriteMiniPitchRad( pSpriteMini, Deg2Rad( angle ) )
    endfunction

    function SetSpriteMiniRoll takes integer pSpriteMini, real angle returns nothing
        call SetSpriteMiniRollRad( pSpriteMini, Deg2Rad( angle ) )
    endfunction

    function SetSpriteMiniOrientation takes integer pSpriteMini, real yaw, real pitch, real roll returns nothing
        call SetSpriteMiniOrientationRad( pSpriteMini, Deg2Rad( yaw ), Deg2Rad( pitch ), Deg2Rad( roll ) )
    endfunction
    //===================================================================

    function SetSpriteMiniScaleXYZ takes integer pSpriteMini, real x, real y, real z returns nothing
        call SetSpriteBaseScaleXYZ( pSpriteMini, x, y, z, false )
    endfunction

    function ResetSpriteMiniMatrix takes integer pSpriteMini returns nothing
        call ResetSpriteBaseMatrix( pSpriteMini, false )
    endfunction

    function Init_MemHackCSpriteMiniAPI takes nothing returns nothing
        if PatchVersion != "" then
            if PatchVersion == "1.24e" then

        elseif PatchVersion == "1.26a" then

        elseif PatchVersion == "1.27a" then

        elseif PatchVersion == "1.27b" then

        elseif PatchVersion == "1.28f" then

            endif
        endif
    endfunction
endlibrary

//===========================================================================
function InitTrig_MemHackCSpriteMiniAPI takes nothing returns nothing
    //set gg_trg_MemHackCSpriteMiniAPI = CreateTrigger(  )
endfunction
//! endnocjass
//===========================================================================
function InitCustomTriggers takes nothing returns nothing
    call InitTrig_APIBasicUtils(  )
    call InitTrig_APITypecast(  )
    call InitTrig_APIMemory(  )
    call InitTrig_APIMemoryCalls(  )
    call InitTrig_APIMemoryBitwise(  )
    call InitTrig_APIMemoryString(  )
    call InitTrig_APIMemoryKernel(  )
    call InitTrig_APIMemoryMPQ(  )
    call InitTrig_APIMemoryRestorer(  )
    call InitTrig_APIMemoryStormDLL(  )
    call InitTrig_APIMemoryGameData(  )
    call InitTrig_MemHackCObjectAPI(  )
    call InitTrig_APIMemoryGameUI(  )
    call InitTrig_APIMemoryGameUIButton(  )
    call InitTrig_APIMemoryGameWindow(  )
    call InitTrig_MemHackConstantsAPI(  )
    call InitTrig_MemHackCFrameAPI(  )
    call InitTrig_MemHackCLayerAPI(  )
    call InitTrig_MemHackCLayoutFrameAPI(  )
    call InitTrig_MemHackCBackDropFrameAPI(  )
    call InitTrig_MemHackCEditBoxAPI(  )
    call InitTrig_MemHackCModelFrameAPI(  )
    call InitTrig_MemHackCSimpleButtonAPI(  )
    call InitTrig_MemHackCSimpleFontAPI(  )
    call InitTrig_MemHackCSimpleGlueAPI(  )
    call InitTrig_MemHackCSimpleFrameAPI(  )
    call InitTrig_MemHackCSimpleMessageFrameAPI(  )
    call InitTrig_MemHackCSliderAPI(  )
    call InitTrig_MemHackCSpriteFrameAPI(  )
    call InitTrig_MemHackCTextAreaAPI(  )
    call InitTrig_MemHackCTextFrameAPI(  )
    call InitTrig_MemHackCSimpleStatusBarAPI(  )
    call InitTrig_MemHackCStatusBarAPI(  )
    call InitTrig_MemHackCSimpleTextureAPI(  )
    call InitTrig_MemHackCSimpleRegionAPI(  )
    call InitTrig_MemHackFrameAPI(  )
    call InitTrig_MemHackUIAPI(  )
    call InitTrig_MemHackPlayerAPI(  )
    call InitTrig_MemHackAbilityAddressAPI(  )
    call InitTrig_MemHackAbilityBaseAPI(  )
    call InitTrig_MemHackAbilityNormalAPI(  )
    call InitTrig_MemHackAbilityUnitAPI(  )
    call InitTrig_MemHackCastAbility(  )
    call InitTrig_MemHackWidgetBaseAPI(  )
    call InitTrig_MemHackWidgetNormalAPI(  )
    call InitTrig_MemHackEffectAPI(  )
    call InitTrig_MemHackTrackableAPI(  )
    call InitTrig_MemHackItemBaseAPI(  )
    call InitTrig_MemHackItemNormalAPI(  )
    call InitTrig_MemHackUnitBaseAPI(  )
    call InitTrig_MemHackUnitNormalAPI(  )
    call InitTrig_MemHackGroupAPI(  )
    call InitTrig_MemHackMouseAPI(  )
    call InitTrig_InitMemoryHack(  )
    call InitTrig_InitMainHook(  )
    call InitTrig_TestHookedDamageEvent(  )
    call InitTrig_MemHackDrawCooldown(  )
    call InitTrig_MemHackDamageHook(  )
    call InitTrig_MemHackBerserkHook(  )
    call InitTrig_MemHackCustomAbilityChargesHook(  )
    call InitTrig_Testing(  )
    call InitTrig_MemHackCSpriteUberAPI(  )
    call InitTrig_MemHackCSpriteBaseAPI(  )
    call InitTrig_MemHackCSpriteMiniAPI(  )
endfunction

//***************************************************************************
//*
//*  Players
//*
//***************************************************************************

function InitCustomPlayerSlots takes nothing returns nothing

    // Player 0
    call SetPlayerStartLocation( Player(0), 0 )
    call ForcePlayerStartLocation( Player(0), 0 )
    call SetPlayerColor( Player(0), ConvertPlayerColor(0) )
    call SetPlayerRacePreference( Player(0), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(0), false )
    call SetPlayerController( Player(0), MAP_CONTROL_USER )

    // Player 1
    call SetPlayerStartLocation( Player(1), 1 )
    call ForcePlayerStartLocation( Player(1), 1 )
    call SetPlayerColor( Player(1), ConvertPlayerColor(1) )
    call SetPlayerRacePreference( Player(1), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(1), false )
    call SetPlayerController( Player(1), MAP_CONTROL_USER )

    // Player 2
    call SetPlayerStartLocation( Player(2), 2 )
    call ForcePlayerStartLocation( Player(2), 2 )
    call SetPlayerColor( Player(2), ConvertPlayerColor(2) )
    call SetPlayerRacePreference( Player(2), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(2), false )
    call SetPlayerController( Player(2), MAP_CONTROL_USER )

    // Player 3
    call SetPlayerStartLocation( Player(3), 3 )
    call ForcePlayerStartLocation( Player(3), 3 )
    call SetPlayerColor( Player(3), ConvertPlayerColor(3) )
    call SetPlayerRacePreference( Player(3), RACE_PREF_HUMAN )
    call SetPlayerRaceSelectable( Player(3), false )
    call SetPlayerController( Player(3), MAP_CONTROL_USER )

endfunction

function InitCustomTeams takes nothing returns nothing
    // Force: TRIGSTR_002
    call SetPlayerTeam( Player(0), 0 )
    call SetPlayerState( Player(0), PLAYER_STATE_ALLIED_VICTORY, 1 )
    call SetPlayerTeam( Player(1), 0 )
    call SetPlayerState( Player(1), PLAYER_STATE_ALLIED_VICTORY, 1 )

    //   Allied
    call SetPlayerAllianceStateAllyBJ( Player(0), Player(1), true )
    call SetPlayerAllianceStateAllyBJ( Player(1), Player(0), true )

    //   Shared Vision
    call SetPlayerAllianceStateVisionBJ( Player(0), Player(1), true )
    call SetPlayerAllianceStateVisionBJ( Player(1), Player(0), true )

    // Force: TRIGSTR_010
    call SetPlayerTeam( Player(2), 1 )
    call SetPlayerState( Player(2), PLAYER_STATE_ALLIED_VICTORY, 1 )
    call SetPlayerTeam( Player(3), 1 )
    call SetPlayerState( Player(3), PLAYER_STATE_ALLIED_VICTORY, 1 )

    //   Allied
    call SetPlayerAllianceStateAllyBJ( Player(2), Player(3), true )
    call SetPlayerAllianceStateAllyBJ( Player(3), Player(2), true )

    //   Shared Vision
    call SetPlayerAllianceStateVisionBJ( Player(2), Player(3), true )
    call SetPlayerAllianceStateVisionBJ( Player(3), Player(2), true )

endfunction

//***************************************************************************
//*
//*  Main Initialization
//*
//***************************************************************************

//===========================================================================
function main takes nothing returns nothing
    call SetCameraBounds( -3328.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), -3584.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 3328.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 3072.0 - GetCameraMargin(CAMERA_MARGIN_TOP), -3328.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), 3072.0 - GetCameraMargin(CAMERA_MARGIN_TOP), 3328.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), -3584.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM) )
    call SetDayNightModels( "Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl", "Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl" )
    call NewSoundEnvironment( "Default" )
    call SetAmbientDaySound( "LordaeronSummerDay" )
    call SetAmbientNightSound( "LordaeronSummerNight" )
    call SetMapMusic( "Music", true, 0 )
    call CreateAllUnits(  )
    call InitBlizzard(  )
    call InitGlobals(  )
    call InitCustomTriggers(  )

endfunction

//***************************************************************************
//*
//*  Map Configuration
//*
//***************************************************************************

function config takes nothing returns nothing
    call SetMapName( "MemHackAPI v1.7" )
    call SetMapDescription( "A map dedicated for testing MemHack vast API, preferably test before you decide on using this API.

Thanks to leandrotp and Dracol1ch for creating the foundation of MemHack. Addtional thanks to quq_CCCP for helping and testing." )
    call SetPlayers( 4 )
    call SetTeams( 4 )
    call SetGamePlacement( MAP_PLACEMENT_TEAMS_TOGETHER )

    call DefineStartLocation( 0, -2560.0, -128.0 )
    call DefineStartLocation( 1, -2560.0, 832.0 )
    call DefineStartLocation( 2, 2368.0, -192.0 )
    call DefineStartLocation( 3, 2368.0, 832.0 )

    // Player setup
    call InitCustomPlayerSlots(  )
    call InitCustomTeams(  )
endfunction

